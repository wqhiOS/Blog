{"pages":[{"title":"","text":"LJpMHcjgdy","link":"/baidu_verify_LJpMHcjgdy.html"},{"title":"关于我","text":"于15年从事iOS开发至今，16年毕业于河南大学软件工程系；现居住于上海 工作经历 智慧树网 时间：2018年5月~至今 行业类别：互联网教育 职位：iOS高级开发工程师 善林(上海)金融信息服务有限公司 时间：2015年7月~2018年4月 行业类别：金融 职位：iOS开发工程师 上海思霍网络有限公司 时间：2015年1月~2015年月7月 行业类别：互联网电子商务 职位：iOS开发工程师 联系方式： wuqh_ios@icloud.com","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"schedule","text":"","link":"/schedule/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Objective-C类对象","text":"什么是类对象？在Objective-C中任何的类定义都是对象。即在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个“描述其定义的对象”，也就是苹果公司说的类对象（class object），它是一个单例。 类对象起什么作用？Objective-C是一门很动态的语音，因此程序里的所有实例对象都是在运行时由Objective-Cd的运行时库生成的，而这个类对象就是运行时库用来创建实例对象的依据。 ClassObjective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下： 123// An opaque type that represents an Objective-Cclass.typedef struct objc_class *Class; 查看objc/runtime.h中objc_class结构体的定义如下： 1234567891011121314151617181920212223242526272829303132333435struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !OBJC2 Class _Nullablesuper_class OBJC2_UNAVAILABLE; const char* _Nonnull name OBJC2_UNAVAILABLE; longversion OBJC2_UNAVAILABLE; longinfo OBJC2_UNAVAILABLE; longinstance_size OBJC2_UNAVAILABLE; structobjc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; structobjc_method_list * _Nullable * _NullablemethodLists OBJC2_UNAVAILABLE; structobjc_cache * _Nonnull cache OBJC2_UNAVAILABLE; structobjc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif } OBJC2_UNAVAILABLE;/* Use Class instead of struct objc_class * */ id与objc_object“objc_object”是表示一个类的实例的结构体，它的定义如下 12345678910/// Represents an instance of a class.struct objc_object { Class _Nonnullisa OBJC_ISA_AVAILABILITY;}; /// A pointer to an instance of a class.typedef struct objc_object *id; 可以看到，这个结构体只有一个变量，即指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类的方法列表以及父类的方法列表里中寻找与消息对应的selector指向的方法。 当创建一个特定类的实例对象时，分配的内存包含一个objc_object数据结构，然后是类的实例变量的数据。NSObject类的alloch和allocWithZone：方法使用函数class_creatInstance来创建objc_object数据结构。 元类（Meta Class）上面提到，所有的类自身也是一个对象，我们可以向这个类型发送消息（即调用类方法）。 NSArray*array = [ NSArray array]; 这个例子中，+array消息发送给了NSArray类，而这个NSArray也是一个对象。既然是对象，那么它也是一个objc_object指针，它包含一个指向其类的一个isa指针。那么这些就又一个问题了。这个isa指针指向什么呢？为了调用+array方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念。 meta-class 是一个类对象的类。 当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。 meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。 再深入一下。meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类，而基类的meta-class的isa指针是指向它自己。这就形成了一个完美的闭环。 123456789101112131415161718void testMetaClass(id self,SEL _cmd) { NSLog(@\"This object is %p\",self); NSLog(@\"Class is %@,super class is %@\",[self class],[self superclass]); Class currentClass = [self class]; for (int i = 0; i &lt; 4; i++) { NSLog(@\"Following the isa pointer %d times gives %p\",i,currentClass); currentClass = objc_getClass((__bridge void *)currentClass); } NSLog(@\"NSObject's class is %p\",[NSObject class]); NSLog(@\"NSObject's meta class is %p\",objc_getClass((__bridge void*)[NSObject class]));} Class newClass = objc_allocateClassPair([NSError class], \"TestClass\", 0); class_addMethod(newClass, @selector(testMetaClass), (IMP)testMetaClass, \"v@:\"); objc_registerClassPair(newClass); id instance = [[newClass alloc] initWithDomain:@\"some domain\" code:0 userInfo:nil]; [instance performSelector:@selector(testMetaClass)]; 打印输出： 1234567891011121314152016-05-08 16:41:43.414952+0800 TestDemo[1759:642703]This object is 0x60400025f3b02016-05-08 16:41:43.415111+0800 TestDemo[1759:642703]Class is TestClass,super class is NSError2016-05-08 16:41:43.415196+0800 TestDemo[1759:642703]Following the isa pointer 0 times gives 0x60400025f4102016-05-08 16:41:43.415306+0800 TestDemo[1759:642703]Following the isa pointer 1 times gives 0x02016-05-08 16:41:43.415398+0800 TestDemo[1759:642703]Following the isa pointer 2 times gives 0x02016-05-08 16:41:43.415608+0800 TestDemo[1759:642703]Following the isa pointer 3 times gives 0x02016-05-08 16:41:43.415697+0800 TestDemo[1759:642703]NSObject's class is 0x102efeea82016-05-08 16:41:43.415783+0800 TestDemo[1759:642703]NSObject's meta class is 0x0 在for循环中，我们通过objc_getClass来获取对象的isa，并将其打印出来，以此一直回溯到NSObject的meta-class。分析打印结果，可以看到最后指针指向的地址是0x0。","link":"/2016/05/08/Objective-C对象详解/"},{"title":"Grand Central Dispatch","text":"简介 什么是GCD 全程：Grand Central Dispatch（强大的中枢调度器） 纯C语言，提供了非常强大的函数 GCD的优势 GCD会自动利用更多的CPU内核 GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程） 程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码 任务和队列 GCD中有两个核心概念 任务：执行什么操作 队列：用来存放任务 GCD的使用有两个步骤 定制任务 将任务添加到队列中 GCD会自动将队列中的任务取出来，放到对应的线程中执行 任务的取出遵循队列的FIFO（现金先出）原则 执行任务 GCD中有两个用来执行任务的常用函数 12345678/** 用同步的方式执行任务 @param queue#&gt; 队列 description#&gt; @param void block任务 @return */ dispatch_sync(&lt;#dispatch_queue_t _Nonnull queue#&gt;, &lt;#^(void)block#&gt;); 1234/** 用异步的方式执行任务 */ dispatch_async(&lt;#dispatch_queue_t _Nonnull queue#&gt;, &lt;#^(void)block#&gt;); 还有个用来执行任务的函数： 1234567&gt; //第一个参数queue 不能是全局的并发队列&gt; /*&gt; dispatch_barrier_async函数的作用与barrier的意思相同,在进程管理中起到一个栅栏的作用,它等 待所有位于barrier函数之前的操作执行完毕后执行,并且在barrier函数执行之后,barrier函数之后的 操作才会得到执行,该函数需要同dispatch_queue_create函数生成的concurrent Dispatch Queue 队列一起使用&gt; */&gt; dispatch_barrier_async(&lt;#dispatch_queue_t _Nonnull queue#&gt;, &lt;#^(void)block#&gt;);&gt; dispatch_barrier_sync(&lt;#dispatch_queue_t _Nonnull queue#&gt;, &lt;#^(void)block#&gt;);&gt; 同步和异步的区别 同步：只能在当前线程中执行任务，不具备开启新线程的能力 异步：只能在新的线程中执行任务，局别开启新线程的能力 同步、异步、并发、串行 要分清楚 同步和异步主要影响：能不能开启新的线程 同步：只是在当前线程中执行任务，不具备开启新线程的能力 异步：可以在新的线程中执行任务，具备开启新线程的能力 并发和串行主要影响：任务的执行方式 并发：允许多个任务并发（同时）执行 串行：一个任务执行完毕后，再执行下一个任务 dispatch_async 和 dispatch_sync 还要一个很重要的区别 异步执行 会立刻返回 123456789101112//验证异步执行会立刻返回 dispatch_async(dispatch_get_global_queue(0, 0), ^{ //子线程 for (NSInteger i = 0; i &lt; 100; i++) { NSLog(@\"22222\"); } }); NSLog(@\"33333\"); /* 先打印33333 最后才是2222。。。 */ 同步执行会等待执行结束后才返回 123456789101112//验证同步执行会等待执行结束后返回 dispatch_sync(dispatch_get_global_queue(0, 0), ^{ //因为是同步。不会开启线程，所以仍然是main线程 for (NSInteger i = 0; i &lt; 100; i++) { NSLog(@\"22222\"); } }); NSLog(@\"33333\"); /* 先打印完所有22222 最后才会打印33333 */ 正是因为这个特性 在主线程同步调用任务在mainQueue里，就会造成死锁的情况。因为：1）:dispatch_sync在等待block语句执行完成，而block语句需要在主线程里执行，所以dispatch_sync如果在主线程调用就会造成死锁2）:dispatch_sync是同步的，本身就会阻塞当前线程，也即主线程。而又往主线程里塞进去一个block，所以就会发生死锁。 创建队列队列的类型 GCD的队列可以分为2大类型 并发队列 可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务） 并发功能只有在异步（dispatch_async）函数下才有效 串行队列 让任务一个接着一个地执行（一个任务执行完毕之后，再执行下一个任务） 如何创建并发队列第一种方法： 1dispatch_queue_create(\"com.a\", DISPATCH_QUEUE_CONCURRENT); 第二种方法：使用系统提供的 Global Dispatch Queue 1dispatch_get_global_queue(0, 0);//第一个设置优先级，仅仅是大致优先级。第二个暂时没用 如何创建串行队列第一种方法： 1dispatch_queue_create(\"com.b\", NULL); 注意：《iOS与OS X多线程和内存管理》中讲到 使用dispatch_queue_create()创建的DispatchQueue在ARC中也需要手动调用dispatch_release（）方法释放。经过验证，iOS6以后的ARC中就不需要了。 这里需要注意使用Serial Disparch Queue时，其生成个数的问题，Concurrent Dispatch Queue能够并行执行多个追加处理（也就是会开启多条线程去处理追加到队列中的的多个任务），而Serial Dispatch Queue同时只能执行一个追加处理（也就是只能开启一条线程）。 但是当通过dispatch_queue_create()生成多个Serial Dispatch Queue时，各个Serial Dispatch Queue将并行执行（前提是使用异步方式）。虽然在一个Serial Dispatch Queue中同时只能执行一个追加处理，但如果将处理分别追加到4个Serial Dispatch Queue中，各个Serial Dispatch Queue执行一个，即为并行执行4个处理。≈ 如下图： 如果生成2000个Serial Dispatch Queue，那么就生成2000个线程，如果过多使用，就会消耗大量内存，引起大量的上下文切换，大幅度降低系统的性能。 第二种方法：直接使用主队列（主队列是串行队列） GCD的其他函数dispatch_set_target_queue 变更Dispatch Queue的执行优先级。dispatch_queue_create函数生成的Dispatch Queue不管是Serial Dispatch Queue还是Concurrent Dispatch Queue，都使用与默认优先级Global Dispatch Queue相同执行优先级的线程。 12345 dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.oukavip.www&quot;,NULL); dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0); dispatch_set_target_queue(serialQueue, globalQueue); // 第一个参数为要设置优先级的queue,第二个参数是参照物，既将第一个queue的优先级和第二个queue的优先级设置一样。//第一个参数如果指定系统提供的Main/Global Dispatch Queue则不知道会出现什么情况，因此这些均不可以指定。 将Dispatch Queue指定为dispatch_set_target_queue函数的参数还可以作成Dispatch Queue的执行阶层，那么原本应并行执行的多个Serial Dispatch Queue，在目标Serial Dispatch Queue上只能同时执行一个处理。（修改用户队列的目标队列，使多个Queue在目标Queue上一次只有一个执行） 1234567891011121314151617181920212223242526dispatch_queue_t targetQueue = dispatch_queue_create(\"targetQueue\", DISPATCH_QUEUE_SERIAL); dispatch_queue_t queue1 = dispatch_queue_create(\"queue1\", DISPATCH_QUEUE_SERIAL); dispatch_queue_t queue2 = dispatch_queue_create(\"queue1\", DISPATCH_QUEUE_CONCURRENT); //设置参考 dispatch_set_target_queue(queue1, targetQueue); dispatch_set_target_queue(queue2, targetQueue); dispatch_async(queue1, ^{ NSLog(@\"job3 in\"); [NSThread sleepForTimeInterval:2.f]; NSLog(@\"job3 out\"); }); dispatch_async(queue1, ^{ NSLog(@\"job2 in\"); [NSThread sleepForTimeInterval:1.f]; NSLog(@\"job2 out\"); }); dispatch_async(queue1, ^{ NSLog(@\"job1 in\"); [NSThread sleepForTimeInterval:3.f]; NSLog(@\"job1 out\"); }); 打印输出为： 12345615:19:48.144492+0800 GCD[3693:336603] job3 in15:19:50.148901+0800 GCD[3693:336603] job3 out15:19:50.149213+0800 GCD[3693:336603] job2 in15:19:51.153663+0800 GCD[3693:336603] job2 out15:19:51.154019+0800 GCD[3693:336603] job1 in15:19:54.157262+0800 GCD[3693:336603] job1 out 通过打印的结果说明我们设置了queue1和queue2队列以targetQueue队列为参照对象，那么queue1和queue2中的任务将按照targetQueue的队列处理。 在必须将不可并行执行的处理追加到多个Serial Dispatch Queue中时，如果使用dispatch_set_target_queue函数将目标制定为某一个Serial Dispatch Queue，即可防止处理并行执行。 适用场景：一般都是把一个任务放到一个串行的queue中，如果这个任务被拆分了，被放置到多个串行的queue中，但实际还是需要这个任务同步执行，那么就会有问题，因为多个串行queue之间是并行的。这时候dispatch_set_target_queue将起到作用。 dispatch_after想在指定时间后执行处理，可使用dispatch_after函数来实现。 1234//在3秒后将指定的block追加到Main Dispatch Queue中dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@\"waited at last three seconds.\"); }); dispatch_after函数并不是在指定时间后执行处理，而只是在指定时间追加处理到Dispatch Queue。此源代码与在3秒后用dispatch_async函数追加block到Main Dispatch Queue相同。 因为Main Dispatch Queue在主线程的RunLoop中执行，所以在比如每隔1/60秒执行的RunLoop中，block最快在3秒后执行，最慢在3+1/60秒后执行。并且Main Dispatch Queue有大量处理追加或主线程的处理本身有延迟时，这个时间会更长。如果想在大致延迟时间执行处理，该函数是非常有效的。 disparch_group_t无论向什么样的Dispatch Queue中追加处理，使用Dispatch Group都可以监视这些处理执行的结束。一旦检测到所有处理执行结束，就可将结束的处理追加到Dispatch Queue中。这就是使用Dispatch Group的原因。 123456789101112131415161718dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^{ NSLog(@\"blk0\"); }); dispatch_group_async(group, queue, ^{ NSLog(@\"blk1\"); }); dispatch_group_async(group, dispatch_queue_create(\"com.wuqh.queue\", NULL), ^{ NSLog(@\"blk2\"); [NSThread sleepForTimeInterval:5]; NSLog(@\"blk2done\"); }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{ NSLog(@\"done\"); }) 另外，在Dispatch Gourp中也可以使用dispatch_group_wait函数仅等待全部处理执行结束。 12345678910111213141516171819dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^{ NSLog(@\"blk0\"); }); dispatch_group_async(group, queue, ^{ NSLog(@\"blk1\"); }); dispatch_group_async(group, dispatch_queue_create(\"com.wuqh.queue\", NULL), ^{ NSLog(@\"blk2\"); [NSThread sleepForTimeInterval:5]; NSLog(@\"blk2done\"); }); //程序会一直停留在此处等待gourp中的任务，直到全部执行完毕才会继续向下执行。 //也就是说，意味着一旦调用dispatch_group_wait函数，该函数就处于调用的状态而不返回。即执行dispatch //_group_wait函数的线程停止。在经过dispatch_group_wait函数中指定时间或任务全部执行结束之前 //执行该函数的线程停止 dispatch_group_wait(group, DISPATCH_TIME_FOREVER); 也可以指定等待时间。disparch_group_wait，有一个long类型的返回值，返回值为0，表示全部执行结束，返回值不为0，表示虽然经过了指定时间，但还有某些处理没有执行完。 123456long result = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC))); if (result &gt; 0) { NSLog(@\"没有全部执行结束执行结束\"); }else { NSLog(@\"全部执行结束\"); } 指定time为DISPATCH_TIME_NOW，则不用任何等待即可判定属于Dispatch Group的处理是否执行结束。 1long result = dispatch_group_wait(group, DISPATCH_TIME_NOW); dispatch_(a)syncdispatch_async函数的”async“意味着“非同步”，就是将指定的block”非同步”地追加到指定的队列中。dispatch_async函数不作任何等待，如下图： dispatch_sync意味着“同步”。函数会一直等待执行结束，“等待”意味着当前线程停止。如下图： 注意：dispatch_sync函数容易引起问题，即死锁。例如在主线程中执行以下源代码就会死锁： 123dispatch_sync(dispatch_get_main_queue(), ^{ //。。。 }); 使用async，或者Serail Dispatch Queue都会遇到死锁，如下： 12345dispatch_async(dispatch_get_main_queue(), ^{ dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@\"...\"); })}); 123456dispatch_queue_t queue = dispatch_queue_create(\"com.gcd.error\", NULL); dispatch_async(queue, ^{ dispatch_async(queue, ^{ NSLog(@\"...\"); })}); dispatchbarrier(a)sync在进程管理中起到一个栅栏的作用，它等待所有位于barrier函数之前的操作执行完毕后执行，并且在barrier函数执行之后，barrier函数之后的操作才会得到执行，该函数需要同dispatch_queue_create函数生成的Concureent Dispatch Queue队列一起使用。注意：与使用dispatch_get_global_queue()获得的队列一起使用无效。 作用： 实现高效率的数据库访问和文件访问 避免数据竞争 123456789101112131415161718192021222324252627282930dispatch_queue_t queue = dispatch_queue_create(\"com.gcd\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ for (int i = 0; i&lt;20; i++) { NSLog(@\"----1----%@\",[NSThread currentThread]); } }); dispatch_async(queue, ^{ for (int i = 0; i&lt;20; i++) { NSLog(@\"----2----%@\",[NSThread currentThread]); } }); dispatch_barrier_async(queue, ^{ for (int i = 0; i&lt;20; i++) { NSLog(@\"----barrier----%@\",[NSThread currentThread]); } }); dispatch_async(queue, ^{ for (int i = 0; i&lt;20; i++) { NSLog(@\"----3----%@\",[NSThread currentThread]); } }); dispatch_async(queue, ^{ for (int i = 0; i&lt;20; i++) { NSLog(@\"----4----%@\",[NSThread currentThread]); } });//先执行1和2，之后是barrier，最后是3和4 同dispath_async一样，此函数也有一个这样的函数：dispatch_barrier_sync函数，此函数与dispatch_barrier_async的区别和 dispatch_async与dispatch_sync的区别相同：async不阻塞当前线程。 dispatch_apply dispatch_apply函数时dispatch_sync函数和Dispatch Group的关联API。该函数按指定的次数将指定的block追加到指定的Dispatch Queue中，并等待全部处理执行结束。 12345NSArray *array = [NSArray arrayWithObjects:@0,@1,@2,@3,@4,@5,@6,@7,@8,@9, nil];dispatch_apply([array count], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) { NSLog(@\"async:%@-%@\",array[index],[NSThread currentThread]);});NSLog(@\"done\");//同sync一样。最后才会打印done。 由于dispatch_apply函数会等待执行结束，因此有时候也可以在dispatch_async函数中非同步地执行dispatch_apply函数。 123456789dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ dispatch_apply([array count], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) { NSLog(@\"async:%@-%@\",array[index],[NSThread currentThread]); }); dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@\"success\"); }); });NSLog(@\"done\");//因为async不需要等待，所以会立马执行，不会最后才打印。 dispatch_suspend/dispatch_resume当追加大量处理到Dispatch Queue时，在追加处理的过程中，有时希望不执行已追加的处理。在这种情况下，只要挂起Dispatch Queue即可，当可以执行时再恢复。 注意：dispatch_suspend/dispatch_resume对全局队列不起作用。 必须确保dispatch_suspend/dispatch_resume成对调用。那么这里有个问题？gcd中如何中途结束线程？ 1234567891011121314151617181920212223dispatch_queue_t queue = dispatch_queue_create(\"com.test.gcd\", DISPATCH_QUEUE_SERIAL);//提交第一个block，延时5秒打印。dispatch_async(queue, ^{ sleep(5); NSLog(@\"After 5 seconds...\");});//提交第二个block，也是延时5秒打印dispatch_async(queue, ^{ sleep(5); NSLog(@\"After 5 seconds again...\");});//延时一秒NSLog(@\"sleep 1 second...\");sleep(1);//挂起队列NSLog(@\"suspend...\");dispatch_suspend(queue);//延时10秒NSLog(@\"sleep 10 second...\");sleep(10);//恢复队列NSLog(@\"resume...\");dispatch_resume(queue); 1234562017-08-18 17:52:41.261398+0800 GCD[5222:795121] sleep 1 second...2017-08-18 17:52:42.262096+0800 GCD[5222:795121] suspend...2017-08-18 17:52:42.262496+0800 GCD[5222:795121] sleep 10 second...2017-08-18 17:52:46.263456+0800 GCD[5222:795188] After 5 seconds...2017-08-18 17:52:52.263457+0800 GCD[5222:795121] resume...2017-08-18 17:52:57.264210+0800 GCD[5222:795191] After 5 seconds again... 在dispatch_suspend挂起队列后，第一个block还是在运行，并且正常输出。 dispatch_suspend并不会立即暂停正在运行的block，而是在当前block执行完成后，暂停后续的block执行。 Dispatch Semaphoredispatch_semaphore只有3个方法： dispatch_semaphore_create 执行dispatch_semaphore_create会根据传入的long类型参数创建对应数目的信号量 dispatch_semaphore_signal 执行dispatch_semaphore_singal会增加一个信号量 dispatch_semaphore_wait //等待信号量 执行dispatch_semaphore_wait如果信号量是0，就会根据传入的等待时间来等待，如果大于0则不会等待，并且会减去一个信号量 作用： 可以控制一个资源最多由多少个线程来访问。 如下代码所示，由于设定的信号值为2，先执行两个线程，等执行完其中一个，第三个才会继续执行。保证同一时间执行的线程数不超过2。 12345678910111213141516171819202122232425262728//crate的value表示，最多几个资源可访问 dispatch_semaphore_t semaphore = dispatch_semaphore_create(2); dispatch_queue_t quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //任务1 dispatch_async(quene, ^{ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@\"run task 1\"); sleep(1); NSLog(@\"complete task 1\"); dispatch_semaphore_signal(semaphore); }); //任务2 dispatch_async(quene, ^{ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@\"run task 2\"); sleep(1); NSLog(@\"complete task 2\"); dispatch_semaphore_signal(semaphore); }); //任务3 dispatch_async(quene, ^{ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@\"run task 3\"); sleep(1); NSLog(@\"complete task 3\"); dispatch_semaphore_signal(semaphore); }); 也可以起到类似栅栏函数的作用。线程A和线程B：线程A执行完之后线程B再继续执行。 如下代码所示：先执行获取token方法，在执行request 1234567891011121314151617181920212223242526{ //这里使用dispatch_async，是为了不阻塞当前线程。 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); [self getToken:semaphore]; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [self request]; }); NSLog(@\"继续执行啊\");}//异步请求，获取token- (void)getToken:(dispatch_semaphore_t)semaphore { dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ for (int i = 0; i &lt; 10000; i++) { NSLog(@\"getToken:%d\",i); } NSLog(@\"getToken:Success\"); dispatch_semaphore_signal(semaphore); });}//执行网络请求- (void)request { NSLog(@\"request\");} 题外话： 123456789&gt; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&gt; &gt; NSMutableArray *array = [[NSMutableArray alloc] init];&gt; for (int i = 0; i &lt; 100000; ++i) {&gt; dispatch_async(queue, ^{&gt; [array addObject:[NSNumber numberWithInt:i]];&gt; });&gt; }&gt; &gt; 上面这段代码会执行错误。报错如下： 123&gt; malloc: *** error for object 0x6040003805b0: pointer being freed was not allocated&gt; *** set a breakpoint in malloc_error_break to debug&gt; &gt; 为什么、？ dispatch_oncedispatch_once函数是保证在应用程序中只执行一次指定处理的API。单例模式经常用到此函数。 1234static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ //code to be executed once }); Dispatch I/O","link":"/2016/07/18/Grand-Central-Dispatch/"},{"title":"RAC(三)RACSignal各类操作","text":"获得一个信号的方式单元信号1234RACSignal *signal1 = [RACSignal return:@\"Some value\"];RACSignal *signal2 = [RACSignal error:errorObject];RACSignal *signal3 = [RACSignal empty];RACSignal *signal4 = [RACSignal never]; 动态信号123456789RACSignal *signal5 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) { [subscriber sendNext:@1]; [subscriber sendNext:@2]; [subscriber sendError:errorObject]; [subscriber sendCompleted]; return [RACDisposable disposableWithBlock:^{ }];}]; Cocoa桥接1234RACSignal *signal6 = [button rac_signalForSelector:@selector(setFrame:)];RACSignal *signal7 = [button rac_signalForControlEvents:UIControlEventTouchUpInside];RACSignal *signal8 = [button rac_willDeallocSignal];RACSignal *signal9 = RACObserve(button, backgroundColor); 信号变换123RACSignal *signal10 = [signal1 map:^id _Nullable(NSString* _Nullable value) { return [value substringFromIndex:1]; }] 序列转换1RACSignal *signal11 = [RACSequence return:@1].signal; 订阅一个信号的方式注意Signal是push-driven(推驱动) 基本订阅方法 subscribe1234567[signal1 subscribeNext:^(id _Nullable x) { NSLog(@\"%@\",x);} error:^(NSError * _Nullable error) { NSLog(@\"%@\",error);} completed:^{ NSLog(@\"complete\");}]; 绑定1RAC(view,backgroundColor) = signal10; Cocoa桥接123[view rac_liftSelector:@selector(convertPoint:toView:) withSignals:signal1,signal2, nil];[view rac_liftSelector:@selector(convertPoint:toView:) withSignalsFromArray:@[signal1,signal2]];[view rac_liftSelector:@selector(convertPoint:toView:) withSignalOfArguments:signal5]; 分析订阅过程RACSignal的常见用法： 123456789101112131415 // part 1:[RACSignal createSignal]来获得signal RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) { // part 3: 进入didSubscribe，通过[subscriber sendNext:]来执行next block [subscriber sendNext:@1]; [subscriber sendNext:@2]; [subscriber sendCompleted]; return nil;//这里忽略RACDisposable，暂时不讲 }]; // part 2 : [signal subscribeNext:]来获得subscriber，然后进行subscription，error和complete不讨论与next一样。（RACSignal里面保存的事件分为3中。一种是值value，一种是error，一种是complete。） [signal subscribeNext:^(id _Nullable x) { //... }];} RACSignal的Subscription过程概括起来可以分为三个步骤： 步骤一：[RACSignal createSignal]来获得signal12345678910//RACSignal.m中：+ ( RACSignal *)createSignal:( RACDisposable * (^)( id &lt; RACSubscriber &gt; subscriber))didSubscribe { return [ RACDynamicSignal createSignal :didSubscribe];}//RACDynamicSignal.m中+ ( RACSignal *)createSignal:( RACDisposable * (^)( id &lt; RACSubscriber &gt; subscriber))didSubscribe { RACDynamicSignal *signal = [[ self alloc ] init ]; signal-&gt; _didSubscribe = [didSubscribe copy ]; return [signal setNameWithFormat : @\"+createSignal:\" ];} [RACSignal createSignal]会调用子类RACDynamicSignal的createSignal来返回一个signal，并在signal中保存后面的 didSubscribe这个block 步骤二：[signal subscribeNext:]来获得subscriber，然后进行subscription12345678910111213141516171819202122232425262728//RACSignal.m中：- ( RACDisposable *)subscribeNext:( void (^)( id x))nextBlock { RACSubscriber *o = [ RACSubscriber subscriberWithNext :nextBlock error : NULL completed : NULL ]; return [ self subscribe :o];}//RACSubscriber.m中：+ ( instancetype )subscriberWithNext:( void (^)( id x))next error:( void (^)( NSError *error))error completed:( void (^)( void ))completed { RACSubscriber *subscriber = [[ self alloc ] init ]; subscriber-&gt; _next = [next copy ]; subscriber-&gt; _error = [error copy ]; subscriber-&gt; _completed = [completed copy ]; return subscriber;}//RACDynamicSignal.m中：- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber { RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable]; subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable]; if (self.didSubscribe != NULL) { RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^{ RACDisposable *innerDisposable = self.didSubscribe(subscriber); [disposable addDisposable:innerDisposable]; }]; [disposable addDisposable:schedulingDisposable]; } return disposable;} [signal subscribeNext]先会获得一个subscriber，这个subscriber中保存了nextBlock、errorBlock、completedBlock 由于这个signal其实是RACDynamicSignal类型的，这个[self subscribe]方法会调用步骤一中保存的didSubscribe，参数就是1中的subscriber 步骤三：进入didSubscribe，通过[subscriber sendNext:]来执行next block12345678//RACSubscriber.m中：- (void)sendNext:(id)value { @synchronized (self) { void (^nextBlock)(id) = [self.next copy]; if (nextBlock == nil) return; nextBlock(value); }} signal的subscription过程回顾从上面的三个步骤，我们看出： 先通过createSignal和subscribeNext这两个调用，声明了流中value到来时的处理方式 didSubscribe block块中异步处理完毕之后，subscriber进行sendNext，自动处理 RACTupleRAC定义的一种数据类型。类似Swift中的tuple。这里不多介绍。 12345RACTuple *tuple = RACTuplePack(@1,@\"haha\");id first = tuple.first;id last = tuple.last;id idnex1 = tuple[1];RACTupleUnpack(NSNumber *num,NSString *str) = tuple; RACSignal各类操作 对值操作map/mapReplace reduceEach只能用在tuple上。tuple个数少了会挂，多了只去和参数相同的个数。 Scan 其他not/and/or/reduceApply/materialize/dematerialize; 对数量操作filter ignore/ignoreValues/distinctUntilChanged这几个根据英文很容易理解 take skip 其他 startWith Repeat retry collect Aggregate 副作用操作doNext 时间操作Delay Throttle 组合操作Concat Merge merge用处很多，如下： 123RACSignal *appearSignal = [[self rac_signalForSelector:@selector(viewDidAppear:)]] mapReplace:@YES];RACSignal *disappearSignal = [[self rac_signalForSelector:@selector(viewWillDisAppear:)]] mapReplace:@NO];RACSignal *activeSignal = [RACSignal merge:@[appearSignal,disappearSignal]]; Zip CombineLatest Sample TakeUntil TakeUntilReplacement","link":"/2017/01/08/RAC-三-RACSignal基本使用/"},{"title":"RAC(一)函数响应式编程概述","text":"ReactiveCocoa是一种新的编程范式(即函数响应式编程)，而不是一个基础库。是在面向对象语言的基础上，对函数响应式编程的实现。本文主要讲解函数式编程和响应式编程。 编程是什么？根据冯诺依曼体系结构。编程就是：对输入设备进行采样，最终通过计算设备进行计算，得到的结果通过输出设备输出，这就是编程。 编程也可以是：根据业务需求，形成一种业务模式，最后通过把这个模式转换为代码实现的一个过程。 面向过程 vs 面向对象“面向过程”和“面向对象”指的是编程思想，它们属于同一种编程范式，都是命令式编程。 命令式编程 vs 函数式编程所有的命令式编程都被设计来高效地使用冯诺依曼体系结构的计算机。实际上，最初的命令式语言的目的就是取代汇编语言，对机器指令进行进一步抽象。因此，命令式语言带有强烈的硬件结构特征。命令式语言的核心特性有：模拟存储单元的变量、基于传输操作的赋值语句，以及迭代形式的循环运算。命令式语言的基础是语句（特别是赋值），它们通过修改存储器的值而产生副作用的方式去影响后续的计算。 函数式语言设计的基础是数学函数，函数式程序设计把程序的输出定义为其输入的一个数学函数，在这里没有内部状态，也没有副作用。函数式语言进行计算的主要是将函数作用与给定参数之上。函数式语言没有命令式语言所必需的那种变量，可以没有赋值语句，也可以没有循环。一个程序就是函数定义和函数应用的说明；一个程序的执行就是对函数应用的求值。 看下面两段代码，功能都为求一个数的阶乘（n!），下面两段代码分别代表了命令式编程 和 函数式编程。 12345678//命令式编程int factorial1(int x) { int result = 1; for (int i = 0; i &lt;= x; ++i) { result *= i } return result;} 12345//函数式编程int factorial2(int x) { if (x == 1) return; return x * factorial2(x-1);} 不难理解，两个方法的作用相同。都为求一个数的阶乘（n!）。那么两段代码有什么区别呢？ 看待运算不懂 factorial1把运算看做是cpu的运算，有存储，创建、计算，返回值（基于冯诺依曼体系结构）。 factorial2更接近数学计算，更多的是描述一种运算。n的阶乘是什么呢？那就是n! = n * (n-1)!。所以factorial2就是在表述这种运算。 factorial1是基于语句的(赋值语句、for循环语句)，factorial2是基于表达式的（表达式是指有值返回的就叫做表达式）。 factorial1是基于状态量的，就是代码中的result，要赋值，比较。factorial2是基于不变量的，代码中没有任何修改值的操作。 factorial1 与 factorial2的对比，也就是命令式编程与函数式编程的对比。像我们平时接触的c、oc、java都是命令式编程很少会接触到纯函数式编程的编程语言,比如Erlang、clojure、Scala。 总结函数式编程的特点 函数是“第一等公民” 所谓“第一等公民”，指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。 只用表达式，不用语句 “表达式”是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。 原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。”语句”属于对系统的读写操作，所以就被排斥在外。 当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。 没有“副作用” 所谓“副作用”，指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。 函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。 这个不太容易理解，通俗一点的说，我们平时使用命令式编程开发工程中有经常会有如下场景：fun1()调用完之后才能调用fun2()。那这种情况在函数式编程中就不会出现。因为每个函数都是没有副作用的，不影响外部变量，所以func1()还是func2谁先调用，都无所谓。 不修改状态 上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。在其他类型的语言中，变量往往用来保存”状态”。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。 引用透明 引用透明，指的是函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。 有了前面的第三点和第四点，这点是很显然的。其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫”引用不透明”，很不利于观察和理解程序的行为。 惰性计算（？？有点疑问函数式编程的惰性求值） 响应式编程在计算机中，响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。 例如，在命令式编程环境中，a=b+c表示将表达式的结果赋给a，而之后改变b或c的值不会影响a。但在响应式编程中，a的值会随着b或c的更新而更新。 电子表格程序就是响应式编程的一个例子。单元格可以包含字面值或类似”=B1+C1”的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化 。 在ios开发中，autolayout就是使用了响应式编程。响应式编程理解起来应该会简单一点，这里就不多解释。 ReactiveCocoa是什么？上面讲了函数式编程 和 响应式编程。那么ReactiveCocoa 就是结合了函数式编程和响应式编程的特点： 函数式编程：将运算过程尽量写成一些列的函数调用。 响应式编程：面对离散数据流以及对离散数据流进行操作。 ，提供基于时间变化的数据流的组合和变换，将输入转化为输出在时间上的持续过程的一种方式。","link":"/2016/12/14/RAC-一-函数式编程概述/"},{"title":"RAC(二)基础知识","text":"核心组件 RACStream RACSequence RACSignal RACSubscriber RACDisposable RACScheduler Cocoa框架适配工具 RACStream的两个子类：Sequence &amp; Signal RACStream表示一个数据流的类。这个流不一定是基于时间的，所以它有两个子类RACSequence和RACSignal。 RACSequence是基于空间的数据流 RACSignal是基于时间的数据流 对比RACSequence和RACSignal，基于空间的数据流和基于时间的数据流到底有什么区别？ Sequence是Pull-Driven(拉驱动)，Signal是Push-driven(推驱动) pull-driver表示数据的变化是由拉取者决定的。举个简单的例子，sequence就好比一本书，我们看书，想看到哪页就可以翻到哪页去看，看什么内容读取什么数据，是由我们决定，而不是由书（sequence）决定。 push-driver表示数据的变化是由推送者决定的，与pull-driver刚好相反。可以把Signal比作电视体育直播。看什么内容读取什么数据，是由电视(Signal)决定的，如果我们去上个卫生间也无法暂停体育直播，中间的数据就会错过。 Sequence里面可以仅仅存放任何类型的数据。RACSignal里面不仅包含数据，也包含信号的状态（后面会了解到信号状态）。 RACSequence的简单使用RACSequence使用的情况很少。这里就简单介绍一下常用方法 123456789101112131415161718192021//创建 RACSequence *sequence1 = [RACSequence return:@1]; RACSequence *sequence2 = [RACSequence sequenceWithHeadBlock:^id _Nullable{ return @2; } tailBlock:^RACSequence * _Nonnull{ return sequence1; }]; RACSequence *sequence3 = @[@1,@2,@3].rac_sequence; //变换 RACSequence *mappedSequence = [sequence1 map:^id _Nullable(NSNumber* value) { return @(value.integerValue*3); }]; RACSequence *concatedSequence = [sequence2 concat:mappedSequence]; RACSequence *mergerdSequence = [RACSequence zip:@[concatedSequence,sequence3]]; //遍历 NSLog(@\"%@\",mergerdSequence.head); for (id value in mergerdSequence) { NSLog(@\"%@\",value); } RACSignal的简单使用1234567891011121314151617181920212223//创建 RACSignal *signal1 = [RACSignal return:@\"hello\"]; RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) { [subscriber sendNext:@1]; [subscriber sendNext:@2]; [subscriber sendCompleted]; return nil; }]; RACSignal *signal3 = RACObserve(self.view, backgroundColor); //变换 RACSignal *mappedSignal = [signal1 map:^id _Nullable(NSString* value) { return [value stringByAppendingString:@\" word\"]; }]; RACSignal *concatedSignal = [mappedSignal concat:signal2]; RACSignal *mergeSignal = [mappedSignal merge:@[concatedSignal,signal3]]; //遍历 [mergeSignal subscribeNext:^(id _Nullable x) { NSLog(@\"%@\",x); } completed:^{ NSLog(@\"completed\"); }]; 这里仅仅是对RACSignal做初步了解。具体方法到底怎么用。后面的文章会讲到。 RACSubscriber &amp; RACDisposableSubscription(订阅者)表⽰等待或者能够等待信号发送事件的任意对象。在框架中使用RACSubscriber协议表示,也即任意实现了RACSubscriber协议的对象都可以是订阅者。可以通过调⽤ -subscribeNext:error:completed:⽅法来创建订阅。RACStream和RACSignal类的大多操作也会⾃己创建订阅。订阅会对Signals对象引⽤计数加1,当信号发送错误或者完成事件后,会⾃动被处理,不需要⽤户关⼼内存管理。当然,⽤户也可以⼿动处理。 RACDisposable类⽤于取消订阅或者清理资源。 下图展示了Subscriber、Disposable、Signal三者的关系 Scheduler 用来做调度 代替GCD 异步与并发 scheduler由RACScheduler类表示,它是信号执行任务时所在的队列(queue)或者信号执⾏完后将结果放到队列⾥执行,可以认为就是gcd⾥的queues。scheduler⽀持取消操作,⽽且它总是串行地执⾏任务。这有利于避免死锁。RACScheduler有时候也类似NSOperationQueue,但它不允许任务间相互依赖。","link":"/2017/01/01/RAC-二-基础知识/"},{"title":"CPU寻址能力到底怎么理解？","text":"内存首先讲解一下存储器 存储器是计算机重要组成部分，他是用来存储数据和部件。存储器的种类很多，按各种说法分类也有很多。下面主要讲解一种通常普遍的说法 现代计算机存储器按用途分类，可以分为： 主存储器，简称主存 RAM ROM 辅助存储器 Cache(高级缓冲存储器) (它位于CPU与主存之间，是读写速度比内存还快的存储器，从名字应该就知道它的作用，主要是为了解决CPU和主存速度不匹配而设计的，因为CPU中寄存器的速度更更快，所以出现了速度能接近于CPU的Cache) 通常我们会把主存储器叫做内存。但是严格意义上说，内存是由主存（比如内存条）、Cache两部分组成。但是可能由于Cache相对于内存条容量特别小，以及很久之前的计算机没有Cache，所以很多情况，大家就默认内存就是主存的说法了。 通过上面介绍存储器，我们可以知道 内存 是存储器的一部分，也叫主存。 内存是CPU能直接寻址的存储空间。计算机中所有的程序的运行都是在内存中进行的。 内存的特点是速率很快。（这点大家都应该知道。） 我们平时会说 “我的电脑内存太小，只有4G，需要加内存条”，这里所说的 4G是什么意思呢？ 内存中含有大量的存储单元，每个存储单元的大小都是1B，所以上面所说的4G内存，意思就是它是有22*230个存储单元。 这些个存储单元组成在一起，就叫做 内存空间,那何为内存地址呢？在内存中，每个存储单元都有一个编号，这个编号通常用16进制表示，从0开始编号。这个编号就叫做内存地址。 理解了 内存地址和 内存空间 才能共清楚的明白CPU寻址。 寻址空间CPU寻址，也就是通过内存地址，找到对应的存储单元。上面已经提到过，一个存储单元是1B。 解释寻址能力之前，先来看下 寻址空间 （Addressing space）的概念。 寻址空间一般指的是CPU对于内存寻址的能力。通俗地说，就是能最多用到多少内存空间的一个问题。数据在存储器(RAM)中存放是有规律的 ，CPU在运算的时候需要把数据提取出来就需要知道数据存放在哪里 ，这时候就需要挨家挨户的找，这就叫做寻址，但如果地址太多超出了CPU的能力范围，CPU就无法找到数据了。 CPU最大能查找多大范围的地址叫做寻址能力 ，CPU的寻址能力以字节为单位 ，如32位寻址的CPU可以寻址2的32次方大小的地址也就是4G，这也是为什么32位的CPU最大能搭配4G内存的原因 ，再多的话CPU就找不到了。 上面提到了何为寻址能力？就是CPU最大能查找多大范围的地址。千万不要理解为CPU最大能查找多大的地址 虽然跟上一句比仅仅少了一个’范围’，但是完全是两个意思。 我最开始就理解成了 最大能查找到多大的地址。。。 或者也可以理解为：CPU最多能查找多少个地址 （这里多少个地址，指得是多少个存储单元，存储单位最小单位是Byte，不是b） 。或者可以理解为 CPU可以对多少个存储单元进行寻址 到了这里 应该就明白了寻址能力的概念，但是还不够。。 注意：文中的“存储单元”或者“内存单元”意思是一样的。”内存空间”和”存储空间” 意思也是一样的。 寻址能力 Byte or Bite?思考一个问题： 8086CPU的地址总线宽度是20，那么他的寻址能力是大呢 看到这里如果不明白什么是地址总线，请看我的这篇文章 : 入门汇编语言 地址总线的宽度决定了CPU的寻址能力，宽度是20，也就代表有20根导线， 每根导线发射的是高、低电信号两种情况，所以寻址能力为 220B = 1M 但是这里可能会出现很多人都纳闷的问题，20根导线，不就是20位吗，所以应该是220b。那为什么是 220B ，而不是220b 呢？ （B为Byte/字节，b为bite/位） 位 ，表示的是二进制位，一般称为比特，即0或1，是计算机存储的最小单位 字节是计算机中数据处理的基本单位；计算机以字节为单位存储和解释信息，规定一个字节由8个二进制位构成，即1B = 8b 因为地址总线的宽度决定了CPU的 寻址能力，那何为寻址能力呢，说面提到了，寻址能力可以理解为CPU可以对多少个存储单元进行寻址，地址总线是20，那么就代表最多能找到220个存储单元，又因为8086中一个存储单元是1B所以，这里是220B 看到这里可能又会继续糊涂，因为你可能不明白存储单元、内存地址、内存空间到底是什么，他们之间有什么的联系，所以往下看…… 内存地址、内存单元和内存空间首先。在平时开发中，可能有时候你看到的内存地址是4位16进制（0x0001），有时候你看到的内存地址是8位16进制(0x00000001)。这两个内存地址都是表示编号大小为十进制1的内存地址，为什么一个用4位16进制？另外一个又用8位16进制？(注意，0x0001 和 0x00000001 仅仅是表示方式不一样，数值大小可是相等的，可别搞迷糊了！） 这就是因为寻址能力的问题。CPU寻址能力达不到8位16进制，所以用4位16进制表示就可以，理论上你硬要用8位16进制表示也可以。只不过你寻址能力低，不可能超过4位。所以 寻址能力低，不会超过4位的就用4位16进制，能够超过4的cpu就用8位16进制。 接下来就解释一下内存地址和 内存单元 内存地址 仅仅是一个标号，代表一个内存单元。在计算机中存储器的容量是以字节B为基本单位的，所以一个内存地址代表一个字节 1B = 8b 的内存单元，也可以说一个内存单元占8b或1B的存储空间。 我们平时经常说32位操作 系统，最多支持4G内存空间。就是因为232B = 4G 所以这里的结论就是：用4位16进制表示的内存地址和用8位16进制表示的内存地址，其实都是代表一个8位/1字节的存储空间，把这8位/1字节的存储空间叫做一个内存单元 比如一个汉字“中”在计算机中是如何存储呢，一个汉字，需要两个存储单元，也就是2B大小，这2B存储空间是连续的，所以不需要全部找到，只需要找到最开始的一部分，就能找到这个“中” 所以，内存地址是内寸中存储数据的一个标识，并不是数据本身，通过内存地址可以知道内存当中存储的数据，这个数据可能占1个内存单元，也可能占多个内存单元。 可以抽象的把内存空间比作房子🏡，如果想要找到房子，就需要通过🚪门牌号来找，所以内存地址就可以比作门牌号，那这个房子多大呢，就可以称为占了多少的内存空间。那这个房子里可能还包括有厨房、卧室、卫生间，这些统统不用继续找了，因为有了门牌号（内存地址），就能找到房子（数据，整个内存空间），找到房子自然就能找打屋里的厨房、卧室……(一个个内存单元)。另外，门牌号是贴在房子上的，所以内存地址不占用内存空间，不要和平时开发中的指针这一概念搞混淆。 参考： 《百度百科-寻址空间》) 《汇编语言论坛》 《内存概念》 《关于内存地址和内存空间的概念》 《内存地址与内存空间》","link":"/2018/05/19/CPU寻址能力到底怎么理解？/"},{"title":"RAC(四)信号高阶操作","text":"高阶信号对数组的操作可以有二维数组，多维数组。同样，信号也是可以嵌套的，经常会遇到二维信号，也就是信号中发送的值也为信号。 升阶和降阶(下图菱形图例代表信号，圆圈代表值) 创建高阶信号123456RACSiganl *siganl = [RACSignal return:@1];RACSiganl *signalHighOrder = [RACSiganl return:signal];RACSiganl *anotherSignal = [signal map:^id(id value) { return [RACSignal return:value];}]; 订阅高级信号123456RACSiganl *siganl = @[@1,@2,@3].rac_sequence.signal;RACSignal *highOrderSignal = [signal map:^id(RACSiganl *aSiganl) { [aSignal subscribeNext:^(id x) { //... }];}]; 降阶操作SwitchToLatests 使用switchToLatests方法降阶时，需要注意的是新的信号会把旧的信号截断 if/then/else 看一下ifThenElse方法的实现代码，可以很容易理解。它的本质还是使用了SwitchToLatests。 1234567891011121314+ (RACSignal *)if:(RACSignal *)boolSignal then:(RACSignal *)trueSignal else:(RACSignal *)falseSignal { NSCParameterAssert(boolSignal != nil); NSCParameterAssert(trueSignal != nil); NSCParameterAssert(falseSignal != nil); return [[[boolSignal map:^(NSNumber *value) { NSCAssert([value isKindOfClass:NSNumber.class], @&quot;Expected %@ to send BOOLs, not %@&quot;, boolSignal, value); return (value.boolValue ? trueSignal : falseSignal); }] switchToLatest] setNameWithFormat:@&quot;+if: %@ then: %@ else: %@&quot;, boolSignal, trueSignal, falseSignal];} 类似的方法还有SwitchCasesDefaultSignal: 1234567891011121314151617181920212223242526+ (RACSignal *)switch:(RACSignal *)signal cases:(NSDictionary *)cases default:(RACSignal *)defaultSignal { NSCParameterAssert(signal != nil); NSCParameterAssert(cases != nil); for (id key in cases) { id value __attribute__((unused)) = cases[key]; NSCAssert([value isKindOfClass:RACSignal.class], @\"Expected all cases to be RACSignals, %@ isn't\", value); } NSDictionary *copy = [cases copy]; return [[[signal map:^(id key) { if (key == nil) key = RACTupleNil.tupleNil; RACSignal *signal = copy[key] ?: defaultSignal; if (signal == nil) { NSString *description = [NSString stringWithFormat:NSLocalizedString(@\"No matching signal found for value %@\", @\"\"), key]; return [RACSignal error:[NSError errorWithDomain:RACSignalErrorDomain code:RACSignalErrorNoMatchingCase userInfo:@{ NSLocalizedDescriptionKey: description }]]; } return signal; }] switchToLatest] setNameWithFormat:@\"+switch: %@ cases: %@ default: %@\", signal, cases, defaultSignal];} Flatten flatten与SwitchToLatests不同的是，新的信号不会截断旧的信号。它相当于是使用**merge:方法把信号中的所有信号都合并在了一起。 flatten：这个带参数的方法 的参数类型是NSUInteger。拿上图举例子就是说，当前这个参数为2，那这个值就代表的是当前最多展开的信号，signalA中有4个信号，最多同时展开两个信号。也就是说，首先能够一次订阅前两个信号，如果这里两个信号都没执行完， 就不能订阅第三个，当 前两个信号其中有一个信号结束之后，才会去订阅第三个信号，这样依次类推。 Concat 对于一个返回a信号、b信号的高阶信号调用flatten:1，等价于[a信号 concat:b信号]。 对于高级信号，也有一个- (RACSIgnal *)concat;方法，就是相当于调用flatten:1 FlattenMapflattenMap就是 先map为高阶信号在调用flatten降阶 看一下 RACStream.m文件中 flattenMap: 、flatten、map：的实现 123456789101112131415161718192021222324252627- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(id value))block { Class class = self.class; return [[self bind:^{ return ^(id value, BOOL *stop) { id stream = block(value) ?: [class empty]; NSCAssert([stream isKindOfClass:RACStream.class], @\"Value returned from -flattenMap: is not a stream: %@\", stream); return stream; }; }] setNameWithFormat:@\"[%@] -flattenMap:\", self.name];}- (__kindof RACStream *)flatten { return [[self flattenMap:^(id value) { return value; }] setNameWithFormat:@\"[%@] -flatten\", self.name];}- (__kindof RACStream *)map:(id (^)(id value))block { NSCParameterAssert(block != nil); Class class = self.class; return [[self flattenMap:^(id value) { return [class return:block(value)]; }] setNameWithFormat:@\"[%@] -map:\", self.name];} 通过看方法的实现，可以看出，flatten和map方法都是基于flattenMap:的，还有filter： 12345678910111213- (__kindof RACStream *)filter:(BOOL (^)(id value))block { NSCParameterAssert(block != nil); Class class = self.class; return [[self flattenMap:^ id (id value) { if (block(value)) { return [class return:value]; } else { return class.empty; } }] setNameWithFormat:@\"[%@] -filter:\", self.name];} 查看flattenMap方法实现。发现它是基于bind:方法的。RAC中的方法几乎所有都是基于bind方法实现的，它是RAC的核心方法。这个bind方法感觉比较复杂，我暂时也不太理解，以后再研究。","link":"/2017/03/10/RAC-四-信号高阶操作/"},{"title":"Tagged Pointer","text":"一道面试题12345678@property (nonatomic, strong) NSString *target;//.... dispatch_queue_t queue = dispatch_queue_create(\"parallel\", DISPATCH_QUEUE_CONCURRENT);for (int i = 0; i &lt; 1000000 ; i++) { dispatch_async(queue, ^{ self.target = [NSString stringWithFormat:@\"ksddkjalkjd%d\",i]; });} 结果会崩溃。原因setTarget是线程不安全的，可能会出现已经释放的内存再次释放，造成崩溃。解决办法很多，在这里不过多讨论。 如果把代码改成下面这样就不会发生崩溃了： 12345678@property (nonatomic, strong) NSString *target;//.... dispatch_queue_t queue = dispatch_queue_create(\"parallel\", DISPATCH_QUEUE_CONCURRENT);for (int i = 0; i &lt; 1000000 ; i++) { dispatch_async(queue, ^{ self.target = [NSString stringWithFormat:@\"%d\",i]; });} 因为苹果从64位程序开始，引入了Tagged Pointer概念，导致self.taget的值直接保存在了指针值中。 内存对齐在苹果64位处理器上，堆内存对齐采用的是16字节对齐。所以任何指向堆内存的指针都是如下形式： 10x---------------0/8 最后一个十六进制数字始终是 0或者8。 我用真机测试最低位都是8 用模拟器测试最低位都是0 （具体原因不清楚。总之指向堆内存的指针最低位都是一样的，要么全是8要么全是0） 使用16字节内存对齐，也就意味着，如果堆上需要存储的数据实际大小只有1字节，可它还是会多占用15个字节来达到内存对齐，这是不是很浪费？ 那么比如NSNumber，如果数值仅仅为1，NSNumber num = @1。那如果不使用Tagged Pointer还是需要占用16个字节来保存1，以及一个8字节的指针指向16字节的堆内存。 Tagged Pointer从64位程序开始（iPhone5s是配备了首个采用 64 位架构的 A7 双核处理器），苹果引入了Tagged Pointer的概念，为了节省内存和提升效率。 主要用于NSString、NSNumber、NSDate、NSIndexPath等存储小规模数据的对象。这些使用了Tagged Pointer优化的对象，他们的指针不再是指向堆内存的地址，而是直接将值保存在了指针中（苹果为了数据安全，对Tagged Pointer指针的值做了数据混淆）。 使用Tagged Pointer仅仅是针对存储的值比较小的时候，如果存储的值过大，8个字节的指针无法保存，还是会在堆中分配内存。 在objc源码中，用_objc_isTaggedPointer函数来判断是否为Tagged Pointer，源码如下： 12345static bool _objc_isTaggedPointer(const void * _Nullable ptr){ return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;} 注意看 _OBJC_TAG_MASK的值 1234567891011121314#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__ // 64-bit Mac - tag bit is LSB# define OBJC_MSB_TAGGED_POINTERS 0#else // Everything else - tag bit is MSB# define OBJC_MSB_TAGGED_POINTERS 1#endif#if OBJC_MSB_TAGGED_POINTERS# define _OBJC_TAG_MASK (1UL&lt;&lt;63)#else# define _OBJC_TAG_MASK 1UL//在mac平台 _OBJC_TAG_MASK = 1UL//其他平台 _OBJC_TAG_MASK = 1UL&lt;&lt;63 (1左移63位) 在iOS平台上，系统通过指针的最高有效位是否为1(也就是第64位)，来判断是否为Tagged Pointer，在macOS平台上则是根据最低有效位。 这里我们来验证一下： 123NSString *a = @&quot;a&quot;;NSObject *object = [[NSObject alloc] init];NSLog(@&quot;%@ %p\\n%p&quot;,[a class],a,object); console输出为： 12__NSCFConstantString 0x10dc680200x600002c38940 通过上面的代码，发现这里的a不是TaggedPointer，a实际是指向了常量区。为什么这样说呢？因为我这里多添加了一个object变量，object指针肯定是指向堆中，但是a指针的值却比object指针值小了很多很多。所以，a不是在堆中，且栈的地址又是大于堆地址，所以排除堆和栈，那就是说这里的字符串”a”是保存在数据段常量区的。因为iOS内存分布结构，地址从小到大依次是：代码段、数据段、堆、栈。 那为什么这里的a不是Tagged Pointer呢。因为常量字符串本来就是在常量区啊。。。Tagged Pointer优化的是指向堆内存的指针。所以修改下代码： 123NSString *a = [[@\"a\" mutableCopy] copy];NSObject *object = [[NSObject alloc] init];NSLog(@\"%@ %p\",[a class],a); 为什么不直接使用 NSString *a = [@&quot;a&quot; copy];? 因为苹果在这里做了优化，对一个常量区字符串copy，没有意义啊，所以直接返回了@”a”; 为什么要mutableCopy后再加copy？ 因为mutableCopy后，变成了可变对象，可变对象不可能为Tagged Pointer，所以需要在copy一下变为不可变对象。 (我这里这样做，没有任何意义，仅仅是为了这次测试，开发中不会这样写代码)。 console输出为： 12NSTaggedPointerString 0xae2f7c76826f6e010x60000104c170 可以看大，a的类型变为了NSTaggedPointerString，a指针的值为0xae2f7c76826f6e01。 最高位是0xa 转换为2进制为 1010，二进制最高位为1，所以是Tagged Pointer。 一个问题如果对Tagged Pointer有了了解，下面这个问题就很好解决了 假设有下面这段代码： 123456789101112@interface NSObject (AssociatedObject) @property (nonatomic, assign) CGFloat someProperty; @end @implementation NSObject (AssociatedObject) @dynamic someProperty; - (void)setSomeProperty:(CGFloat)someProperty{ return objc_setAssociatedObject(self, @selector(someProperty), @(someProperty), OBJC_ASSOCIATION_ASSIGN); } - (CGFloat)someProperty{ return [objc_getAssociatedObject(self, @selector(someProperty)) floatValue]; } @end 123//代码1self.view.someProperty = 100;NSLog(@\"%@\", @(self.view.someProperty)); 123//代码2self.view.someProperty = 999999999999999.1;NSLog(@\"%@\", @(self.view.someProperty)); 分别执行上面两段代码1 和 2。会发生什么问题嘛？ 代码1不会崩溃，代码2会崩溃。因为@(100)没有malloc分配内存，但是数值过大会分配内存，所以需要使用retain。但是上面代码使用的assign。所以调用get方法时，会访问到坏内存。 上面这个问题引用自由Tagged Pointer联想到的一个问题。具体更详细的解释参考这篇文章就行（我这里就是把这个问题记录下来，方便自己以后回顾，因为经常遇到收藏的文章，过一段时间再去访问文章就不见了。可能是作者服务器挂了或者文章被删除了==）。 参考资料： Tagged Pointer字符串 深入理解Tagged Pointer Let’s Build Tagged Pointers 从一道网易面试题浅谈Tagged Pointer) 聊聊伪指针Tagged Pointer 由Tagged Pointer联想到的一个问题","link":"/2018/11/06/Tagged-Pointer/"},{"title":"iOS绘制手势解锁","text":"手势解锁这个功能其实已经用的越来越少了。但是郁闷不知道我公司为什么每次做一个app都要把手势解锁加上。。。。。于是就自己研究了一下手势解锁页面的实现。。 要想实现这个页面，先说说需要掌握哪些：UIPanGestureRecognizer的基本使用CGRectContainsPoint(&lt;#CGRect rect#&gt;, &lt;#CGPoint point#&gt;)UIBezierPath贝塞尔曲线的绘制drawRect 和 layoutIfNeeded 知道何时，如何使用 只要掌握上面说的四点，实现手势解锁就很简单了。上面说的初学者可以自己谷歌学习，学完后再去看我的手势解锁代码，应该就会很明白了。 并且已经适配所有尺寸的iPhone，可以自定义UI源码地址：https://github.com/wqhiOS/WUGesturesToUnlock","link":"/2016/04/02/iOS绘制手势解锁/"},{"title":"iOS图层性能优化","text":"性能优化是一个很广的话题，性能优化包括方方面面，比如代码的执行效率、大文件的读取和写入、网络缓存、流量的使用、动画流畅度、程序的启动时间、应用程序包的大小等等。 这里只介绍关于图层方面的性能优化。 了解Core Animation说起图层，你必须能想到的是Core Animation。在iOS上，几乎所有的东西都是通过Core Animation绘制出来的。Core Animation 的核心是 OpenGL ES 的一个抽象物，简而言之，它让你直接使用 OpenGL ES 的功能，却不需要处理 OpenGL ES 做的复杂的事情。 不要被Core Animation的名字所误解，对于Core Animation，它实际是从Layer Kit演变而来的。所以做动画，仅仅只是Core Animation的冰山一角。 Core Animation是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的图层，存储在一个叫做图层树的体系之中。于是这个树形成了UIKit以及在iOS应用程序当中你所能在屏幕上看见的一切的基础。 首先看一下Core Animation在cocoa中的位置的关系: Core Animation 通过 Core Graphics 的一端和 OpenGL ES 的另一端，精心策划基于 CPU 的位图绘制。因为 Core Animation 处在渲染过程中的重要位置上，所以你如何使用 Core Animation 将会对性能产生极大的影响。 CoreAnimation是如何工作的呢？ 布局 显示 准备 提交 对所有的图层属性计算中间值，设置Open-GL几何形状（纹理话的三角形）来执行渲染 在屏幕上渲染可见三角形 1-5是由CPU来负责的，只有第6步是由GPU负责。 通过下面的两张图，可以更好理解： CPU VS GPU关于图层绘制和动画有两种处理方式：CPU（中央处理器）和GPU（图形处理器）。我们可以说CPU所做的工作都是在软件层面，而GPU做的工作是硬件层面。我们可以用CPU做任何事情，但是对于图像处理(CPU也可以做，但是效率低)，通常用硬件会更快，因为GPU使用图像对高度并行浮点运算做了优化。 GPU 是一个专门为图形高并发计算而量身定做的处理单元。它并发的本性让它能高效的将不同纹理合成起来。它连接到 CPU。从硬件上讲两者之间存在某种类型的总线，并且有像 OpenGL，Core Animation 和 Core Graphics 这样的框架来在 GPU 和 CPU 之间精心安排数据的传输。为了将像素显示到屏幕上，一些处理将在 CPU 上进行。然后数据将会传送到 GPU，这也需要做一些相应的操作，最终像素显示到屏幕上。 针对图层的性能优化，说白了就是关于如何智能利用GPU和CPU，使他们均衡的被使用，不超出负荷。 可以大体粗略的说，图层绘制到屏幕之前或者做动画之前的大多数工作都是由CPU处理的，而GPU是用来采集图片和形状(三角形)，运行变换，应用纹理和混合然后把它们输送才屏幕上。 GPU的相关操作基于GPU的哪些常见操作会降低图层绘制： 太多的几何结构 重绘（合成compositing）：主要由重叠半透明图层引起 离屏渲染 （Off-Screen Rendering）：离屏渲染指的是GPU在当前屏幕缓冲区以外开辟一个新的缓冲区进行渲染。包括设置图层的圆角、图层遮罩(mask)、阴影、光栅化(shouldRasterize )等都会造成离屏渲染。另外补充在屏渲染的概念：指的是GPU的渲染操作在当前用于显示的屏幕缓冲区进行。 过大的图片：如果视图绘制超出GPU支持的尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能。目前的苹果设备最大支持4096x4096尺寸的纹理。如果图片的大小超过4096x4096是无法显示的。必须要用CPU对图片进行预处理。 等等 CPU的相关操作上文已经提到，大多数工作在Core Animation的CPU都发生在动画开始之前。这意味着它不会影响到帧率，但是他会延迟动画开始的时间，让你的界面看起来会比较迟钝。 基于CPU的哪些常见操作会延迟图层绘制的开始时间： 布局计算：因为需要大量的计算，自动布局机制在低版本的iOS系统下尤为明显。 视图懒加载：视图懒加载对内存的使用是很友好的，但是也会有不好的方面，比如你在视图控制器的ViewDidLoad中写入了大量耗时的操作，那等该视图控制器的view被使用时，就会消耗一定的时间。 Core Graphics绘制：如果对视图实现了-drawRect:方法或CALayerDelegate的-drawLayer:inContext:方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。所以这也就是为什么很多地方都会提到，尽量避免重写-drawRect:方法的原因。 解压图片：为了节省内存，iOS通常直到真正绘制的时候才会去解码图片，所以第一次加载图片时都要解压，那对于过大的图片，都会占用一定的时间。 等等 屏幕图像显示原理这篇文章： iOS保持界面流畅的技巧 非常详细得介绍了屏幕图像显示原理，具体内容参考这篇文章，我这里用一张图总结一下。 Instruments工具使用 由于苹果A系列芯片太过于强大，所以建议在测试性能的时候建议至少使用iPhone6以前的手机。我使用的是iPhone5s 注意：本文中提到的一些需要性能优化的地方，不是说这样做是错误的，仅仅是因为如果大量的做了某一个操作，这个操作会占用CPU或者GPU，这些操作堆积在一起，可能在老机型的手机上，造成GPU或者CPU单方面的负荷，导致卡顿等问题。 CoreAnimation 使用CoreAnimation调试，目的是为了找到程序当前卡顿的原因是CPU超负荷还是GPU超负荷造成的。 这里我提供了一个demo用来测试。有两个列表页面，一个是未优化的一个是已优化的，先使用Instruments Core Animation对未优化的列表进行调试，看看问题究竟出在CPU还是GPU。进入未优化的页面如下图，来回滑动列表，肉眼可见的卡顿。 那卡顿原因到底出在哪里，是CPU负荷还是GPU呢？ 图中红色框全出的时间，这时候我在未优化的列表页面始终不停滑动列表。从图中监控的数据可以看出，FPS从未超过15，极其卡顿，GPU使用率几乎达到 百分之百。CPU表现正常。 所以可以得出结论。我们需要对GPU所做的操作进行优化，尽量把GPU所做的一部分工作分给CPU。具体怎么做，上面已经介绍过了。详细可以查看我的这个demo。 我们在进入另一个展示同样列表，且已经性能优化的页面。来回滑动列表，你会发现非常流畅。那我们在使用CoreAnimation工具测试一下，结果如下图(非常稳定，最低59FPS，GPU使用率维持在30%左右，CPU表现正常)： View Debugging Rendering将项目启动运行在真机上。新版Xcode入口在：[Debug] -&gt; [View Debugging] -&gt; [Rendering] &gt; Color Blended Layers因为上文提到了，图层混合是GPU的工作，所以该优化是针对GPU超负荷的情况。如果你用Instruments-CoreAnimation调试，发现GPU使用率很低，几乎就可以放弃这项检测。 该选项用于检测哪里发生了图层混合，并用红色标记出来。因此我们需要尽可能减少看到的红色区域。 如果发现了有大量的红色，我们该如何处理呢？ 关于CALayer的opaque(不透明)属性：该属性可以告诉GPU是否去做合成，YES代表是不透明，GPU不会去做合成，但是对于普通的开发者来说，这个属性用处不大，因为基于UIView的CALayer，它默认的opaque属性就是YES，表示不透明。（虽然很多文章有提到这个属性，但是其实是可以忽略的） 针对项目中用到的图片素材，不仅它本身要是不透明的，并且图片也不要包含alpha通达(因为有一些图片，你看着它是不透明的，但是它包含有alpha通达，仍然后发生图层混合，影响应能） 关于UILabel中含有中文字体时，即使UILabel设置了不透明的背景颜色，可是还是会被标记为红色（因为苹果对显示中文做了不知道是好的还是坏的优化，显示中文是，UILabel会多出一个layer），针对这个的解决办法是：label.layer.masksToBounds = true; (我觉的这个影响微乎其微，可以忽略没有必要处理) Color Offscreen-Rendered Yellow哪些常见操作会造成离屏渲染 阴影 如何优化？ 使用shadowPath 。因为如果没有手动指定，Core Animation会去自动计算，这就会触发离屏渲染，所以可以手动指定阴影路径 如果想给文字添加阴影，最好使用富文本，NSShadow 1layer.shadowPath = UIBezierPath(rect: cell._imageView2.bounds).cgPath 12345let shadow = NSShadow()shadow.shadowOffset = CGSize(width: 0, height: 2)shadow.shadowBlurRadius = 5shadow.shadowColor = UIColor(white: 0, alpha: 0.5)let attText = NSAttributedString(string: text, attributes: [NSAttributedString.Key.shadow: shadow]) 圆角 设置cornerRadius本身并不会导致离屏渲染，但很多时候它还需要配合layer.masksToBounds = true使用。根据之前的总结，设置masksToBounds会导致离屏渲染 如何优化： 光栅化 ，等于加了缓存(开启光栅化等于开启离屏渲染，双刃剑、可以解决，但是并不完美) 创建一个圆形CAShapeLayer，然后设置为mask(完全不推荐、自己尝试后觉得没有效果，mask也是离屏渲染) 使用UIGraphics把当前image画成圆形生成新的UIImage，重新赋值给UIImageView（原理：GPU做的事情，转给了CPU来做。） 1234567891011121314151617181920212223extension UIImageView { func cornerRadiusOptimized(radius: CGFloat) { self.image = self.image?.drawRectWithRoundedCorner(radius: radius, self.bounds.size) }}extension UIImage { fileprivate func drawRectWithRoundedCorner(radius: CGFloat, _ sizetoFit: CGSize) -&gt; UIImage? { let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: sizetoFit) UIGraphicsBeginImageContextWithOptions(rect.size, false, UIScreen.main.scale) let context = UIGraphicsGetCurrentContext() context?.addPath(UIBezierPath(roundedRect: rect, byRoundingCorners: UIRectCorner.allCorners, cornerRadii: CGSize(width: radius, height: radius)).cgPath) context?.clip() self.draw(in: rect) context?.drawPath(using: .fillStroke) let output = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return output }} Color Hits Green and Misses Red该选项用于检测图像缓存是否命中，表示如果命中缓存则显示为绿色，否则显示为红色，显然绿色越多越好，红色越少越好。 这里要提到一个概念：光栅化 光栅化是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。如果对于阴影效果这样比较消耗资源的静态内容进行缓存，可以得到一定幅度的性能提升 CALayer的属性shouldRasterize表示是否设置光栅化 yes代表是 虽然《iOS核心动画高级技巧》性能调优一节中有光栅化做了性能优化，但是我觉得这样的处理还是指标不治本。因为现在的问题是GPU使用率过高，更好的办法是把该部分工作转移个CPU执行。但是光栅化其实仅仅是加了一个缓存，缓存期限也仅仅只有100ms，即0.1s之后缓存就没有了，所以仅仅是对于快速滑动列表时会有一点作用。 光栅化同样会造成离屏渲染。当把光栅化打开的时候，也就代表你手动开启了离屏渲染。 Color Misaligned Images该选项作用不大，其实就是找出哪些图片进行了缩放，因为缩放也是需要时间的。所以，我们在平时开发中，尽量保证图片素材的的大小与视图的frame保持一致。（这条基本可以忽略，除非你视图大小是40x40，结果你用了一张400x400，这种情况肯定是要避免。基本不会有人这样搞吧。。） 参考资料 《iOS Core Animation Advanced Techniques》 WWDC心得：Advanced Graphics and Animations for iOS Apps 绘制像素到屏幕上 iOS保持界面流畅的技巧 UIKit性能调优实战讲解","link":"/2019/03/09/iOS图层性能优化/"},{"title":"iOS内存管理详解","text":"内存管理/引用计数Objective-C的内存管理方式：引用计数 内存管理的思考方式 对象操作 Objective-C方法 生成并持有对象 alloc/new/copy/mutableCopy等方法 持有对象 retain方法 释放对象 release方法 废弃对象 dealloc方法 ​ ​ 这些有关Objective-C内存管理的方法，实际上不包括在该语言中，而是包含在Cocoa框架中用于OS X、iOS应用开发。Cocoa框架中Foundation框架类库的NSObject类担负内存管理的职责。 自己生成的对象，自己持有 12// 自己生成并持有对象id obj = [[NSObject alloc] init]; 使用alloc/new/copy/mutableCopy的方法，取得的对象都是自己生成并持有的。 用这些以外的方法取得的对象，因为非自己生成，所以自己不是对象的持有者。 copy方法利用基于NSCopying方法约定，由各类实现的copyWithZone:方法生成并持有对象的副本，mutable与copy类似 。用copy/mutableCopy方法生成的对象，虽然是对象的副本，但同allco、new方法一样，在“自己生成并持有对象”这点上没有改变。 非自己生成的对象，自己也能持有 12345678 /*取得非自己生成对象，不持有*/id obj = [NSMutableArray array];/*自己持有*/[obj reatin]; 通过retain方法，非自己生成的像 可以被自己所持有。 不再需要自己持有的对象时释放 用alloc/new/copy/mutableCopy方法生成并持有的对象，或者用retain方法持有的对象，一旦不再需要，务必要用release方法进行释放。 无法释放非自己持有的对象 内存管理黄金法则： The basic rule to apple is everything thatincreases the reference counter with alloc,[mutable]copy[WithZone:] or retainis in charge of the corresponding [auto]release. 如果一个对象使用了alloc，[mutable] copy，retain，那么你必须使用相应的[auto]release 苹果对于引用计数的实现在NSObject类的alloc类方法上设置断点，追踪程序的执行。以下列出了执行所调用的方法和函数： 1234+alloc+allocWithZone:class_createInstancecalloc alloc类方法首先调用allocWithZone:类方法，然后调用class_createInstance函数，最后通过调用calloc来分配内存块。 retainCount/retain/release实例方法又是怎么实现呢？同刚才的方法一样，下面列出各个方法分别调用的方法和函数： 123-retainCount__CFDoExternRefOperationCFBasicHashGetCountOfKey 123-retain__CFDoExternRefOperationCFBasicHashAddValue 1234-release__CFDoExternRefOperationCFBasicHashRemoveValue(CFBasicHashRemoveValue返回0时，-release调用dealloc) 各个方法都通过同一个__CFDoExternRefOperation函数，调用了一系列名称相似的函数。如这些函数名的前缀”CF”所示，她们包含于CoreFoundation框架源代码中，即是CFRuntime.c的CFDoExternRefOperation函数。为了理解其实现，下面简化该函数的源代码： 1234567891011121314151617181920int __CFDoExternRefOperation(uintptr_t op, id obj) { CFBasicHashRef table = 取得对象的散列表(obj); int count; switch (op) { case OPERATION_retainCount: count = CFBasicHashGetCountOfKey(table, obj); return count; break; case OPERATION_retain: count = CFBasicHashAddValue(table, obj); return obj; case OPERATION_release: count = CFBasicHashRemoveValue(table, obj); return 0 == count; }} __CFDoExternRefOperation通过switch语句 针对不同的操作来进行具体的方法调用，retainCount/retain/release实例方法也许如下面代码所示： 1234567891011121314- (NSUInteger)retainCount{ return (NSUInteger)____CFDoExternRefOperation(OPERATION_retainCount,self);}- (id)retain{ return (id)____CFDoExternRefOperation(OPERATION_retain,self);}- (void)release{ return ____CFDoExternRefOperation(OPERATION_release,self);} 通过以上，可以看出苹果的大概实现就是将引用计数保存在引用计数表的记录中，而不是保存在对象占用内存块头部中。采用散列表(引用计数表)来管理引用计数。 这样的好处是： 不用在每个对象内存块中考虑引用计数所占的内存 引用技术表各记录中存有内存地址，可从各个记录追溯到各对象的内存块（即使出现故障导致对象占用的内存块损坏，但只要引用计数表没有被破坏，就能够确认各个内存块的位置） 另外，在利用工具检测内存泄漏时，引用计数表的各记录也有助于检测各对象的持有者是否存在。 Autorelease使用autorelease，可使取得的对象存在但自己不持有对象。autorelease提供 这样的功能，使对象在超出指定的生存范围时能够自动并正确地释放(自动调用release方法)。 autorelease的具体使用方法如下 生成并持有NSAutoreleasePool对象 调用已分配对象的autorelease实例方法 废弃NSAutoreleasePool对象 NSAutoreleasePool对象的生存周期相当于C语言变量的作用域。对于所有调用过autorelease实例方法的对象，在废弃NSAutoreleasePool对象时，都将调用release实例方法。 用源代码表示如下： 1234NSAutoReleasePool *pool = [[NSAutoReleasePool alloc] init];id obj = [[NSObject alloc] init];[obj autorelease];[pool drain]; NSAutoreleasePool对象的销毁是调用 drain() 方法 ARC中使用NSAutoReleasePool： 1234@autoreleasepool{ }//在{}中存放的对象会在}后释放掉 使用NSAutoreleasePool减少内存峰值在大量产生autorelease的对象时，只要不废弃NSAutoReleasePool对象，那么生成的对象就不能被释放，因此有时会产生内存不足的现象。典型的例子是读入大量图象的同时改变其尺寸。图象文件读入到NSData对象，并生成UIImage对象，改变该对象的尺寸后生成新的UIImage对象。这种情况下，就会大量生成autorelease对象。 12345678for (int i = 0, i &lt; 图像数, ++i) { /* *读入图像 *大量产生autorelease对象 *由于没有废弃NSAutoreleasePool对象 *最终导致内存不足 */} 在此情况下，有必要在适当地方生成、持有或废弃NSAutoreleasePool对象。 1234567891011for (int i = 0; i &lt; 图像数; ++i) { NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; /* *读入图像 */ [pool drain]; /* *通过[pool drain], *autorelease的对象被一起废弃 */} autorelease对象什么时候释放很多人的答案是“当前作用域大括号结束时释放”，显然没有正确理解autorelease的机制。在没有手动添加autoreleasepool的情况下，autorelease对象是在当前runloop迭代结束时释放的。而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop。 看下面代码： 123456789101112131415161718__weak id reference = nil;- (void)viewDidLoad { [super viewDidLoad]; __autoreleasing Person *p = [[Person alloc] init]; reference = p; NSLog(@\"%@\",reference);//Console: &lt;Person: 0x60000000f170&gt;}- (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; NSLog(@\"%@\",reference);//Console: &lt;Person: 0x60000000f170&gt;}- (void)viewDidAppear:(BOOL)animated { [super viewDidAppear:animated]; NSLog(@\"%@\",reference);//Console: (null)} 由于这个vc在loadView之后便add到了window层级上，所以viewDidLoad和viewWillAppear是在同一个runloop调用的，因此在viewWillAppear中，这个autorelease的变量依然有值。当然我们也可以手动干预autorelease对象的释放时机： 12345678910111213141516171819__weak id reference = nil;- (void)viewDidLoad { [super viewDidLoad]; @autoreleasepool { __autoreleasing Person *p = [[Person alloc] init]; reference = p; } NSLog(@\"%@\",reference);//Console: (null)}- (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; NSLog(@\"%@\",reference);//Console: (null)}- (void)viewDidAppear:(BOOL)animated { [super viewDidAppear:animated]; NSLog(@\"%@\",reference);//Console: (null)} 苹果对于autorelease的实现autorelease实例方法的本质就是调用NSAutoreleasePool对象的addObject方法。 系统在每个runloop迭代中都加入了自动释放池的Push和Pop方法。具体为runloop开始的时候调用AutoreleasePoolPage的Push方法，结束的时候调用Pop方法。 1234567void *objc_autoreleasePoolPush(void) { return AutoreleasePoolPage::push();}void objc_autoreleasePoolPop(void *ctxt) { AutoreleasePoolPage::pop(ctxt);} 那么AutoreleasePoolPage是什么东西呢？ AutoReleasePoolPage是一个C++的类，在NSObject.mm中定义是： 123456789class AutoreleasePoolPage { magic_t const magic; id *next; pthread_t const thread; AutoreleasePoolPage * const parent; AutoreleasePoolPage *child; uint32_t const depth; uint32_t hiwat;}; magic 用于对当前 AutoreleasePoolPage`完整性的校验 thread 保存了当前所在的线程 每一个自动释放池都是由一系列的AutoreleasePoolPage组成的，并且每一个AutoreleasePoolPage的大小都是4096字节(0x1000) 自动释放池中的AutoreleasePoolPage是以双向链表的形式链接起来的： parent 和 child 就是用来构造双向链表的指针。 autorelease和runloop的关系runloop开始启动的时候会创建autoreleasePool，结束的时候会销毁autoreleasePool ARC引用计数内存管理的本质部分在ARC中并没有改变。ARC只是自动帮我们处理“引用计数”的相关部分。 所有权修饰符ARC有效时，id类型和对象类型同C语言其他类型不同，其类型上必须附加所有权修饰符。所有权修饰符一共有4中。 __strong __strong修饰符是id类型和对象类型默认的所有权修饰符。__strong修饰符表示对对象的“强引用”，持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放。 __strong修饰符修饰的变量，不仅仅只在变量作用域中，在赋值上也能够正确地管理其对象的所有者。 通过__strong修饰符，不必再键入retain或者release，完美地满足了“引用技术内存管理的思考方式” __weak 多用来解决“循环引用”的问题。 __weak修饰符还有另外一个优点，在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于nil被赋值的状态（空弱引用）。 __unsafe_unretained __unsafe_unretained修饰符正如其名unsafe所示，是不安全的所有权修饰符。尽管ARC式的内存管理是编译器的工作，但附有 __unsafe_unretained修饰符的变量不属于编译器的内存管理对象。 和__weak一样都是弱引用。但是当引用的对象被废弃后，指针不会置为nil，会造成野指针 __autoreleasing 12345678910/* ARC无效 */NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];id obj = [[NSObject alloc] init];[obj autorelease];[pool drain];/* ARC有效 与上面代码等价 */@autoreleasepool { id __autoreleaseing obj = [[NSObject alloc] init];} ARC有效时，autorelease功能是起作用的。用@autorelasepool块替代NSAutoreleasePool类，用附有__autoreleasing修饰符的变量替代autorelease方法。 对象赋值给附有__autorelease修饰符的变量等价于在ARC无效时调用对象的autorelease方法，即对象被注册到autoreleasepool。 显示地附加_autoreleaseing修饰符同显示地附加\\_strong修饰符一样罕见，所以在ARC中经常非显示地使用___autoreleasing修饰符。 非显示地使用__autoreleaseing修饰符的列子： 1) 12id __weak obj1 = obj0; NSLog(@&quot;class=%@&quot;,[obj1 class]); 下面的代码与上面的相同： 123id __weak obj1 = obj0;id __autoreleasing tmp = obj1;NSLog(@&quot;class=%@&quot;,[tmp class]); 在访问到weak修饰符的变量时必须访问注册到autoreleasepool的对象。这是因为weak修饰符只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。如果把要访问的对象注册到autoreleasepool中，那么在@autoreleasepool块结束之前都能确保该对象存在。因此，使用富有weak修饰符的变量时就必定要使用注册到autoreleasepool中的对象。 2） 123+ (id)array { return [NSMutableArray new];} 上述源代码等同于： 1234+ (id)array { id obj = [NSMutableArray new]; return obj;} 由于return使得对象变量超出其作用域，所以该强引用对应的自己持有的对象会被自动释放，但该对象作为返回值，编译器会自动将其注册到autoreleasePool。 3) id的指针或对象的指针在没有显示指定时会被附加上__autoreleasing修饰符 12NSError *error = nil;Bool result = [obj performOperationWithError:&amp;error]; 该方法的声明为： 1- (BOOL)performOperationWithError:(NSError **)error; 等同于一下源代码： 1- (BOOL)performOperationWithError:(NSError * __autoreleasing*)error; 规则 不能使用retain/release/retainCount/autorelease 不能使用NSAllocateObject/NSDeallocateObject 须遵守内存管理的方法命名规则 不要显示调用dealloc 使用@autoreleasepool块代替NSAutoreleasePool 不能使用区域(NSZone) 不管ARC是否有效，区域在现在的运行时系统中已单纯地被忽略 对象型变量不能作为C语言结构体的成员 C语言的规约上没有方法来管理结构体成员的生命周期。因为ARC把内存管理的工作分配给编译器，所以编译器必须能够知道并管理对象的生命周期。例如C语言的自动变量(局部变量)可使用该变量的作用于来管理对象。但是对于C语言的结构体成员来说，这在标准上就是不可实现的。 如果非要把对象型变量加入到结构体重时，可强制转换为void *或是附加见面所述的__unsafe_unretained修饰符（附有___unsafe_unretained修饰符的变量不属于编译器的内存管理对象。如果管理时不注意赋值对象的所有者，便有可能遭遇内存泄漏或程序崩溃） 显示转换id和void * 通过_bridge，id和void能够相互转换。但是\\_bridge转换，其安全性与赋值给__unsafe_unretained修饰符相近，甚至会更低。如果管理时不注意赋值对象的所有者，就会因悬垂指针而导致程序崩溃。 __bridge转换中还有另外两种转换，分别是__bridge_retained转换和__bridge_transfer转换 ##","link":"/2016/08/20/iOS内存管理/"},{"title":"@property与@dynamic","text":"我们经常使用@property 声明一个属性，但是了解@property到底做了哪些事情呢？ 其实property仅仅是声明了 setter 和 getter 方法（没有实现）。 @property 对应的是 @synthesize 和 @dynamic 在Xcode4.5及以后的版本中，可以省略@synthesize，编译器会默认帮你加上@synthesize ivar = _ivar; @synthesize ivar = _ivar的作用是： 在.m文件中生成一个私有_ivar变量以及生成对应ivar的getter和setter方法的实现。 @dynamic ivar的作用是： 不会生成_ivar变量，也不会生成对应ivar的getter和setter的方法实现。只是告诉编译器,属性的setter与getter方法由用户自己实现，不自动生成。 通过一下代码可以验证，使用@dynamic ivar;的时候，不仅没有getter和setter方法，同时也并没有生成成员变量。 1234567891011121314151617181920@interface Person : NSObject@property (nonatomic, copy) NSString *name;@end@implementation Person@dynamic name;@end{unsigned int ivar_count = 0;unsigned int property_count = 0;//获取所有成员变量class_copyIvarList([Person class], &amp;ivar_count);//获取所有属性class_copyPropertyList([Person class], &amp;property_count);NSLog(@\"%d\",ivar_count);NSLog(@\"%d\",property_count);//当使用@dynamic name: ivar_count = 0;property_count = 1;//当使用@synthesize : ivar_count = 1;property_count = 1;}","link":"/2016/05/11/property与-dynamic/"},{"title":"优雅的使用NSNotification.Name","text":"Swift 3之前使用通知： 1NSNotificationCenter.defaultCenter().post(\"kReceiveMessageNoti\") Swift 3之后 1NotificationCenter.default.post(Notification.Name(rawValue: \"kReceiveMessageNoti\")) 显然 这种使用全局字符串常亮的方法不是很好。 我在阅读Almofire的时候发现，作者是这样使用通知的： 12345extension Notification.Name { public struct Task { public static let DidResume = Notification.Name(rawValue: \"org.alamofire.notification.name.task.didResume\") }} 使用的时候： 12345NotificationCenter.default.post( name: Notification.Name.Task.DidResume, object: self, userInfo: [Notification.Key.Task: task] ) 利用extension为Notification.Name添加一个结构体，在结构体上添加 静态常量办法。直接使用静态常量就可以，但是作者又使用了 结构体，这样做的好处是为了给通知名称分类。 显然这种方法比我们直接使用常量字符串要好很多。下面。再给出我使用enum的方法 1234567891011121314enum DDNotificationName: String { /// 注销成功 case logoutSuccess /// 登录成功 case loginSuccess //收到消息 case receiveMessage var name: NSNotification.Name { return NSNotification.Name(\"k\" + rawValue) }} 1NotificationCenter.default.post(name: DDNotificationName.loginSuccess.name, object: nil)","link":"/2018/05/18/优雅的使用NSNotification-name/"},{"title":"入门汇编语言","text":"了解汇编语言编程语言的发展 机器语言 由0和1组成 汇编语言 （Assembly Language） 用符号代替了0和1，比机器语言便于阅读和机翼 高级语言 C\\C++\\Java\\Swift等，更接近人类自然语言 分别用上面三种语言实现： 将寄存器BX的内容送人寄存器AX 机器语言： 10010100010101 汇编语言：mov ax,bx 高级语言：ax = bx 由此可以看出，越低级的语言，越是难以理解。。。 汇编语言 与 机器语言 一一对应，每一条机器指令都有与之对应的汇编指令 汇编语言 可以通过编译得到机器语言，机器语言可以通过反汇编得到汇编语言 高级语言可以通过编译得到汇编语言 \\ 机器语言，但汇编语言 \\ 机器语言几乎不可能还原成高级语言 汇编语言的特点 所有高级语言（C、Swift、Java等）都是基于操作系统，无法脱离于操作系统之外。但是汇编是基于硬件（可以说是CPU）的语言。 可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度的发挥硬件的功能 汇编指令是机器指令的助记符，同机器指令一一对应。每一种CPU都有自己的机器指令集\\汇编指令集，所以汇编语言不具备可移植性 知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护 不区分大小写、比如 mov 和MOV是一样的 汇编语言种类很多 8086汇编 Win32汇编 Win64汇编 AT&amp;T汇编（Mac、iOS模拟器） ARM汇编（嵌入式设备，也就是手机电视车载系统之类） 汇编语言VS高级语言采用高级语言C++和汇编语言编写同一个功能 ： 将a+b的结果赋值给c，然后在屏幕上打印c的结果 语言 源文件大小 目标文件大小 可执行文件大小 汇编语言 近400字节 近200字节 近600字节 C++ 近150字节 近550字节 近9000字节 CPU总线每一个CPU芯片都有许多管脚（上图右边银色的触角），这些管脚和总线相连，CPU通过总线跟外部进行交互； 总线：一根根导线的集合 总线的分类： 地址总线 数据总线 控制总线 地址总线它的宽度决定了CPU的 寻址能力 （什么是寻址能力，指它能找到多大的地址） 8086的地址总线宽度是20，所以寻址能力即为220B = 210B 2 10=1KB 210 = 1KB * 1024 = 1M 什么是寻址能力？寻址能力为什么如上面这样计算？ 由于解释起来篇幅不短，所以新写一篇文章专门讨论 《CPU寻址能力到底怎么理解？》 数据总线它的宽度决定了CPU的单次数据传送量，也就是数据传送速度 8086的数据总线宽度是16，所以单次最大传递2个字节的数据。因为16根线，代表16位，8位等于1字节，所以是2字节。 注意！！这里的数据总线千万不要和上面的地址总线搞混，完全是两码事儿 控制总线它的宽度决定了CPU对其他器件的控制能力、能有多少种控制 控制总线 知道大概就行，不需要深究 8086的寻址方式CPU访问内存单元时，要给出内存单元的地址，也就是内存地址 8086CPU虽然是16位CPU，但是它有20位地址总线，可以传送20位的地址，1M的寻址能力 内部地址16位，但是却能传送出20位的地址，原因是： 8086采用一种在内部用2个16位地址合成的方法来生成1个20位的物理地址 地址加法器采用 物理地址=段地址*16+偏移地址的方法用段地址和偏移地址合成物理地址。例如，8086CPU要访问123C8H的内存单元是，可以通过1230H*10H+00C8H 主要寄存器 8086有14个寄存器，都是16位。可以存放2个字节（2个字节是一个字word） 通用寄存器AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，称为通用寄存器(有时也有特定用途)；通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对通用寄存器中的数据进行运算。 段寄存器8086有4个段寄存器:CS、DS、SS、ES，当CPU需要访问内存时由这4个段寄存器提供内存单元的段地址。 控制寄存器最常用的控制寄存器IP，通常和CS代码段寄存器搭配使用，为CS服务 CS为代码段寄存器，IP为指令指针寄存器，它们指示了CPU当前要读取指令的地址； 任意时刻，8086CPU都会将CS:IP指向 的指令作为下一条需要执行的指令。 上图有执行顺序编号，详细执行过程如下： CS、IP中的内容送入地址加法器，得到物理地址 20000H 地址加法器将物理地址送入输入输出控制电路 输入输出控制电路将物理地址2000H送上 地址总线 从地址为20000H的内存单元开始，存放的机器指令B8 23 01通过数据总线被送入CPU 输入输出控制电路将机器指令B8 23 01送入 指令缓冲器 读取一条指令后，IP中的值自动增加，以使CPU可以读取下一条指令。因为B82301是3个字节，所以IP中的值加3 ，此时CS:IP指向内存单元2000H:0003H 执行控制器执行指令 B8 23 01即 mov ax,0123h 回到第1步，重复以上的步骤，只不过第一条中的CS仍然为2000H，但是iP已经在第6步中改为了0003H 汇编语言学习资料整理《汇编语言(第三版)》-王爽 豆瓣9.2分 必看！！正在读这本书，真的是特别值得推荐！是我所有读过的国内计算机类书籍中我觉得写得最好的一本。 《汇编语言论坛》 已经很少有人讨论了。但是里面有很多以前讨论的问题和解答，很有参考价值 《零基础入门学习汇编语言》- 小甲鱼 这是一套视频，没有看过，但是在网上查找汇编相关的资料的时候，发现很多网友都是看过这套视频，对于入门应该不错。 上大学的时候记得有看过他的入门C语言视频","link":"/2018/05/15/入门汇编语言/"},{"title":"macOS、Darwin、XNU","text":"OS X is the platform, Darwin is the operating system, and XNU is the kernel. Namely, the XNU kernel is the core piece of software that provides resource management, hardware abstraction, and scheduling. Darwin consists of the XNU kernel and basic software run by there kernel to provide a UNIX environment. OS X is built atop Darwin and provides a collection of frameworks and services that implement the user interface and main application libraries. Darwin and XNU are open source software, but the frameworks that make up the OS X platform on top of Darwin, are not. 引用自：https://www.quora.com/Whats-the-difference-between-Mac-OS-X-Darwin-OS-and-a-popular-Linux-distribution-like-Ubuntu-What-can-be-done-on-Darwin 这里说的OS X，就是macOS，在10.12版本开始(2016年)，苹果OS X正式改名为macOS。 maxOS/iOS是平台，Darwin是操作系统，XNU是内核。即，XNU内核是提供资源管理，硬件抽象和调度的核心软件。Darwin由XNU内核和由该内核运行的基本软件组成，以提供UNIX环境。macOS和iOS都是构建在Darwin之上，并提供了实现用户界面和主要应用程序库的框架和服务的集合。Darwin和XNU是开源软件，但基于Darwin之上的macOS/iOS平台的框架是闭源的。 推荐阅读： Apple Kernel Programming","link":"/2017/11/05/macOS、Darwin、XNU/"},{"title":"在CentOS7上搭建Shadowsocks","text":"前提：购买一台国外主机，我是在搬瓦工上买的 首先使用SSH登录在CENTOS7上搭建Shadowsocks在CENTOS7上搭建Shadowsocks 1ssh -p 端口号 username@ip 例如 我的端口号是23456， username是root ，ip地址是123.232.123.123 “ssh -p 23456 root@123.232.123.123” 登录成功如下： 安装pip登录之后 输入 https://bootstrap.pypa.io/get-pip.py -o get-pip.py 加回车 输入python get-pip.py加回车 效果如下 安装Shadowsocks输入pip install shadowsocks后回车，如下： 配置Shadowsocks输入编辑文件命令vi /etc/shadowsocks.json并回车 输入下面内容 12345678{ &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:9057, &quot;local_port&quot;:10080, &quot;password&quot;:&quot;1234567890&quot;, &quot;timeout&quot;:600, &quot;method&quot;:&quot;aes-256-cfb&quot;} 9057 是端口 1234567890 是密码 将Shadowsocks加入系统服务输入编辑文件命令vi /etc/systemd/system/shadowsocks.service并回车 粘贴下面内容： 1234567[Unit]Description=Shadowsocks[Service]TimeoutStartSec=0ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json[Install]WantedBy=multi-user.target 启动Shadowsocks服务，并设置开机自动启动12345678# 设置开机自启命令systemctl enable shadowsocks# 启动命令systemctl start shadowsocks#查看状态命令systemctl status shadowsocks 依次执行上面三条命令如下： active 显示running 就成功了 Mac shadowsocks 软件下载地址： https://github.com/shadowsocks/ShadowsocksX-NG iOS shadowsocks 要去国外appStore 下载","link":"/2019/08/14/在CentOS7上搭建Shadowsocks/"},{"title":"汇编学习踩坑记录","text":"对于汇编学习，网上的资源相比高级语言算是挺少的了。这里，记录下在学习汇编过程踩过的坑和遇过的问题。 mov ax ffffhmov ax ffffh这段指令，编译器会报错。 原因：大于9ffffh的十六进制数据，如果a000h、a001h……ffffh等，在书写的时候都是以字母开头。而在汇编源程序中，数据不能以字母开头，所以要在前面加0。 应该改为： 1mov ax 0ffffh mov ax [0h]把地址为 1000h:[0h]的内存单元的内容赋值给ax时，我们可能会这样写 123mov ax,1000hmov ds,axmov ax,[0h] 这段汇编代码没有任何问题，但是其中mov ax,[0h]在masm编译器中是亲测是无法达到预期的效果，会被解释为 mov ax,0h 为了达到预期效果，可以把指令改为 1mov ax,ds:[0h] 或者使用emu8086编写汇编代码，就不会出现上面的问题。 自从出现这个问题。我就再也不适用masm编译了，以免踩到跟多的坑。 Debug.exe常用命令 r 查看各个寄存器 d 查看内存单元/寄存器中的内容 u 查看内存单元对应的指令 e 写入指令 t 执行下一条指令 g g xxxx (xxxx为内存物理地址)。表示程序直接执行到 xxxx对应的指令。 p 如果下一条指令是int，要想正确执行下一条指令，是用p 如果遇到loop想自动执行完loop，可以使用p 寄存器中最大存储的十进制数为65535x86 CPU为16位，也就是说寄存器为16位，最大存储两个字节，一个字。 寄存器存储的最大16进制数为ffffh = 16^4-1=65535 所以在使用十进制赋值的时候，注意不要超过65535 如果段中的数据占N个字节，则程序加载后，该段实际占有空间为多少？《汇编语言》第三版这本书 给的答案是：（N/16+1)*16 这个答案是 错误 如果当N = 16时，如果按照答案，得到的是32，其实还是16。如果不确定，可以自己动手测试一下(经过我自己的测试、确实不是32，而是16) 准确答案是： 当N可以被16整除时 占有的空间为(N/16)*16 当N不可以被16整除时 占有的空间为(N/16+1)*16 上面两种情况总结成一个通用的公式：((N+15)/16)*16 8086汇编中 每个段都是以16字节来对齐的 至于为什么这样子设计，我觉得应该是根据8086CPU特殊的寻址方式(段地址*16+偏移地址 )有关。比如一个段中的数据占了17个内存单元，那下一个段，肯定不是从第18个内存单元开始，因为段地址起始地址，必须是16的整数倍。所以如果一个段中的数据占17个内存单元，那紧挨着它的下一个段肯定是从第33个内存单元(也就是编号32开始)开始。 如果理解了上面的问题，可以动手做一下下面的题目，巩固对上面的理解 答案： 123456789101112131415161718192021222324252627282930313233assume cs:codea segment db 1,2,3,4,5,6,7,8a endsb segment db 1,2,3,4,5,6,7,8b endsc segment db 0,0,0,0,0,0,0,0c endscode segmentstart: mov ax,a mov ds,ax mov bx,0 mov cx,8s:mov al,ds:[bx] add al,ds:[bx+16] ; 注意！！！这里是16 不是8 我第一次写的时候写成了8 结果在调试的时候发现了这个错误 mov ds:[bx+32],al ; 注意！！！这里是32 不是16 add bx,1 loop s mov ax,4c00h int 21hcode endsend start","link":"/2018/05/28/汇编学习踩坑记录/"},{"title":"多线程基础篇","text":"进程与线程学习多线程之前，首先要了解什么是进程和线程，以及进程与线程的关系： 《OS X and iOS Kernel Programming》这本书中对进程和线程分别做了如下定义： When the user launches an application, the operating system loads the program’s code and data into memory from disk and begins executing its code. A program being executed is known as a “process.” Unlike a program, a process is an active entity, and consists of a snapshot of the state of the program at a single instance during execution. Modern operating systems no longer treat processes as the basic units of operation, instead work with threads. A thread is merely a distinct register state, and more than one can exist in a given process. All threads share the virtual memory space, descriptors and handles. 上面有这样一句话：A thread is merely a distinct register state(线程仅仅是一个不同的寄存器状态)。我对于这句话的理解就是线程相对于真实存在的进程来说，是一个相对虚拟的概念，仅仅是用不同的寄存器状态来区分不同的线程。由于我本身对操作系统了解还不够深入，所以我也不确定我的理解完全正确。 进程： 进程是指在系统中运行的一个应用程序。（比如打开QQ,就是打开了一个进程） 每个进程之间是相互独立的，每个进程均运行在受保护的内存空间内 线程： 一个进程想要执行任务，必须得有线程（每个进程至少有一条线程） 进程中的所有任务都是在线程中执行的 总结： 进程有独立的空间地址，而线程只是一个进程中的不同执行路径。 进程是资源分配的基本单位(进程是一块包含了某些资源的内存区域)。 线程是CPU独立运行和独立调度的基本单位(可以理解为一个进程中执行的代码片段)。 多线程了解了进程和线程之后，那什么是多线程呢？ 1个进程中可以开启多条线程，每条线程中可以并行（同时）执行不同的任务。 并发(concurrency)和并行(parallel)的区别 并发(concurrency)：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。 并行(parallel)：当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行。 多线程并发执行的原理？ 在同一时间内。CPU只能处理1条线程，只有1条线程在工作（执行）。多线程并发（同时）执行，其实是CPU快速地在多线程之间调度（切换），如果CPU调度线程的时间足够快。那就造成了多线程并发执行的假象。 合理利用线程： 优点 能适当提高程序的执行效率 能适当提高资源利用率（CPU、内存利用率） 缺点 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序性能 线程越多，CPU在调度线程上的开销就越大 程序设计更加复杂：比如线程之间的通信、多线程的数据共享 线程的状态 下面分别阐述线程周期中的每一步： 创建：实例化线程对象 就绪/开启：向线程对象发送start消息，线程对象被加入可调度线程池等待CPU调度。 运行：CPU负责调度可调度线程池中线程的执行。线程执行完毕之前，状态可能会在就绪和运行之间来回切换。就绪和运行之间的状态变化由CPU负责，程序员不能干预。 阻塞：当满足某个预定条件时，可以使用休眠或锁，阻塞线程执行。sleepForTimeInterval（休眠指定时长），sleepUntilDate(休眠到指定日期),@synchronized(self)：(互斥锁)、metux锁、OSSpinLock锁等等。被阻塞的线程不在可调度线程池中，一旦阻塞就会从可调度线程池中移除。等到就绪转态时，又会重新加入可调度线程池。 死亡：正常死亡，线程执行完毕。非正常死亡，当满足某个条件后，在线程内部中执行/在主线程中止线程对象。（注意，网上看到有很多资料说，线程死亡后，线程对象从内存中移除。这种说法肯定是错误的。线程死亡并不代表线程对象一定就从内存中移除了，还是要遵循引用计数，如果有其他对象对线程引用，那内存就不会释放。） NSThread - exit 和cancel +exit() 一旦强行终止线程，后续的所有代码都不会被执行 exit线程死后，线程不能起死回生，不能再调用线程的start，否则会崩溃 -cancel()：取消，并不会直接取消线程，只是给线程对象添加isCancelled标记。 1234567891011121314151617- (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(test) object:nil]; [self.thread start];}- (void)test { for (int i = 0; i &lt; 50; i++) { NSLog(@&quot;%d&quot;,i); if (i == 20) { [self.thread cancel];//不会立马结束 //[NSThread exit];//会立马结束 } }} iOS中多线程的实现方案 实现方案 特点 使用语言 使用频率 线程生命周期 pthread 1）跨平台，可移植； 2）使用起来有点麻烦 C 几乎不用 由程序员进行管理 NSThread 1）面向对象；2）简单，可以直接操作线程对象 OC 偶尔 由程序员进行管理 GCD 1）旨在替代NSThread等线程技术 2）充分利用设备的多核 C 经常 自动管理 NSOperation 1）底层是GCD；2）比GCD多了一些更简单实用的功能；3）实用更加面向对象 OC 经常 自动管理 pthread123456789101112// import &lt;phtread.h&gt;//1.创建线程对象 pthread_t thread; //2.创建线程 /* 第一个参数:线程对象 传递地址 第二个参数:线程的属性 NULL 第三个参数:指向函数的指针 第四个参数:函数需要接受的参数 */ pthread_create(&amp;thread, NULL, task, NULL); NSThread基本使用1234567891011121314151617181920212223//第一种创建线程的方式：alloc init.//特点：需要手动开启线程，可以拿到线程对象进行详细设置//创建线程/*第一个参数：目标对象第二个参数：选择器，线程启动要调用哪个方法第三个参数：前面方法要接收的参数（最多只能接收一个参数，没有则传nil）*/NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(run:) object:@\"wendingding\"];//启动线程[thread start]; //第二种创建线程的方式：分离出一条子线程//特点：自动启动线程，无法对线程进行更详细的设置/*第一个参数：线程启动调用的方法第二个参数：目标对象第三个参数：传递给调用方法的参数*/[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@\"我是分离出来的子线程\"];//第三种创建线程的方式：后台线程//特点：自动启动线程，无法进行更详细设置[self performSelectorInBackground:@selector(run:) withObject:@\"我是后台线程\"]; 设置线程的属性123456//设置线程的属性//设置线程的名称thread.name = @\"线程A\";//设置线程的优先级,注意线程优先级的取值范围为0.0~1.0之间，1.0表示线程的优先级最高,如果不设置该值，那么理想状态下默认为0.5thread.threadPriority = 1.0; 线程的状态123456//线程的各种状态：新建-就绪-运行-阻塞-死亡//常用的控制线程状态的方法[NSThread exit];//退出当前线程[NSThread sleepForTimeInterval:2.0];//阻塞线程[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:2.0]];//阻塞线程//注意：线程死了不能复生 线程间通信1234567891011121314151617181920212223242526272829-(void)touchesBegan:(nonnull NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event{// [self download2]; //开启一条子线程来下载图片 [NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil];}-(void)downloadImage{ //1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源 NSURL *url = [NSURL URLWithString:@\"http://p6.qhimg.com/t01d2954e2799c461ab.jpg\"]; //2.根据url地址下载图片数据到本地（二进制数据 NSData *data = [NSData dataWithContentsOfURL:url]; //3.把下载到本地的二进制数据转换成图片 UIImage *image = [UIImage imageWithData:data]; //4.回到主线程刷新UI //4.1 第一种方式// [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES]; //4.2 第二种方式// [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES]; //4.3 第三种方式 [self.imageView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:YES];} GCD CGD源码：https://github.com/apple/swift-corelibs-libdispatch 基本概念 两个核心概念:队列和任务 同步函数和异步函数 GCD基本使用 异步函数+并发队列：开启多条线程，并发执行任务 异步函数+串行队列：开启一条线程，串行执行任务 同步函数+并发队列：不开线程，串行执行任务 同步函数+串行队列：不开线程，串行执行任务 异步函数+主队列：不开线程，在主线程中串行执行任务 同步函数+主队列：不开线程，串行执行任务（注意死锁发生） 注意同步函数和异步函数在执行顺序上面的差异 GCD间线程通信123456789101112131415161718192021//0.获取一个全局的队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //1.先开启一个线程，把下载图片的操作放在子线程中处理 dispatch_async(queue, ^{ //2.下载图片 NSURL *url = [NSURL URLWithString:@\"http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg\"]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; NSLog(@\"下载操作所在的线程--%@\",[NSThread currentThread]); //3.回到主线程刷新UI dispatch_async(dispatch_get_main_queue(), ^{ self.imageView.image = image; //打印查看当前线程 NSLog(@\"刷新UI---%@\",[NSThread currentThread]); }); }); GCD其他常用函数12345678910111213141516171819202122232425262728293031323334353637 //栅栏函数（控制任务的执行顺序） dispatch_barrier_async(queue, ^{ NSLog(@\"--dispatch_barrier_async-\"); }); //延迟执行（延迟·控制在哪个线程执行） dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSLog(@\"---%@\",[NSThread currentThread]); });// 一次性代码（注意不能放到懒加载） -(void)once { //整个程序运行过程中只会执行一次 //onceToken用来记录该部分的代码是否被执行过 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ NSLog(@\"-----\"); }); } // 快速迭代（开多个线程并发完成迭代操作） dispatch_apply(subpaths.count, queue, ^(size_t index) { }); // 队列组（同栅栏函数） //创建队列组 dispatch_group_t group = dispatch_group_create(); //队列组中的任务执行完毕之后，执行该函数 dispatch_group_notify(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block); // 进入群组和离开群组 dispatch_group_enter(group);//执行该函数后，后面异步执行的block会被gruop监听 dispatch_group_leave(group);//异步block中，所有的任务都执行完毕，最后离开群组 //注意：dispatch_group_enter|dispatch_group_leave必须成对使用 NSOperation（1）基本概念 NSOperation是对GCD的包装 两个核心概念【队列+操作】 （2）基本使用 NSOperation本身是抽象类，只能使用它的子类 三个子类分别是：NSBlockOperation、NSInvocationOperation以及自定义继承自NSOperation的类 NSOperation和NSOperationQueue结合使用实现多线程并发 （3）相关代码 12345678910111213141516171819202122232425262728293031323334353637383940414243// 01 NSInvocationOperation //1.封装操作 /* 第一个参数：目标对象 第二个参数：该操作要调用的方法，最多接受一个参数 第三个参数：调用方法传递的参数，如果方法不接受参数，那么该值传nil */ NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil]; //2.启动操作 [operation start];------------------------------------------------- // 02 NSBlockOperation //1.封装操作 /* NSBlockOperation提供了一个类方法，在该类方法中封装操作 */ NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{ //在主线程中执行 NSLog(@\"---download1--%@\",[NSThread currentThread]); }]; //2.追加操作，追加的操作在子线程中执行 [operation addExecutionBlock:^{ NSLog(@\"---download2--%@\",[NSThread currentThread]); }]; [operation addExecutionBlock:^{ NSLog(@\"---download3--%@\",[NSThread currentThread]); }]; //3.启动执行操作 [operation start];----------------------------------------------// 03 自定义NSOperation //如何封装操作？ //自定义的NSOperation,通过重写内部的main方法实现封装操作 -(void)main { NSLog(@\"--main--%@\",[NSThread currentThread]); }","link":"/2016/07/08/多线程基础/"},{"title":"如何继承类簇（例如NSString）","text":"在今天之前 如果有人问我 如果给NSString添加一个方法 ，我最先想到的方法肯定就是使用Category。一直觉得NSString是不能被继承的，因为它是类簇，其实如果真的想继承，也是有办法的。 在Cocoa框架里有许多类簇，比如NSArray，NSString，NSNumber（具体什么是类簇就不解释了。网上关于类簇的介绍很多）。 具体关于如何为类簇添加子类，需要遵守几条规则： 子类应该继承自类簇中的抽象基类。 子类应该自定义自己的数据存储方式。（开发者编写NSArray子类时，必须用一个实例变量来存放数组中的对象。这似乎与大家预想的不同，我们以为NSArray自己肯定会保存那些对象，所以在子类中就无须再保存一份了。但是大家要记住，NSArray本身只不过是包在其他隐藏对象外面的壳，它仅仅定义了所有数组都需具备的一些接口。对于这个自定义的数组类来说，可以用NSArray来保存其实例）。 子类应当覆写超类文档中指明需要覆写的方法。 接下来就动手实现如何继承NSArray 和 NSString。 12345678910111213141516171819202122232425262728293031#import \"WUArray.h\"@interface WUArray(){ NSArray *_storeArray;}@end@implementation WUArray- (instancetype)initWithArray:(NSArray *)array { if (self = [super init]) { _storeArray = [NSArray arrayWithArray:array]; } return self;}#pragma mark - override- (NSUInteger)count { return _storeArray.count;}- (id)objectAtIndex:(NSUInteger)index { return [_storeArray objectAtIndex:index];}@end ######以上为WUArray.m文件 123456789101112131415161718192021222324252627#import \"WUString.h\"@interface WUString(){ NSString *_storeString;}@end@implementation WUString- (instancetype)initWithString:(NSString *)aString { if (self = [self init]) { _storeString = [[NSString stringWithString:aString] copy]; } return self;}- (NSUInteger)length { return [_storeString length];}- (unichar)characterAtIndex:(NSUInteger)index { return [_storeString characterAtIndex:index];}@end ######以上为WUString.m 文件 实现完之后 来验证一下：12345WUString *str = [[WUString alloc] initWithString:@\"123456789\"]; NSLog(@\"%@\",[str substringFromIndex:5]); //控制台打印输出为 6789 WUArray *array = [[WUArray alloc] initWithArray:@[@\"h\",@\"e\",@\"l\",@\"l\",@\"0\"]]; NSLog(@\"%@\",[array componentsJoinedByString:@\".\"]); //控制台打印输出为 h.e.l.l.o 在继承的时候 关于要具体覆写超类的哪几个方法，NSString的头文件里面写的有：1234/* NSString primitives. A minimal subclass of NSString just needs to implement these two, along with an init method appropriate for that subclass. We also recommend overriding getCharacters:range: for performance. */@property (readonly) NSUInteger length;- (unichar)characterAtIndex:(NSUInteger)index;","link":"/2017/05/15/如何继承类簇/"},{"title":"深入理解Block","text":"block的本质block看上去是“带有自动变量值的匿名函数”，实际上是作为极普通的C语言源代码来处理的。通过支持Block的编译器，将含有Block语法的源代码转换为一般C语言编译器能够处理的源代码。 在实际编译时无法转换为我们能够理解的源代码，但clang(LLVM编译器)具有转换为我们可读源代码的功能。通过“-rewrite-objc”选项就能将含有Block语法的源代码转换为C++代码。 12345678int main(int argc, const char * argv[]) { void (^blk)(void) = ^{printf(\"Block\\n\");}; blk(); return 0;} 此源代码的Block语法最为简单，它省略了返回值类型以及参数列表。通过clang可变换为一下形式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;//函数指针};//__main_block_impl_0结构体相当于基于objc_object结构体的Objective-C对象的结构体。struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; //结构体的构造函数 (C是不允许这么写的,C++才可以) __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) { //通过isa指针，可以想到block实质是OC的对象 // isa指向block的类对象objc_class结构体。block的类对象通过&amp;_NSConcreteStackBlock初始化。 impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; //impl.FuncPtr保存block执行的内容。在这里就是__main_block_func_0这个c语言函数 impl.FuncPtr = fp; Desc = desc; }};//- 通过block使用的匿名函数实际上是被作为简单的c语言函数来处理。另外根据block语法所属的函数名(此处为main)和该block语法所在该函数出现的顺序值(此处为0)来给经clang变换的函数命名。//- 该函数的参数__cself相当于c++实例方法中指向实例自身的变量this，或是OC中的self，即__cself为指向Block值得变量。static void __main_block_func_0(struct __main_block_impl_0 *__cself) { printf(\"Block\\n\");}static struct __main_block_desc_0 { size_t reserved; size_t Block_size;} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};int main(int argc, const char * argv[]) { void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); //blk为什么能直接调用FuncPtr呢，不是应该blk-&gt;imp.FuncPtr吗，因为这里进行了强制转换，把blk//转为了impl，为什么可以这样转呢，因为impl是blk的第一个变量，所以他们两个的地址其实是一样的。 ((void (*)(·__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); return 0;} 在main方法中，初始化了block，并调用了执行了block，通过clang转换的源代码由于转换较多，看起来不是很清楚，这里优化去掉转换部分，具体如下： 1234567891011121314151617//该源代码将__main_block_impl_0结构体类型的自动变量，即栈上生成的__main_block_impl_0结构体实例的指针，赋值给__main_block_impl_0结构体指针类型的变量。//下面两行对应的代码是：void (^blk)(void) = ^{printf(\"Block\\n\");};//__main_block_impl_0的构造函数需要传入两个参数，上面源代码中构造函数参数有3个，最后一个有默认值，可以不传，所以这里传的是两个参数：//- 第一个参数是block中所执行的具体内容，由block语法转换的C语言函数。//- 第二个参数是静态全局变量初始化的__main_block_desc_0结构体实例指针。// 对应这一部分源代码：// static struct __main_block_desc_0 {// size_t reserved;// size_t Block_size;// } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};// 由此可知，该源代码使用block，即__main_block_impl_0结构体实例的大小进行初始化。struct __main_block_impl_0 tmp = __main_block_impl_0(__main_block_func_0,&amp;__main_block_desc_0_DATA);//这里调用的是__main_block_impl_0的构造函数struct __main_block_impl_0 *blk = &amp;tmp;//这就是简单地使用函数指针调用函数，FuncPtr函数传入的参数__cself,这里为blk，所以也证明了__cself指向block自身。把blc传给FuncPtr，为了就是在FuncPtr里面调用block blk-&gt;FuncPtr(blk); 结论：block是指向结构体的指针，又因为该结构体含有isa指针，所以，可以说block本质就是OC对象。 block变量捕获机制123456789101112int main() { int dmy = 256; int val = 10; const char *fmt = \"val = %d\\n\"; void (^blk)(void) = ^{printf(fmt,val);}; blk(); return 0; } 将上面截获变量值的 源代码通过clang进行转换： 123456789101112131415161718192021222324252627282930313233343536373839struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; /*block语法表达式中使用的自动变量被作为成员变量追加到了__main_block_impl_0结构体中：fmt、val没有使用的局部变量不会被追加*/ const char *fmt; int val; /*在初始化结构体实例时，根据传递给构造函数的参数对由自动变量追加的成员变量进行初始化。由此可知，在__main_block_impl_0结构体实例中，自动变量值被截获*/ __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, const char *_fmt, int _val, int flags=0) : fmt(_fmt), val(_val) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { //bound by copy这里的注释表示，block对它引用的局部变量做了只读拷贝，也就是说block引用的是局部变量的副本。所以在执行block语法后，即使改写block中使用的局部变量的值也不会影响block执行时局部变量的值。 const char *fmt = __cself-&gt;fmt; // bound by copy int val = __cself-&gt;val; // bound by copy printf(fmt,val);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size;} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};int main() { int dmy = 256; int val = 10; const char *fmt = \"val = %d\\n\"; void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val)); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); return 0;} 总的来说，所谓“截获自动变量值”意味着在执行block语法时，block语法表达式所使用的自动变量值来保存到block的结构体实例中。 另外需要注意的是，block不能直接使用C语言数组类型的自动变量。为什么呢？因为block截获自动变量时，是通过将值传递给结构体的构造函数进行保存。因为c语言不允许这种赋值 1234void func(char a[10]) { char b[10] = a;//此处报错：Array initializer must be an initializer or string literal printf(\"%d\\n\",b[0]);} __block说明符再来回顾前面截获自动变量值得例子 1^{printf(fmt,val);} 该源代码转换如下 12345static void __main_block_func_0(struct __main_block_impl_0 *__cself) { const char *fmt = __cself-&gt;fmt; // bound by copy int val = __cself-&gt;val; // bound by copy printf(fmt,val);} block中所使用的被截获自动变量就如“带有自动变量值的匿名函数”所说，仅截获自动变量。block中使用自动变量后，在block的结构体实例中重写该自动变量也不会改变原先截获的自动变量。 如果在block中修改截获自动变量的值会产生编译错误，因为在实现上不能改写截获自动变量的值。 解决这种问题有两个方法。 第一种：C语言中有几种变量允许block改写值： 静态局部变量 静态全局变量 全局变量 虽然block语法的匿名函数部分简单地变换为了c语言函数，但从这个变换的函数中访问静态全局变量/全局变量并没有任何改变，可直接使用。但是静态局部变量的情况下，转换后的函数原本就设置在含有block语法的函数外面，所以无法在变量作用域访问。 看一下下面的代码： 1234567891011121314151617int global_val = 1;static int static_global_val = 2;int main() { static int static_val = 3; void (^blk)(void) = ^{ global_val *= 1; static_global_val *= 2; static_val *= 3; }; blk(); return 0; } 源代码转换后如下： 12345678910111213141516171819202122232425262728293031323334353637int global_val = 1;static int static_global_val = 2;struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; //将静态局部变量的地址作为成员变量保存 int *static_val; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_val, int flags=0) : static_val(_static_val) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { int *static_val = __cself-&gt;static_val; // bound by copy global_val *= 1; static_global_val *= 2; (*static_val) *= 3;}static struct __main_block_desc_0 { size_t reserved; size_t Block_size;} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};int main() { static int static_val = 3; void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val)); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); return 0;} 通过转换后的代码可以得知，对静态全局变量和全局变量的访问与转换前完全相同，因为他们是全局变量，不管在哪里都可以访问到，没有作用域的限制。但是对于静态局部变量，为什么要使用指针来访问呢？ 因为静态局部变量在其所在函数结束后，是仍然存在的（自动变量在函数结束后就不存在），但又因为在其他函数中无法引用到该静态局部变量，所以通过将静态局部变量的指针传递给block结构体的构造函数并作为成员变量保存，是超出作用域使用静态局部变量的最简单方法。 静态局部变量的这种方法也适用于自动变量的访问。但是我们为什么没有这么做呢？因为前面已经提到了，在变量作用域结束的同时，静态局部变量没有被废弃，而自动变量被废弃掉了，所以将不能通过指针访问原来的自动变量。 第二种方法是使用”__block说明符””__block说明符“,更准确的表述方式为”__block存储域类说明符”。 下面是使用__block修饰自动变量的代码： 1234567891011int main() { __block int val = 10; void (^blk)(void) = ^ { val = 1; }; blk(); return 0;} 上述代码变换后如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct __Block_byref_val_0 { void *__isa; __Block_byref_val_0 *__forwarding; int __flags; int __size; int val;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_val_0 *val; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, int flags=0) : val(_val-&gt;__forwarding) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_val_0 *val = __cself-&gt;val; // bound by ref (val-&gt;__forwarding-&gt;val) = 1; }static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)&amp;dst-&gt;val, (void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main() { __attribute__((__blocks__(byref))) __Block_byref_val_0 val = {(void*)0,(__Block_byref_val_0 *)&amp;val, 0, sizeof(__Block_byref_val_0), 10}; void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, 570425344)); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); return 0;} 只是在自动变量上附加了__block说明符，源代码量就急剧增加。 __block修饰的val变量 1__block int val = 10; ，转换成了： 1234567struct __Block_byref_val_0 { void *__isa; __Block_byref_val_0 *__forwarding; int __flags; int __size; int val;}; 这里能够发现，__block修饰的自动变量也同block一样变成了__Block_byref_val0结构体类型的自动变量，即栈上生成的\\_Block_byref_val_0结构体实例。 再来看一下__block变量赋值的代码： 123^ { val = 1; }; 该源代码转换如下： 123456static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_val_0 *val = __cself-&gt;val; // bound by ref (val-&gt;__forwarding-&gt;val) = 1; } block的__main_block_impl0结构体实例持有指向变量的\\_Block_byref_bal_0结构体实例的指针。__Block_byref_bal_0结构体实例的成员变量__forwarding持有指向该实例自身的指针。通过成员变量__forwarding访问成员变量val。 这里会遇到3个问题 1.为什么_block变量的\\_Block_byref_val_0结构体不放在__main_block_impl_0结构体中？ 这样做是为了在多个Block中使用__block变量。达到复用效果，从而节省不必要的空间开销。 2.block超出变量作用域可存在的理由 3.__block变量的结构体成员变量__forwarding存在的理由。 问题2和3，留到下面讲解 Block存储域通过前面的说明可知，block转换为block的结构体类型的自动变量，_block变量转换为\\_block变量的结构体类型的自动变量。 block也是Objective-C对象，block的类有： _NSConcreteStackBlock _NSConcreteGlobalBlock _NSConcreteMallocBlock 全局block特点：应用程序在它就在。 在记录全局变量的地方写block的时候，block为全局block 不在书写全局变量的地方，只要不截获自动变量，不管用什么修饰符修饰，都是全局block。 全局变量全部粗放在静态存储区，在程序开始执行时给全局变量分配存储区，程序执行完毕就释放。它们占据固定的存储单元。 栈block特点：声明周期由系统控制，超出其所在作用域即销毁。 截获自动变量且没有强指针引用的时候，为栈block。栈block因为存储在栈上，所以在超出其作用域时被销毁，不会存在了。 在ARC下。会默认添加__strong修饰符，所以很少会出现栈block。 大多数情况编译器会会在适当的地方添加修饰，把block从栈复制到堆，比如将block作为函数返回值时。不过在此之外的情况下需要手动生成代码，将block从栈复制到堆上。 编译器不能进行判断是什么样的状况呢？如下所示： 向方法或函数的参数中传递block时 但是如果在方法或函数内部适当地复制了传递过来的参数，那么就不必在调用该方法或函数前手动复制了。以下方法或函数不用手动复制： Cocoa框架的方法且方法名中含有usingBlock等时 GCD的api 以下两个例子在ARC下都为栈block： 12345678- (id)getBlockArray { int val = 10; return [[NSArrary alloc] initWithObjects: ^{NSLog(@&quot;blk0:%d&quot;,val);}, ^{NSLog(@&quot;blk0:%d&quot;,val);}, nil ];} 123//栈blockint i = 0;NSLog(@&quot;%@&quot;,^{NSLog(@&quot;%d&quot;,i);});//输出结果 __NSStackBlock__: 0x7fff57aada78&gt; 堆block特点：没有强指针引用即销毁，生命周期由程序员手动管理 栈block有强指针strong/copy引用就会被copy到堆中，变成堆block 通过对着3类block的解释，也解释了为什么block在超出其作用域仍然可以存在。 __block变量存储域block从栈复制到堆时对__block变量产生的影响： __block变量的配置存储域 block从栈复制到堆时的影响 栈 从栈复制到堆并被block持有 堆 被block持有 在一个block中使用_block变量，则当该block从栈复制到堆时，使用的所有\\_block变量也必定配置在栈上。这些__block变量也全部从栈复制到对上。此时block持有__block变量。即使在该block已复制到堆的情况下，复制Block也对所使用的__block变量没有任何影响。 在多个block中使用__block变量，因为最先会将所有的block配置在栈上，所以__block变量也会配置在栈上。在任何一个block从栈复制到堆时，__block变量也会一并从栈复制到堆并被该block所持有。当剩下的block从栈复制到堆时，被复制的block持有__block变量，并增加__block变量的引用计数。 如果配置在堆上的block被废弃，那么它会释放所持有的_block变量，当该\\_block变量没有持有者时，就会释放。 到这里我们可以看出，此思考方式与OC的引用计数内存管理完全相同。 看如下源代码： 12345678910111213int main() { __block int val = 0; //在arc下，不用copy就可以了。因为默认会有__strong修饰符 void (^blk)(void) = [^{++val;} copy]; ++val; blk(); //打印结果为2。说明栈上的val结构体，和堆上的val结构体，指向同一块内存地址。为什么呢？下面会给出答案。 printf(\"%d\",val);} 转换后如下： 1234567891011121314151617181920212223242526272829303132333435363738394041struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_val_0 *val; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, int flags=0) : val(_val-&gt;__forwarding) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_val_0 *val = __cself-&gt;val; // bound by ref ++(val-&gt;__forwarding-&gt;val);}static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;val, (void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};//只留下main函数，其他部分这里省略int main() { __attribute__((__blocks__(byref))) __Block_byref_val_0 val = {(void*)0,(__Block_byref_val_0 *)&amp;val, 0, sizeof(__Block_byref_val_0), 0}; void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, 570425344)); //注意这里！ ++(val.__forwarding-&gt;val); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); printf(\"%d\",(val.__forwarding-&gt;val));} 在上述源代码中，利用copy方法复制使用了_block变量的block，block和\\_block变量两者均从栈复制到了堆上。代码中有两处使用到了val，一处是在block的匿名函数里，使用的是堆上的val，另一处是复制前栈上的__block变量的结构体实例的地址。 那是如何保证，不管__block变量是配置在栈上还是堆上，都能够正确的访问该变量呢？ 因为栈上的_block变量用结构体实例在\\_block变量从栈复制到堆上时，会将成员变量__forwarding的值替换为复制目标上的__block变量结构体实例的地址。所以就算使用栈上的__block变量。访问的其实还是堆上的那个。如下图所示： 通过该功能，无论是在block语法中、block语法外使用_block变量，还是\\_block变量配置在栈上或堆上，都可以顺利地访问同一个__block变量。 截获对象来看一下在block语法中使用对象的语法： 12345678910blk_t blk;{ NSMutableArray *array = [[NSMutableArray alloc] init]; blk = ^(id obj) { [array addObject:obj]; };}blk([NSObject new]);blk([NSObject new]);blk([NSObject new]); 变量作用域结束的同时，变量array被废弃，其强引用失效，因此赋值给变量的array的NSMutableArray类的对象必定被释放并废弃。但是上述代码能够运行正常。这一结果意味着赋值给变量array的NSMutableArray类的对象在该源代码最后block的执行部分超出其作用域而存在。通过编译转换后的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849typedef void (*blk_t)(id);struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; id array;//这里是在arc环境下，默认有__strong修饰符。强引用 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id _array, int flags=0) : array(_array) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself, id obj) { id array = __cself-&gt;array; // bound by copy ((void (*)(id, SEL, ObjectType))(void *)objc_msgSend)((id)array, sel_registerName(\"addObject:\"), (id)obj);}static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;array, (void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main(int argc, const char * argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; blk_t blk; { id array = ((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSMutableArray\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")); blk = ((void (*)(id))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, array, 570425344)); } //(*blk-&gt;impl.FuncPtr)(blk, [NSObject new]); ((void (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSObject\"), sel_registerName(\"new\"))); ((void (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSObject\"), sel_registerName(\"new\"))); ((void (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSObject\"), sel_registerName(\"new\"))); } return 0;} 请注意被赋值NSMutableArray对象并被截获的自动变量array。我们可以发现，它是block结构体中的成员变量： 12345678910111213struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; //注意这里 id __strong array; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id _array, int flags=0) : array(_array) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }}; 在Objective-C中，C语言结构体不能含有附有_strong修饰符的变量（换句话说：对象型变量不能作为C语言结构体的成员）。因为编译器不知道何时进行C语言结构体的初始化和废弃操作，不能很好地管理内存。但是Objective-C运行时库能够准确把握block从栈复制到堆以及堆上的block被废弃的时机，因此block结构体中即使含有对象型变量，也可以恰当地进行初始化和废弃。为此需要使用\\_main_block_desc_0结构体中增加的成员变量copy和dispose（这两个变量都是函数指针，指向函数），以及作为指针赋值给该成员变量的__main_block_copy_0函数和__main_block_dispose_0函数： 1234567static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)&amp;dst-&gt;array, (void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src){ _Block_object_dispose((void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/);} 观察转换后的代码，上面两个函数包括使用指针全部都没有被调用。那么这些函数是从哪儿调用呢？ 函数 调用时机 copy函数 栈上的block复制到堆时 dispose函数 堆上的block被废弃时 那么什么时候栈上的block会复制到堆呢？ 调用block的copy/strong实例方法 block作为函数返回值返回时 将block赋值给附有__storng修饰符id类型的类或block类型成员变量时 在方法中含有usingBlock的Cocoa框架方法或GCD的api中传递block时 也就是说虽然从源代码来看，在上面这些情况下栈上的block被赋值到堆上，但其实可归结为_Blockcopy函数被调用时block从栈复制到堆。相对的，在释放复制到堆上的block后，谁都不持有block而使其被废弃时调用disopose函数。这相当于对象的dealloc方法。有了这种构造，通过使用附有__strong修饰符的自动变量，block中截获的对象就能够超出其变量作用域而存在。虽然这种使用copy函数，dispose函数的方法在之前没有讲解，但实际上在\\_block变量中已经用到了。 __block修饰变量和对象__block说明符可指定任何类型的自动变量。下面指定用于赋值Objective-C对象的id类型自动变量。 1__block id obj = [NSObject new]; 其代码等同于： 1__block id __strong obj = [NSObject new]; 改代码可通过clang转换如下： 在_block变量为附有\\_strong修饰符的id类型或对象类型自动变量的情况下会发生同样的过程。当__block变量从栈复制到堆上时，使用_Block_object_assign函数，持有赋值给__block变量的对象。当堆上的__block变量被废弃时，则使用_Block_object_dispose函数释放赋值给__block变量的对象。 如果__block和__weak一起使用，则block不会被持有，所以不起作用。__block不能和__autoreleasing一起使用，会编译错误。 总结 block截获自动变量时不管截获的自动变量是对象类型还是基本类型，都会在block结构体内部建立一个成员变量进行存储，数据类型与与截获的自动变量数据类型相同。 为什么不能修改截获的自动变量？ 对于值类型，是简单的值传递。（为什么不直接传递指针呢？因为值类型保存在栈上，就算传递了指针，值类型在函数结束后就销毁了。所以传递指针也没有意义。） 对于对象类型是指针浅复制（浅拷贝就是拷贝指向原来对象的指针，使原对象的引用计数+1，可以理解为创建了一个指向原对象的新指针而已，并没有创建一个全新的对象。所以我们可以通过复制后的变量修改这份内存，但是不能修改外部自动变量使其指向另一块内存区域）。 为什么使用__block后就可以修改截获的自动变量？ 被修饰了_block的自动变量不管是基本类型还是对象类型都会被封装到一个结构体类型变量中，表面上看到的是block截获的是自动变量，其实是这个结构体类型变量的指针，因此可以修改自动变量。并且当block从栈上复制到堆上时，栈上的\\_block修饰的自动变量的结构体类型变量的forwarding指针会指向堆上的__block修饰的自动变量的结构体类型变量。所以不管是在栈上还是堆上，在block内还是在block外修改使用__block修饰的自动变量，修改的都是同一块内存区域。 参考： 《Objective-C高级编程:iOS与OS X多线程和内存管理》 《谈Objective-C block的实现-唐巧》 《浅谈 block - 截获变量方式》 《iOS中的深复制与浅复制》","link":"/2018/01/11/深入理解Block/"}],"tags":[{"name":"多线程","slug":"多线程","link":"/tags/多线程/"},{"name":"ReactiveCocoa","slug":"ReactiveCocoa","link":"/tags/ReactiveCocoa/"},{"name":"8086汇编","slug":"8086汇编","link":"/tags/8086汇编/"},{"name":"寻址能力","slug":"寻址能力","link":"/tags/寻址能力/"},{"name":"cpu","slug":"cpu","link":"/tags/cpu/"},{"name":"内存","slug":"内存","link":"/tags/内存/"},{"name":"Tagged Pointer","slug":"Tagged-Pointer","link":"/tags/Tagged-Pointer/"},{"name":"内存管理","slug":"内存管理","link":"/tags/内存管理/"},{"name":"性能优化","slug":"性能优化","link":"/tags/性能优化/"},{"name":"swift tips","slug":"swift-tips","link":"/tags/swift-tips/"},{"name":"Darwin","slug":"Darwin","link":"/tags/Darwin/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"XNU","slug":"XNU","link":"/tags/XNU/"},{"name":"Shadowsocks","slug":"Shadowsocks","link":"/tags/Shadowsocks/"},{"name":"Block","slug":"Block","link":"/tags/Block/"}],"categories":[{"name":"Objective-C","slug":"Objective-C","link":"/categories/Objective-C/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/计算机基础/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"Swift","slug":"Swift","link":"/categories/Swift/"},{"name":"工具","slug":"工具","link":"/categories/工具/"},{"name":"汇编语言","slug":"计算机基础/汇编语言","link":"/categories/计算机基础/汇编语言/"},{"name":"内存管理","slug":"iOS/内存管理","link":"/categories/iOS/内存管理/"},{"name":"性能优化","slug":"iOS/性能优化","link":"/categories/iOS/性能优化/"},{"name":"操作系统","slug":"计算机基础/操作系统","link":"/categories/计算机基础/操作系统/"},{"name":"多线程","slug":"iOS/多线程","link":"/categories/iOS/多线程/"},{"name":"Objective-C底层原理","slug":"iOS/Objective-C底层原理","link":"/categories/iOS/Objective-C底层原理/"}]}