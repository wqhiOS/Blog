{"pages":[{"title":"","text":"LJpMHcjgdy","link":"/baidu_verify_LJpMHcjgdy.html"},{"title":"schedule","text":"","link":"/schedule/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"关于我","text":"于15年从事iOS开发至今，16年毕业于河南大学软件工程系；现居住于上海 工作经历 智慧树网 时间：2018年5月~至今 行业类别：互联网教育 职位：iOS高级开发工程师 善林(上海)金融信息服务有限公司 时间：2015年7月~2018年4月 行业类别：金融 职位：iOS开发工程师 上海思霍网络有限公司 时间：2015年1月~2015年月7月 行业类别：互联网电子商务 职位：iOS开发工程师 联系方式： wuqh_ios@icloud.com","link":"/about/index.html"}],"posts":[{"title":"多线程基础篇","text":"进程与线程学习多线程之前，首先要了解什么是进程和线程，以及进程与线程的关系： 《OS X and iOS Kernel Programming》这本书中对进程和线程分别做了如下定义： When the user launches an application, the operating system loads the program’s code and data into memory from disk and begins executing its code. A program being executed is known as a “process.” Unlike a program, a process is an active entity, and consists of a snapshot of the state of the program at a single instance during execution. Modern operating systems no longer treat processes as the basic units of operation, instead work with threads. A thread is merely a distinct register state, and more than one can exist in a given process. All threads share the virtual memory space, descriptors and handles. 上面有这样一句话：A thread is merely a distinct register state(线程仅仅是一个不同的寄存器状态)。我对于这句话的理解就是线程相对于真实存在的进程来说，是一个相对虚拟的概念，仅仅是用不同的寄存器状态来区分不同的线程。由于我本身对操作系统了解还不够深入，所以我也不确定我的理解完全正确。 进程： 进程是指在系统中运行的一个应用程序。（比如打开QQ,就是打开了一个进程） 每个进程之间是相互独立的，每个进程均运行在受保护的内存空间内 线程： 一个进程想要执行任务，必须得有线程（每个进程至少有一条线程） 进程中的所有任务都是在线程中执行的 总结： 进程有独立的空间地址，而线程只是一个进程中的不同执行路径。 进程是资源分配的基本单位(进程是一块包含了某些资源的内存区域)。 线程是CPU独立运行和独立调度的基本单位(可以理解为一个进程中执行的代码片段)。 多线程了解了进程和线程之后，那什么是多线程呢？ 1个进程中可以开启多条线程，每条线程中可以并行（同时）执行不同的任务。 并发(concurrency)和并行(parallel)的区别 并发(concurrency)：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。 并行(parallel)：当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行。 多线程并发执行的原理？ 在同一时间内。CPU只能处理1条线程，只有1条线程在工作（执行）。多线程并发（同时）执行，其实是CPU快速地在多线程之间调度（切换），如果CPU调度线程的时间足够快。那就造成了多线程并发执行的假象。 合理利用线程： 优点 能适当提高程序的执行效率 能适当提高资源利用率（CPU、内存利用率） 缺点 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序性能 线程越多，CPU在调度线程上的开销就越大 程序设计更加复杂：比如线程之间的通信、多线程的数据共享 线程的状态 下面分别阐述线程周期中的每一步： 创建：实例化线程对象 就绪/开启：向线程对象发送start消息，线程对象被加入可调度线程池等待CPU调度。 运行：CPU负责调度可调度线程池中线程的执行。线程执行完毕之前，状态可能会在就绪和运行之间来回切换。就绪和运行之间的状态变化由CPU负责，程序员不能干预。 阻塞：当满足某个预定条件时，可以使用休眠或锁，阻塞线程执行。sleepForTimeInterval（休眠指定时长），sleepUntilDate(休眠到指定日期),@synchronized(self)：(互斥锁)、metux锁、OSSpinLock锁等等。被阻塞的线程不在可调度线程池中，一旦阻塞就会从可调度线程池中移除。等到就绪转态时，又会重新加入可调度线程池。 死亡：正常死亡，线程执行完毕。非正常死亡，当满足某个条件后，在线程内部中执行/在主线程中止线程对象。（注意，网上看到有很多资料说，线程死亡后，线程对象从内存中移除。这种说法肯定是错误的。线程死亡并不代表线程对象一定就从内存中移除了，还是要遵循引用计数，如果有其他对象对线程引用，那内存就不会释放。） NSThread - exit 和cancel +exit() 一旦强行终止线程，后续的所有代码都不会被执行 exit线程死后，线程不能起死回生，不能再调用线程的start，否则会崩溃 -cancel()：取消，并不会直接取消线程，只是给线程对象添加isCancelled标记。 1234567891011121314151617- (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(test) object:nil]; [self.thread start];}- (void)test { for (int i = 0; i &lt; 50; i++) { NSLog(@&quot;%d&quot;,i); if (i == 20) { [self.thread cancel];//不会立马结束 //[NSThread exit];//会立马结束 } }} iOS中多线程的实现方案 实现方案 特点 使用语言 使用频率 线程生命周期 pthread 1）跨平台，可移植； 2）使用起来有点麻烦 C 几乎不用 由程序员进行管理 NSThread 1）面向对象；2）简单，可以直接操作线程对象 OC 偶尔 由程序员进行管理 GCD 1）旨在替代NSThread等线程技术 2）充分利用设备的多核 C 经常 自动管理 NSOperation 1）底层是GCD；2）比GCD多了一些更简单实用的功能；3）实用更加面向对象 OC 经常 自动管理 pthread123456789101112// import &lt;phtread.h&gt;//1.创建线程对象 pthread_t thread; //2.创建线程 /* 第一个参数:线程对象 传递地址 第二个参数:线程的属性 NULL 第三个参数:指向函数的指针 第四个参数:函数需要接受的参数 */ pthread_create(&amp;thread, NULL, task, NULL); NSThread基本使用1234567891011121314151617181920212223//第一种创建线程的方式：alloc init.//特点：需要手动开启线程，可以拿到线程对象进行详细设置//创建线程/*第一个参数：目标对象第二个参数：选择器，线程启动要调用哪个方法第三个参数：前面方法要接收的参数（最多只能接收一个参数，没有则传nil）*/NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(run:) object:@\"wendingding\"];//启动线程[thread start]; //第二种创建线程的方式：分离出一条子线程//特点：自动启动线程，无法对线程进行更详细的设置/*第一个参数：线程启动调用的方法第二个参数：目标对象第三个参数：传递给调用方法的参数*/[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@\"我是分离出来的子线程\"];//第三种创建线程的方式：后台线程//特点：自动启动线程，无法进行更详细设置[self performSelectorInBackground:@selector(run:) withObject:@\"我是后台线程\"]; 设置线程的属性123456//设置线程的属性//设置线程的名称thread.name = @\"线程A\";//设置线程的优先级,注意线程优先级的取值范围为0.0~1.0之间，1.0表示线程的优先级最高,如果不设置该值，那么理想状态下默认为0.5thread.threadPriority = 1.0; 线程的状态123456//线程的各种状态：新建-就绪-运行-阻塞-死亡//常用的控制线程状态的方法[NSThread exit];//退出当前线程[NSThread sleepForTimeInterval:2.0];//阻塞线程[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:2.0]];//阻塞线程//注意：线程死了不能复生 线程间通信1234567891011121314151617181920212223242526272829-(void)touchesBegan:(nonnull NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event{// [self download2]; //开启一条子线程来下载图片 [NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil];}-(void)downloadImage{ //1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源 NSURL *url = [NSURL URLWithString:@\"http://p6.qhimg.com/t01d2954e2799c461ab.jpg\"]; //2.根据url地址下载图片数据到本地（二进制数据 NSData *data = [NSData dataWithContentsOfURL:url]; //3.把下载到本地的二进制数据转换成图片 UIImage *image = [UIImage imageWithData:data]; //4.回到主线程刷新UI //4.1 第一种方式// [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES]; //4.2 第二种方式// [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES]; //4.3 第三种方式 [self.imageView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:YES];} GCD CGD源码：https://github.com/apple/swift-corelibs-libdispatch 基本概念 两个核心概念:队列和任务 同步函数和异步函数 GCD基本使用 异步函数+并发队列：开启多条线程，并发执行任务 异步函数+串行队列：开启一条线程，串行执行任务 同步函数+并发队列：不开线程，串行执行任务 同步函数+串行队列：不开线程，串行执行任务 异步函数+主队列：不开线程，在主线程中串行执行任务 同步函数+主队列：不开线程，串行执行任务（注意死锁发生） 注意同步函数和异步函数在执行顺序上面的差异 GCD间线程通信123456789101112131415161718192021//0.获取一个全局的队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //1.先开启一个线程，把下载图片的操作放在子线程中处理 dispatch_async(queue, ^{ //2.下载图片 NSURL *url = [NSURL URLWithString:@\"http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg\"]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; NSLog(@\"下载操作所在的线程--%@\",[NSThread currentThread]); //3.回到主线程刷新UI dispatch_async(dispatch_get_main_queue(), ^{ self.imageView.image = image; //打印查看当前线程 NSLog(@\"刷新UI---%@\",[NSThread currentThread]); }); }); GCD其他常用函数12345678910111213141516171819202122232425262728293031323334353637 //栅栏函数（控制任务的执行顺序） dispatch_barrier_async(queue, ^{ NSLog(@\"--dispatch_barrier_async-\"); }); //延迟执行（延迟·控制在哪个线程执行） dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSLog(@\"---%@\",[NSThread currentThread]); });// 一次性代码（注意不能放到懒加载） -(void)once { //整个程序运行过程中只会执行一次 //onceToken用来记录该部分的代码是否被执行过 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ NSLog(@\"-----\"); }); } // 快速迭代（开多个线程并发完成迭代操作） dispatch_apply(subpaths.count, queue, ^(size_t index) { }); // 队列组（同栅栏函数） //创建队列组 dispatch_group_t group = dispatch_group_create(); //队列组中的任务执行完毕之后，执行该函数 dispatch_group_notify(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block); // 进入群组和离开群组 dispatch_group_enter(group);//执行该函数后，后面异步执行的block会被gruop监听 dispatch_group_leave(group);//异步block中，所有的任务都执行完毕，最后离开群组 //注意：dispatch_group_enter|dispatch_group_leave必须成对使用 NSOperation（1）基本概念 NSOperation是对GCD的包装 两个核心概念【队列+操作】 （2）基本使用 NSOperation本身是抽象类，只能使用它的子类 三个子类分别是：NSBlockOperation、NSInvocationOperation以及自定义继承自NSOperation的类 NSOperation和NSOperationQueue结合使用实现多线程并发 （3）相关代码 12345678910111213141516171819202122232425262728293031323334353637383940414243// 01 NSInvocationOperation //1.封装操作 /* 第一个参数：目标对象 第二个参数：该操作要调用的方法，最多接受一个参数 第三个参数：调用方法传递的参数，如果方法不接受参数，那么该值传nil */ NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil]; //2.启动操作 [operation start];------------------------------------------------- // 02 NSBlockOperation //1.封装操作 /* NSBlockOperation提供了一个类方法，在该类方法中封装操作 */ NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{ //在主线程中执行 NSLog(@\"---download1--%@\",[NSThread currentThread]); }]; //2.追加操作，追加的操作在子线程中执行 [operation addExecutionBlock:^{ NSLog(@\"---download2--%@\",[NSThread currentThread]); }]; [operation addExecutionBlock:^{ NSLog(@\"---download3--%@\",[NSThread currentThread]); }]; //3.启动执行操作 [operation start];----------------------------------------------// 03 自定义NSOperation //如何封装操作？ //自定义的NSOperation,通过重写内部的main方法实现封装操作 -(void)main { NSLog(@\"--main--%@\",[NSThread currentThread]); }","link":"/2016/07/08/多线程基础/"}],"tags":[{"name":"多线程","slug":"多线程","link":"/tags/多线程/"}],"categories":[{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"多线程","slug":"iOS/多线程","link":"/categories/iOS/多线程/"}]}