<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wuqihan&#39;s blog</title>
  
  <subtitle>hard work pays off</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wuqihan.cn/"/>
  <updated>2020-01-27T05:48:49.331Z</updated>
  <id>http://www.wuqihan.cn/</id>
  
  <author>
    <name>吴启晗</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Thank You,Kobe Bryant.</title>
    <link href="http://www.wuqihan.cn/2020/01/27/Kobe/"/>
    <id>http://www.wuqihan.cn/2020/01/27/Kobe/</id>
    <published>2020-01-27T05:47:13.000Z</published>
    <updated>2020-01-27T05:48:49.331Z</updated>
    
    <content type="html"><![CDATA[<p>如果时光可以倒流，我一定一定会想尽一切办法告诉你不要乘坐那架该死的直升机！</p><p>我真的没有想到你会以这样的方式离开！</p><a id="more"></a><p>一个人是有多么强的意志力、多么强的好胜心才能在跟腱断裂的情况下，还能独自回场并完成两颗罚球。</p><p>是的，只有你能做到。你永远是我最喜欢的运动员，你永远是我的偶像。</p><p>你的伟大根本不需要用任何数据来修饰。</p><p>我喜欢你并不是因为你的篮球技巧、你有总冠军，你是得分王、你是MVP、也不因为你有过81分，更不是因为我有多喜欢篮球。</p><p>而是因为你的性格，你独一无二的偏执、你的勤奋坚韧、你的倔强、你追求完美，你愿意为了成功付出所有。</p><p>你就是我最想去成为的那个人。</p><p>我在生活工作的各个方面都被你影响着。你告诉我凌晨四点的洛杉矶，你告诉我曼巴精神。你一直都在激励着我，让我像你一样努力、像你一样偏执。</p><p>在你的8号和24号球衣退役仪式上，你说过：</p><p>“那些你早起的时光，那些你努力工作的时光，那些感觉太疲惫的时光，但仍还是继续那样做的时光、那才是梦想的力量。重要的不是目标，是过程”。</p><p>谢谢您的一路陪伴！</p><p>我虽然不是一个优秀的人。但是至少因为您，我并不是那么的差劲。</p><p>You rise me up and I will always love you ! Mamba 4ever!</p><p><strong>曼巴！一路走好！</strong></p><p><strong>愿天堂有您的篮球！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果时光可以倒流，我一定一定会想尽一切办法告诉你不要乘坐那架该死的直升机！&lt;/p&gt;
&lt;p&gt;我真的没有想到你会以这样的方式离开！&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift实现二叉搜索树</title>
    <link href="http://www.wuqihan.cn/2019/11/20/Swift%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://www.wuqihan.cn/2019/11/20/Swift实现二叉搜索树/</id>
    <published>2019-11-20T11:30:33.000Z</published>
    <updated>2019-11-26T13:25:06.651Z</updated>
    
    <content type="html"><![CDATA[<p>基于Swift实现了二叉搜索树，以及支持在console(控制台)中以如下形式输出二叉树：</p><a id="more"></a><p><img src="https://i.loli.net/2019/11/26/8kaWgBH3Tm9A1R2.png" alt="binaryTreePrint.png"></p><p>括号()中的值，代表该节点的父节点，便于测试。你也可以通过修改degugDescrition中的值，自定义节点的展示内容。<br>代码地址：<a href="https://github.com/wqhiOS/BinaryTree" target="_blank" rel="noopener">https://github.com/wqhiOS/BinaryTree</a> </p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>二叉树</code>【Binary Tree】 和 <code>二叉搜索树</code>(或叫查找)【Binary Search Tree】的相关概念 看维基百科就够了。里面有详细介绍二叉树和二叉搜索树，以及优缺点：</p><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">二叉树</a></p><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="noopener">二叉搜索树</a></p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="前-中-后序遍历（深度优先遍历）"><a href="#前-中-后序遍历（深度优先遍历）" class="headerlink" title="前/中/后序遍历（深度优先遍历）"></a>前/中/后序遍历（深度优先遍历）</h3><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><p>遍历二叉树：L、D、R分别表示遍历左子树、访问根结点和遍历右子树，则先(根)序遍历二叉树的顺序是DLR，中(根)序遍历二叉树的顺序是LDR，后(根)序遍历二叉树的顺序是LRD</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(<span class="hljs-number">_</span> block: <span class="hljs-params">(Element)</span></span></span>-&gt;<span class="hljs-type">Void</span>) &#123;</span><br><span class="line">    preorderTraversal(root, block: block)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(<span class="hljs-number">_</span> node: Node&lt;Element&gt;?,block: <span class="hljs-params">(Element)</span></span></span>-&gt;<span class="hljs-type">Void</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> _node = node <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    block(_node.element)</span><br><span class="line">    preorderTraversal(_node.<span class="hljs-keyword">left</span>, block: block)</span><br><span class="line">    preorderTraversal(_node.<span class="hljs-keyword">right</span>, block: block)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(<span class="hljs-number">_</span> block: <span class="hljs-params">(Element)</span></span></span>-&gt;<span class="hljs-type">Void</span>)  &#123;</span><br><span class="line">  inorderTraversal(root, block: block) </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(<span class="hljs-number">_</span> node: Node&lt;Element&gt;?, block: <span class="hljs-params">(Element)</span></span></span>-&gt;<span class="hljs-type">Void</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> _node = node <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    inorderTraversal(_node.<span class="hljs-keyword">left</span>, block: block)</span><br><span class="line">    block(_node.element)</span><br><span class="line">    inorderTraversal(_node.<span class="hljs-keyword">right</span>,block: block)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(<span class="hljs-number">_</span> block: <span class="hljs-params">(Element)</span></span></span>-&gt;<span class="hljs-type">Void</span>) &#123;</span><br><span class="line">    postorderTraversal(root, block: block)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(<span class="hljs-number">_</span> node: Node&lt;Element&gt;?, block: <span class="hljs-params">(Element)</span></span></span>-&gt;<span class="hljs-type">Void</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> _node = node <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    postorderTraversal(_node.<span class="hljs-keyword">left</span>, block: block)</span><br><span class="line">    postorderTraversal(_node.<span class="hljs-keyword">right</span>,block: block)</span><br><span class="line">    block(_node.element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现思路：</p><p>使用递归实现。如何看一个算法是否能用递归实现，我觉得主要就是是否能写出一个通用的递归公式。比如最简单的例子：你在电影院里黑咕隆咚只有前后有人，你不知道你坐的第几排，你只需要问一下你前排的人他是第n排，然后你就是n+1排。如果你前面的人也不知道，那前面的人就问下他前面的人。。这样依次类推，总结出一个公式：排数=前一排+1。</p><h4 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h4><p>以上是实用<code>递归</code>实现<code>前中后序遍历</code>，下面是实用迭代实现</p><p>迭代实现其实就是模拟递归的过程，我感觉挺麻烦的，太绕了。思路都是从leetcode抄过来的。前序遍历比较简单，能自己想出来，中序稍微难一点，后序再更难一点。代码如下：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/// 前序遍历 迭代实现</span></span><br><span class="line"><span class="hljs-comment">/// - Parameter block: block description</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal2</span><span class="hljs-params">(<span class="hljs-number">_</span> block:<span class="hljs-params">(Element)</span></span></span>-&gt;<span class="hljs-type">Void</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> _root = root <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">var</span> stack = [<span class="hljs-type">Node</span>&lt;<span class="hljs-type">Element</span>&gt;]()</span><br><span class="line">    stack.append(_root)</span><br><span class="line">    <span class="hljs-keyword">while</span> !stack.isEmpty &#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> node = stack.removeLast()</span><br><span class="line">        block(node.element)</span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">right</span> = node.<span class="hljs-keyword">right</span> &#123;</span><br><span class="line">            stack.append(<span class="hljs-keyword">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">left</span> = node.<span class="hljs-keyword">left</span> &#123;</span><br><span class="line">            stack.append(<span class="hljs-keyword">left</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/// 中序遍历 迭代实现</span></span><br><span class="line"><span class="hljs-comment">/// - Parameter block: block description</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal2</span><span class="hljs-params">(<span class="hljs-number">_</span> block: <span class="hljs-params">(Element)</span></span></span>-&gt;<span class="hljs-type">Void</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> stack = [<span class="hljs-type">Node</span>&lt;<span class="hljs-type">Element</span>&gt;]()</span><br><span class="line">    <span class="hljs-keyword">var</span> node = root</span><br><span class="line">    <span class="hljs-keyword">while</span> node != <span class="hljs-literal">nil</span> || !stack.isEmpty &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">            stack.append(node!)</span><br><span class="line">            node = node?.<span class="hljs-keyword">left</span></span><br><span class="line">        &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            node = stack.removeLast()</span><br><span class="line">            block(node!.element)</span><br><span class="line">            node = node?.<span class="hljs-keyword">right</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/// 后序遍历 迭代实现</span></span><br><span class="line"><span class="hljs-comment">/// - Parameter block: block description</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postorderTraversal2</span><span class="hljs-params">(<span class="hljs-number">_</span> block: <span class="hljs-params">(Element)</span></span></span>-&gt;<span class="hljs-type">Void</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> _root = root <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">var</span> stack = [<span class="hljs-type">Node</span>&lt;<span class="hljs-type">Element</span>&gt;]()</span><br><span class="line">    stack.append(_root)</span><br><span class="line">    <span class="hljs-keyword">var</span> lastNode: <span class="hljs-type">Node</span>&lt;<span class="hljs-type">Element</span>&gt;?</span><br><span class="line">    <span class="hljs-keyword">while</span> !stack.isEmpty &#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> node = stack.last</span><br><span class="line">        <span class="hljs-keyword">if</span> (node!.<span class="hljs-keyword">left</span> == <span class="hljs-literal">nil</span> &amp;&amp; node?.<span class="hljs-keyword">right</span> == <span class="hljs-literal">nil</span>) || node!.<span class="hljs-keyword">left</span> == lastNode || node!.<span class="hljs-keyword">right</span> == lastNode &#123;</span><br><span class="line">            lastNode = node</span><br><span class="line">            block(stack.removeLast().element)</span><br><span class="line">        &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">right</span> = node?.<span class="hljs-keyword">right</span> &#123;</span><br><span class="line">                stack.append(<span class="hljs-keyword">right</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">left</span> = node?.<span class="hljs-keyword">left</span> &#123;</span><br><span class="line">                stack.append(<span class="hljs-keyword">left</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历（广-宽度优先遍历）"><a href="#层序遍历（广-宽度优先遍历）" class="headerlink" title="层序遍历（广/宽度优先遍历）"></a>层序遍历（广/宽度优先遍历）</h3><p>从第一层开始一层层遍历，最好理解。</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelTraversal</span><span class="hljs-params">(<span class="hljs-number">_</span> block: <span class="hljs-params">(Element)</span></span></span>-&gt;<span class="hljs-type">Void</span>) &#123;</span><br><span class="line">  <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> root = root <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">var</span> queue = [<span class="hljs-type">Node</span>&lt;<span class="hljs-type">Element</span>&gt;]()</span><br><span class="line">  queue.append(root)</span><br><span class="line">  <span class="hljs-keyword">while</span> !queue.isEmpty &#123;</span><br><span class="line">      <span class="hljs-keyword">let</span> node = queue.removeFirst()</span><br><span class="line">      block(node.element)</span><br><span class="line">      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">left</span> = node.<span class="hljs-keyword">left</span> &#123;</span><br><span class="line">          queue.append(<span class="hljs-keyword">left</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">right</span> = node.<span class="hljs-keyword">right</span> &#123;</span><br><span class="line">          queue.append(<span class="hljs-keyword">right</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现思路：使用队列</p><p>先将根节点root入队， 【从队列中取出第一个元素节点出队并访问，然后将这个节点的左右子树依次入队】，重复执行【】中的操作，直到队列为空。</p><h2 id="二叉树的前驱和后继节点"><a href="#二叉树的前驱和后继节点" class="headerlink" title="二叉树的前驱和后继节点"></a>二叉树的前驱和后继节点</h2><p>在二叉树中，求某个节点的<code>前驱节点</code>，就是<code>中序遍历</code>时该节点的前一个节点。同理，·就是<code>中序遍历</code>时，该节点的后一个节点。</p><p>在二叉搜索树中，某节点的<code>前驱节点</code>就是比该节点小的节点中最大的那一个。某节点的<code>后继节点</code>就是比该节点大的所有节点中最小的那一个。</p><blockquote><p>遍历 和 前驱后继并不是二叉搜索树才有的，这些都是基于二叉树。但是查找、添加和删除是二叉树没有的（因为二叉树中的节点不能保证可以比较大小，只有二叉搜索树中的节点一定能够比较大小）。</p></blockquote><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/// 前驱节点</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">predecessor</span><span class="hljs-params">(node: Node&lt;Element&gt;)</span></span> -&gt; <span class="hljs-type">Node</span>&lt;<span class="hljs-type">Element</span>&gt;?&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> node.<span class="hljs-keyword">left</span> != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> predecessor = node.<span class="hljs-keyword">left</span></span><br><span class="line">        <span class="hljs-keyword">while</span> predecessor?.<span class="hljs-keyword">right</span> != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">            predecessor = predecessor?.<span class="hljs-keyword">right</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> predecessor</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> targetNode = node</span><br><span class="line">    <span class="hljs-keyword">while</span> targetNode.parent != <span class="hljs-literal">nil</span> &amp;&amp; targetNode.parent!.<span class="hljs-keyword">left</span> != <span class="hljs-literal">nil</span> &amp;&amp; targetNode.parent!.<span class="hljs-keyword">left</span>! == targetNode &#123;</span><br><span class="line">        targetNode = targetNode.parent!</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> targetNode.parent</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/// 后继节点</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">successor</span><span class="hljs-params">(node: Node&lt;Element&gt;)</span></span> -&gt; <span class="hljs-type">Node</span>&lt;<span class="hljs-type">Element</span>&gt;? &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> node.<span class="hljs-keyword">right</span> != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> successor = node.<span class="hljs-keyword">right</span></span><br><span class="line">            <span class="hljs-keyword">while</span> successor?.<span class="hljs-keyword">left</span> != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">                successor = successor?.<span class="hljs-keyword">left</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">return</span> successor</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> targetNode = node</span><br><span class="line">    <span class="hljs-keyword">while</span> targetNode.parent != <span class="hljs-literal">nil</span> &amp;&amp; targetNode.parent!.<span class="hljs-keyword">right</span> != <span class="hljs-literal">nil</span> &amp;&amp; targetNode.parent!.<span class="hljs-keyword">right</span>! == targetNode &#123;</span><br><span class="line">        targetNode = targetNode.parent!</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> targetNode.parent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前驱节点实现思路：</p><ul><li>如果有左子树，很简单，前驱节点就是node.left.right.right…</li><li>如果没有左子树，前驱节点为 node.parent.parent…直到node.parent…是在右节点</li></ul><p><strong>如果没有左子树会感觉有点绕，其实反过来想会比较简答。如果没有左子树的话。就相当于是 已知某一节点的后继节点，求该节点。就相当于是把求有右子树的节点的后继节点反过来。</strong></p><p>后继节点实现思路和前驱节点正好相反</p><h2 id="二叉搜索树的查找、添加和删除"><a href="#二叉搜索树的查找、添加和删除" class="headerlink" title="二叉搜索树的查找、添加和删除"></a>二叉搜索树的查找、添加和删除</h2><p>对于普通<code>二叉树</code>来说，是不能<code>添加</code>和<code>删除</code>的。因为普通<code>二叉树</code>的<code>节点</code>之间并不一定能比较大小，不能比较大小的话，你也不知道添加一个节点应该添加在哪里。所以引出了<code>二叉搜索树</code>，<code>二叉搜索</code>中的节点的值是可以比较大小的。</p><h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">node</span><span class="hljs-params">(withElement element: Element)</span></span> -&gt; <span class="hljs-type">Node</span>&lt;<span class="hljs-type">Element</span>&gt;?&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> node = root</span><br><span class="line">    <span class="hljs-keyword">while</span> node != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> result = compare(element, node!.element)</span><br><span class="line">        <span class="hljs-keyword">switch</span> result &#123;</span><br><span class="line">        <span class="hljs-keyword">case</span> .orderedAscending:</span><br><span class="line">            node = node!.<span class="hljs-keyword">left</span></span><br><span class="line">        <span class="hljs-keyword">case</span> .orderedDescending:</span><br><span class="line">            node = node!.<span class="hljs-keyword">right</span></span><br><span class="line">        <span class="hljs-keyword">case</span> .orderedSame:</span><br><span class="line">            <span class="hljs-keyword">return</span> node</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现思路：</strong></p><p>查找很简单，就是从<code>根节点</code>开始往下比较大小。</p><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-number">_</span> element: Element)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        root = <span class="hljs-type">Node</span>(element: element, parent: <span class="hljs-literal">nil</span>)</span><br><span class="line">        size += <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> parentNode = root</span><br><span class="line">    <span class="hljs-keyword">var</span> targetNode = root</span><br><span class="line">    <span class="hljs-keyword">var</span> compareResult: <span class="hljs-type">ComparisonResult</span> = .orderedSame</span><br><span class="line">    <span class="hljs-keyword">while</span> parentNode != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        targetNode = parentNode</span><br><span class="line">        compareResult = compare(element,parentNode!.element)</span><br><span class="line">        <span class="hljs-keyword">switch</span> compareResult &#123;</span><br><span class="line">        <span class="hljs-keyword">case</span> .orderedAscending:</span><br><span class="line">            parentNode = parentNode!.<span class="hljs-keyword">left</span></span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-keyword">case</span> .orderedDescending:</span><br><span class="line">            parentNode = parentNode!.<span class="hljs-keyword">right</span></span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-keyword">case</span> .orderedSame:</span><br><span class="line">            parentNode = <span class="hljs-literal">nil</span></span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">switch</span> compareResult &#123;</span><br><span class="line">    <span class="hljs-keyword">case</span> .orderedAscending:</span><br><span class="line">        <span class="hljs-keyword">let</span> node = <span class="hljs-type">Node</span>(element: element, parent: targetNode)</span><br><span class="line">        targetNode?.<span class="hljs-keyword">left</span> = node</span><br><span class="line">        size += <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">case</span> .orderedDescending:</span><br><span class="line">        <span class="hljs-keyword">let</span> node = <span class="hljs-type">Node</span>(element: element, parent: targetNode)</span><br><span class="line">        targetNode?.<span class="hljs-keyword">right</span> = <span class="hljs-type">Node</span>(element: element, parent: targetNode)</span><br><span class="line">        size += <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">case</span> .orderedSame:</span><br><span class="line">        targetNode?.element = element</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先一定要明白：<strong>二叉搜索树添加节点，这个节点不可能插入到二叉树中间的，该节点添加之后必然会是叶子节点，也就是度为0的节点。</strong></p><p><strong>实现思路：</strong></p><p>添加要比删除简单很多，思路和查找其实差不多。假设要添加的节点为N，只需要从根节点开始，一路往下比大小，找到N的父节点P即可，如果N比P小，设置N为P的左子节点。如果N比P大设置N为P的右子节点即可。<strong>总结一句话：找到合适的父节点然后添加即可</strong></p><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-number">_</span> element: Element)</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">var</span> node = node(withElement: element) <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 如果删除节点度为2，那么最后还是相当于删除度为1或者0的节点。</span></span><br><span class="line">    <span class="hljs-comment">// 所以先判断这个</span></span><br><span class="line">    <span class="hljs-keyword">if</span> node.hasTowChildren &#123;</span><br><span class="line">        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> predecessor = <span class="hljs-keyword">self</span>.predecessor(node: node) <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        node.element = predecessor.element</span><br><span class="line">        node = predecessor</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//走到这里，说明 node度要么是0 要么是1</span></span><br><span class="line">    <span class="hljs-keyword">let</span> replacement = node.<span class="hljs-keyword">left</span> ?? node.<span class="hljs-keyword">right</span></span><br><span class="line">    <span class="hljs-keyword">if</span> replacement != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//node度为1</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> parent = node.parent &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> parent.<span class="hljs-keyword">left</span> == node &#123;</span><br><span class="line">                parent.<span class="hljs-keyword">left</span> = replacement</span><br><span class="line">            &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                parent.<span class="hljs-keyword">right</span> = replacement</span><br><span class="line">            &#125;</span><br><span class="line">            replacement?.parent = parent</span><br><span class="line">        &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            root = replacement</span><br><span class="line">            replacement?.parent = <span class="hljs-literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//度为0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> node == node.parent?.<span class="hljs-keyword">left</span> &#123;</span><br><span class="line">            node.parent?.<span class="hljs-keyword">left</span> = <span class="hljs-literal">nil</span></span><br><span class="line">        &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            node.parent?.<span class="hljs-keyword">right</span> = <span class="hljs-literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> node == root &#123;</span><br><span class="line">            root = <span class="hljs-literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size -= <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现思路：</strong></p><p>删除节点一共就三种情况：删除的节点度为0、1、2这三种情况</p><ol><li><p><strong>删除的节点度为0</strong> ，即叶子节点。</p><p>直接删除即可。</p></li><li><p><strong>删除的节点度为1</strong>，代表其有一个子节点。</p><p>直接删除该节点，然后把该节点的唯一一个叶子节点放在删除的这个节点的位置上即可。</p><p>也就是说用要删除的子节点覆盖自己即可。</p></li><li><p><strong>删除的节点度为2</strong>。</p><p>首先需要找到要删除的节点的后继节点。(这里提到要找到后继节点，并不是唯一办法， 找前序节点也可以。看你想要哪个节点。只要确保是前序或者后继都可以。为什么？自己想一下就明白了)</p><p>用后继节点的内容复制到要删除的节点上。之后删除这个后继节点即可。</p><p><strong>所以这里的删除，就转变为了删除后继节点。后继节点的度要么是0要么是1.所以就转变成了 删除的节点度为0 或者度为1。根据情况 走上面的1或2步骤即可。</strong></p></li></ol><blockquote><p>最后实际删除的节点 度数不可能为2，只能是0或1</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，一棵二叉搜索树的所需要的基本操作都已经实现。主要包括：</p><ul><li>二叉树<ul><li>遍历<ul><li>前中后序遍历（递归/迭代）</li><li>层序遍历（迭代）</li></ul></li><li>前驱、后继节点</li></ul></li><li>二叉搜索树 (extends: 二叉树)<ul><li>查找</li><li>添加</li><li>删除</li></ul></li></ul><p>详细代码参考：<a href="https://github.com/wqhiOS/BinaryTree" target="_blank" rel="noopener">https://github.com/wqhiOS/BinaryTree</a> </p><blockquote><font color="orange">这篇文章只是自己对二叉搜索树的总结，以便日后复习巩固。并不完全具备学习价值。如果要从零学习二叉树相关内容建议还是拿算法书系统看一看。</font></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于Swift实现了二叉搜索树，以及支持在console(控制台)中以如下形式输出二叉树：&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.wuqihan.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://www.wuqihan.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="二叉搜索树" scheme="http://www.wuqihan.cn/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>在CentOS7上搭建Shadowsocks</title>
    <link href="http://www.wuqihan.cn/2019/08/14/%E5%9C%A8CentOS7%E4%B8%8A%E6%90%AD%E5%BB%BAShadowsocks/"/>
    <id>http://www.wuqihan.cn/2019/08/14/在CentOS7上搭建Shadowsocks/</id>
    <published>2019-08-14T12:52:16.000Z</published>
    <updated>2019-08-14T13:10:46.312Z</updated>
    
    <content type="html"><![CDATA[<p>前提：购买一台国外主机，我是在搬瓦工上买的</p><h3 id="首先使用SSH登录"><a href="#首先使用SSH登录" class="headerlink" title="首先使用SSH登录"></a>首先使用SSH登录</h3><p>在CENTOS7上搭建Shadowsocks在CENTOS7上搭建Shadowsocks</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 端口号 username@ip</span><br></pre></td></tr></table></figure><p>例如 我的端口号是23456， username是root ，ip地址是123.232.123.123</p><p>“ssh -p 23456 root@123.232.123.123”</p><a id="more"></a><p>登录成功如下：</p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/ss_8.png" alt="image-20190802161122759"></p><h3 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h3><p>登录之后</p><p>输入 <code>https://bootstrap.pypa.io/get-pip.py -o get-pip.py</code> 加回车</p><p>输入<code>python get-pip.py</code>加回车</p><p>效果如下</p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/ss_7.png" alt="image-20190802161907805"></p><h3 id="安装Shadowsocks"><a href="#安装Shadowsocks" class="headerlink" title="安装Shadowsocks"></a>安装Shadowsocks</h3><p>输入<code>pip install shadowsocks</code>后回车，如下：</p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/ss_6.png" alt="image-20190802162014711"></p><h3 id="配置Shadowsocks"><a href="#配置Shadowsocks" class="headerlink" title="配置Shadowsocks"></a>配置Shadowsocks</h3><p>输入编辑文件命令<code>vi /etc/shadowsocks.json</code>并回车</p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/ss_5.png" alt="image-20190802162108989"></p><p>输入下面内容</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;server_port&quot;:9057,</span><br><span class="line">    &quot;local_port&quot;:10080,</span><br><span class="line">    &quot;password&quot;:&quot;1234567890&quot;,</span><br><span class="line">    &quot;timeout&quot;:600,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/ss_4.png" alt="image-20190802162527185"></p><p>9057 是端口 1234567890 是密码</p><h3 id="将Shadowsocks加入系统服务"><a href="#将Shadowsocks加入系统服务" class="headerlink" title="将Shadowsocks加入系统服务"></a>将Shadowsocks加入系统服务</h3><p>输入编辑文件命令<code>vi /etc/systemd/system/shadowsocks.service</code>并回车</p><p>粘贴下面内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks</span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/ss_2.png" alt="image-20190802162745539"></p><h3 id="启动Shadowsocks服务，并设置开机自动启动"><a href="#启动Shadowsocks服务，并设置开机自动启动" class="headerlink" title="启动Shadowsocks服务，并设置开机自动启动"></a>启动Shadowsocks服务，并设置开机自动启动</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 设置开机自启命令</span><br><span class="line">systemctl enable shadowsocks</span><br><span class="line"></span><br><span class="line"># 启动命令</span><br><span class="line">systemctl start shadowsocks</span><br><span class="line"></span><br><span class="line">#查看状态命令</span><br><span class="line">systemctl status shadowsocks</span><br></pre></td></tr></table></figure><p>依次执行上面三条命令如下：</p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/ss_1.png" alt="image-20190802163000085"></p><p>active 显示running 就成功了</p><p>Mac shadowsocks 软件下载地址： <a href="https://github.com/shadowsocks/ShadowsocksX-NG" target="_blank" rel="noopener">https://github.com/shadowsocks/ShadowsocksX-NG</a></p><p>iOS shadowsocks 要去国外appStore 下载 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前提：购买一台国外主机，我是在搬瓦工上买的&lt;/p&gt;
&lt;h3 id=&quot;首先使用SSH登录&quot;&gt;&lt;a href=&quot;#首先使用SSH登录&quot; class=&quot;headerlink&quot; title=&quot;首先使用SSH登录&quot;&gt;&lt;/a&gt;首先使用SSH登录&lt;/h3&gt;&lt;p&gt;在CENTOS7上搭建Shadowsocks在CENTOS7上搭建Shadowsocks&lt;/p&gt;
&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh -p 端口号 username@ip&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例如 我的端口号是23456， username是root ，ip地址是123.232.123.123&lt;/p&gt;
&lt;p&gt;“ssh -p 23456 root@123.232.123.123”&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://www.wuqihan.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Shadowsocks" scheme="http://www.wuqihan.cn/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>iOS图层性能优化</title>
    <link href="http://www.wuqihan.cn/2019/03/09/iOS%E5%9B%BE%E5%B1%82%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://www.wuqihan.cn/2019/03/09/iOS图层性能优化/</id>
    <published>2019-03-09T11:46:43.000Z</published>
    <updated>2019-11-09T13:21:14.858Z</updated>
    
    <content type="html"><![CDATA[<p>性能优化是一个很广的话题，性能优化包括方方面面，比如代码的执行效率、大文件的读取和写入、网络缓存、流量的使用、动画流畅度、程序的启动时间、应用程序包的大小等等。</p><p>这里只介绍关于图层方面的性能优化。</p><h2 id="了解Core-Animation"><a href="#了解Core-Animation" class="headerlink" title="了解Core Animation"></a>了解Core Animation</h2><p>说起图层，你必须能想到的是<code>Core Animation</code>。在iOS上，几乎所有的东西都是通过<code>Core Animation</code>绘制出来的。Core Animation 的核心是 OpenGL ES 的一个抽象物，简而言之，它让你直接使用 OpenGL ES 的功能，却不需要处理 OpenGL ES 做的复杂的事情。</p><a id="more"></a><p>不要被<code>Core Animation</code>的名字所误解，对于<code>Core Animation</code>，它实际是从<strong>Layer Kit</strong>演变而来的。所以做动画，仅仅只是<code>Core Animation</code>的冰山一角。</p><p><code>Core Animation</code>是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的图层，存储在一个叫做图层树的体系之中。<strong>于是这个树形成了UIKit以及在iOS应用程序当中你所能在屏幕上看见的一切的基础</strong>。</p><p>首先看一下<code>Core Animation</code>在cocoa中的位置的关系:</p><p><img src="https://i.loli.net/2019/11/08/McRstapoSu2YA8K.png" alt="image-20191028112837723.png"></p><p>Core Animation 通过 Core Graphics 的一端和 OpenGL ES 的另一端，精心策划基于 CPU 的位图绘制。因为 Core Animation 处在渲染过程中的重要位置上，所以你如何使用 Core Animation 将会对性能产生极大的影响。</p><h3 id="CoreAnimation是如何工作的呢？"><a href="#CoreAnimation是如何工作的呢？" class="headerlink" title="CoreAnimation是如何工作的呢？"></a>CoreAnimation是如何工作的呢？</h3><ol><li>布局</li><li>显示</li><li>准备</li><li>提交</li><li>对所有的图层属性计算中间值，设置Open-GL几何形状（纹理话的三角形）来执行渲染</li><li>在屏幕上渲染可见三角形</li></ol><p>1-5是由CPU来负责的，只有第6步是由GPU负责。</p><p>通过下面的两张图，可以更好理解：</p><p><img src="http://images.bestswifter.com/UIKitPerformance/pipeline.png" alt="显示流程" style="zoom: 33%;"></p><p><img src="http://images.bestswifter.com/UIKitPerformance/commit.png" alt="解码与转换" style="zoom: 50%;"></p><h2 id="CPU-VS-GPU"><a href="#CPU-VS-GPU" class="headerlink" title="CPU VS GPU"></a>CPU VS GPU</h2><p>关于图层绘制和动画有两种处理方式：<code>CPU</code>（中央处理器）和<code>GPU</code>（图形处理器）。我们可以说<code>CPU</code>所做的工作都是在软件层面，而<code>GPU</code>做的工作是硬件层面。我们可以用<code>CPU</code>做任何事情，但是对于图像处理(<code>CPU</code>也可以做，但是效率低)，通常用硬件会更快，因为<code>GPU</code>使用图像对高度并行浮点运算做了优化。</p><p><code>GPU</code> 是一个专门为图形高并发计算而量身定做的处理单元。它并发的本性让它能高效的将不同纹理合成起来。它连接到 <code>CPU</code>。从硬件上讲两者之间存在某种类型的总线，并且有像 <code>OpenGL</code>，<code>Core Animation</code> 和 <code>Core Graphics</code> 这样的框架来在 <code>GPU</code> 和 <code>CPU</code> 之间精心安排数据的传输。为了将像素显示到屏幕上，一些处理将在 <code>CPU</code> 上进行。然后数据将会传送到 <code>GPU</code>，这也需要做一些相应的操作，最终像素显示到屏幕上。</p><p><strong>针对图层的性能优化，说白了就是关于如何智能利用GPU和CPU，使他们均衡的被使用，不超出负荷。</strong></p><p>可以大体粗略的说，图层绘制到屏幕之前或者做动画之前的大多数工作都是由<code>CPU</code>处理的，而<code>GPU</code>是用来采集图片和形状(三角形)，运行变换，应用纹理和混合然后把它们输送才屏幕上。</p><h3 id="GPU的相关操作"><a href="#GPU的相关操作" class="headerlink" title="GPU的相关操作"></a>GPU的相关操作</h3><p>基于GPU的哪些常见操作会降低图层绘制：</p><ul><li>太多的几何结构</li><li>重绘（合成compositing）：主要由重叠半透明图层引起</li><li>离屏渲染 （Off-Screen Rendering）：离屏渲染指的是GPU在当前屏幕缓冲区以外开辟一个新的缓冲区进行渲染。包括设置图层的圆角、图层遮罩(mask)、阴影、光栅化(shouldRasterize )等都会造成离屏渲染。另外补充在屏渲染的概念：指的是GPU的渲染操作在当前用于显示的屏幕缓冲区进行。</li><li>过大的图片：如果视图绘制超出GPU支持的尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能。目前的苹果设备最大支持4096x4096尺寸的纹理。如果图片的大小超过4096x4096是无法显示的。必须要用CPU对图片进行预处理。</li><li>等等</li></ul><h3 id="CPU的相关操作"><a href="#CPU的相关操作" class="headerlink" title="CPU的相关操作"></a>CPU的相关操作</h3><p>上文已经提到，大多数工作在Core Animation的CPU都发生在动画开始之前。这意味着它不会影响到帧率，但是他会延迟动画开始的时间，让你的界面看起来会比较迟钝。</p><p>基于CPU的哪些常见操作会延迟图层绘制的开始时间：</p><ul><li>布局计算：因为需要大量的计算，自动布局机制在低版本的iOS系统下尤为明显。</li><li>视图懒加载：视图懒加载对内存的使用是很友好的，但是也会有不好的方面，比如你在视图控制器的ViewDidLoad中写入了大量耗时的操作，那等该视图控制器的view被使用时，就会消耗一定的时间。</li><li>Core Graphics绘制：如果对视图实现了<code>-drawRect:</code>方法或<code>CALayerDelegate</code>的<code>-drawLayer:inContext:</code>方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，<code>Core Animation</code>必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。所以这也就是为什么很多地方都会提到，尽量避免重写<code>-drawRect:</code>方法的原因。</li><li>解压图片：为了节省内存，iOS通常直到真正绘制的时候才会去解码图片，所以第一次加载图片时都要解压，那对于过大的图片，都会占用一定的时间。</li><li>等等</li></ul><h2 id="屏幕图像显示原理"><a href="#屏幕图像显示原理" class="headerlink" title="屏幕图像显示原理"></a>屏幕图像显示原理</h2><p>这篇文章： <a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS保持界面流畅的技巧</a> 非常详细得介绍了屏幕图像显示原理，具体内容参考这篇文章，我这里用一张图总结一下。</p><p><img src="https://i.loli.net/2019/11/08/1qIsENRlAJeVgP6.png" alt="屏幕图像显示原理.png" style="zoom: 67%;"></p><h2 id="Instruments工具使用"><a href="#Instruments工具使用" class="headerlink" title="Instruments工具使用"></a>Instruments工具使用</h2><blockquote><p> 由于苹果A系列芯片太过于强大，所以建议在测试性能的时候建议至少使用iPhone6以前的手机。我使用的是iPhone5s</p><p> 注意：本文中提到的一些需要性能优化的地方，不是说这样做是错误的，仅仅是因为如果大量的做了某一个操作，这个操作会占用CPU或者GPU，这些操作堆积在一起，可能在老机型的手机上，造成GPU或者CPU单方面的负荷，导致卡顿等问题。</p></blockquote><h3 id="CoreAnimation"><a href="#CoreAnimation" class="headerlink" title="CoreAnimation"></a>CoreAnimation</h3><p><img src="https://i.loli.net/2019/11/09/jrOS1RuPX9a27My.png" alt="CoreAnimation.png" style="zoom: 67%;"></p><p>使用CoreAnimation调试，目的是<strong>为了找到程序当前卡顿的原因是CPU超负荷还是GPU超负荷造成的</strong>。</p><p>这里我提供了一个<a href="https://github.com/wqhiOS/TableViewPerformanceOptimizationDemo" target="_blank" rel="noopener">demo</a>用来测试。有两个列表页面，一个是未优化的一个是已优化的，先使用Instruments Core Animation对未优化的列表进行调试，看看问题究竟出在CPU还是GPU。进入未优化的页面如下图，来回滑动列表，肉眼可见的卡顿。</p><p><img src="https://i.loli.net/2019/11/09/gt2OA13TQyLGMwC.jpg" alt="tableView.jpg" style="zoom:50%;"></p><p>那卡顿原因到底出在哪里，是CPU负荷还是GPU呢？</p><p><img src="https://i.loli.net/2019/11/09/qHRZDhWKiCxdQnT.png" alt="core_animation_1-2.png"></p><p>图中红色框全出的时间，这时候我在未优化的列表页面始终不停滑动列表。从图中监控的数据可以看出，FPS从未超过15，极其卡顿，GPU使用率几乎达到 百分之百。CPU表现正常。</p><p>所以可以得出结论。我们需要对GPU所做的操作进行优化，尽量把GPU所做的一部分工作分给CPU。具体怎么做，上面已经介绍过了。详细可以查看我的这个<a href="https://github.com/wqhiOS/TableViewPerformanceOptimizationDemo" target="_blank" rel="noopener">demo</a>。</p><p>我们在进入另一个展示同样列表，且已经性能优化的页面。来回滑动列表，你会发现非常流畅。那我们在使用CoreAnimation工具测试一下，结果如下图(非常稳定，最低59FPS，GPU使用率维持在30%左右，CPU表现正常)：</p><p><img src="https://i.loli.net/2019/11/09/DSAiCo4HBz2kaq3.png" alt="core_animation_2.png"></p><h3 id="View-Debugging-Rendering"><a href="#View-Debugging-Rendering" class="headerlink" title="View Debugging Rendering"></a>View Debugging Rendering</h3><p>将项目启动运行在真机上。新版Xcode入口在：<code>[Debug] -&gt; [View Debugging] -&gt; [Rendering] &gt;</code></p><h4 id="Color-Blended-Layers"><a href="#Color-Blended-Layers" class="headerlink" title="Color Blended Layers"></a>Color Blended Layers</h4><p>因为上文提到了，图层混合是GPU的工作，所以该优化是针对GPU超负荷的情况。如果你用Instruments-CoreAnimation调试，发现GPU使用率很低，几乎就可以放弃这项检测。</p><p>该选项用于检测哪里发生了图层混合，并用红色标记出来。因此我们需要尽可能减少看到的红色区域。</p><p>如果发现了有大量的红色，我们该如何处理呢？</p><ul><li>关于CALayer的opaque(不透明)属性：该属性可以告诉GPU是否去做合成，YES代表是不透明，GPU不会去做合成，但是对于普通的开发者来说，这个属性用处不大，因为基于UIView的CALayer，它默认的opaque属性就是YES，表示不透明。（虽然很多文章有提到这个属性，但是其实是可以忽略的）</li><li>针对项目中用到的图片素材，不仅它本身要是不透明的，并且图片也不要包含alpha通达(因为有一些图片，你看着它是不透明的，但是它包含有alpha通达，仍然后发生图层混合，影响应能）</li><li>关于UILabel中含有中文字体时，即使UILabel设置了不透明的背景颜色，可是还是会被标记为红色（因为苹果对显示中文做了不知道是好的还是坏的优化，显示中文是，UILabel会多出一个layer），针对这个的解决办法是：<strong>label.layer.masksToBounds = true;</strong> (我觉的这个影响微乎其微，可以忽略没有必要处理)</li></ul><h4 id="Color-Offscreen-Rendered-Yellow"><a href="#Color-Offscreen-Rendered-Yellow" class="headerlink" title="Color Offscreen-Rendered Yellow"></a>Color Offscreen-Rendered Yellow</h4><p>哪些常见操作会造成离屏渲染</p><ul><li><p>阴影 </p><ul><li><p>如何优化？</p><ul><li>使用shadowPath 。因为如果没有手动指定，Core Animation会去自动计算，这就会触发离屏渲染，所以可以手动指定阴影路径</li><li>如果想给文字添加阴影，最好使用富文本，NSShadow</li></ul></li></ul></li></ul><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.shadowPath = <span class="hljs-type">UIBezierPath</span>(rect: cell._imageView2.bounds).cgPath</span><br></pre></td></tr></table></figure><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> shadow = <span class="hljs-type">NSShadow</span>()</span><br><span class="line">shadow.shadowOffset = <span class="hljs-type">CGSize</span>(width: <span class="hljs-number">0</span>, height: <span class="hljs-number">2</span>)</span><br><span class="line">shadow.shadowBlurRadius = <span class="hljs-number">5</span></span><br><span class="line">shadow.shadowColor = <span class="hljs-type">UIColor</span>(white: <span class="hljs-number">0</span>, alpha: <span class="hljs-number">0.5</span>)</span><br><span class="line"><span class="hljs-keyword">let</span> attText = <span class="hljs-type">NSAttributedString</span>(string: text, attributes: [<span class="hljs-type">NSAttributedString</span>.<span class="hljs-type">Key</span>.shadow: shadow])</span><br></pre></td></tr></table></figure><ul><li><p>圆角</p><ul><li>设置<code>cornerRadius</code>本身并不会导致离屏渲染，但很多时候它还需要配合<code>layer.masksToBounds = true</code>使用。根据之前的总结，设置<code>masksToBounds</code>会导致离屏渲染</li><li><p>如何优化：</p><ul><li>光栅化 ，等于加了缓存(开启光栅化等于开启离屏渲染，双刃剑、可以解决，但是并不完美)</li><li><p>创建一个圆形CAShapeLayer，然后设置为mask(完全不推荐、自己尝试后觉得没有效果，mask也是离屏渲染)</p></li><li><p>使用UIGraphics把当前image画成圆形生成新的UIImage，重新赋值给UIImageView（原理：GPU做的事情，转给了CPU来做。）</p></li></ul></li></ul></li></ul><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UIImageView</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cornerRadiusOptimized</span><span class="hljs-params">(radius: CGFloat)</span></span> &#123;</span><br><span class="line">        <span class="hljs-keyword">self</span>.image = <span class="hljs-keyword">self</span>.image?.drawRectWithRoundedCorner(radius: radius, <span class="hljs-keyword">self</span>.bounds.size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UIImage</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">fileprivate</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">drawRectWithRoundedCorner</span><span class="hljs-params">(radius: CGFloat, <span class="hljs-number">_</span> sizetoFit: CGSize)</span></span> -&gt; <span class="hljs-type">UIImage</span>? &#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> rect = <span class="hljs-type">CGRect</span>(origin: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>), size: sizetoFit)</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-type">UIGraphicsBeginImageContextWithOptions</span>(rect.size, <span class="hljs-literal">false</span>, <span class="hljs-type">UIScreen</span>.main.scale)</span><br><span class="line">        <span class="hljs-keyword">let</span> context = <span class="hljs-type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">        context?.addPath(<span class="hljs-type">UIBezierPath</span>(roundedRect: rect, byRoundingCorners: <span class="hljs-type">UIRectCorner</span>.allCorners, cornerRadii: <span class="hljs-type">CGSize</span>(width: radius, height: radius)).cgPath)</span><br><span class="line">        context?.clip()</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">self</span>.draw(<span class="hljs-keyword">in</span>: rect)</span><br><span class="line">        context?.drawPath(using: .fillStroke)</span><br><span class="line">        <span class="hljs-keyword">let</span> output = <span class="hljs-type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="hljs-type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Color-Hits-Green-and-Misses-Red"><a href="#Color-Hits-Green-and-Misses-Red" class="headerlink" title="Color Hits Green and Misses Red"></a>Color Hits Green and Misses Red</h4><p>该选项用于检测图像缓存是否命中，表示如果命中缓存则显示为绿色，否则显示为红色，显然绿色越多越好，红色越少越好。</p><p>这里要提到一个概念：<code>光栅化</code></p><p><code>光栅化</code>是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。如果对于阴影效果这样比较消耗资源的静态内容进行缓存，可以得到一定幅度的性能提升</p><p>CALayer的属性shouldRasterize表示是否设置光栅化 yes代表是</p><p>虽然《iOS核心动画高级技巧》性能调优一节中有光栅化做了性能优化，但是我觉得这样的处理还是指标不治本。因为现在的问题是GPU使用率过高，更好的办法是把该部分工作转移个CPU执行。但是光栅化其实仅仅是加了一个缓存，缓存期限也仅仅只有100ms，即0.1s之后缓存就没有了，所以仅仅是对于快速滑动列表时会有一点作用。</p><p><strong>光栅化同样会造成离屏渲染</strong>。当把光栅化打开的时候，也就代表你手动开启了离屏渲染。</p><h4 id="Color-Misaligned-Images"><a href="#Color-Misaligned-Images" class="headerlink" title="Color Misaligned Images"></a>Color Misaligned Images</h4><p>该选项作用不大，其实就是找出哪些图片进行了缩放，因为缩放也是需要时间的。所以，我们在平时开发中，尽量保证图片素材的的大小与视图的frame保持一致。（这条基本可以忽略，除非你视图大小是40x40，结果你用了一张400x400，这种情况肯定是要避免。基本不会有人这样搞吧。。）</p><blockquote><p>参考资料</p><p><a href="https://github.com/qunten/iOS-Core-Animation-Advanced-Techniques" target="_blank" rel="noopener">《iOS Core Animation Advanced Techniques》</a></p><p><a href="https://github.com/100mango/zen/blob/master/WWDC心得：Advanced%20Graphics%20and%20Animations%20for%20iOS%20Apps/Advanced%20Graphics%20and%20Animations%20for%20iOS%20Apps.md" target="_blank" rel="noopener">WWDC心得：Advanced Graphics and Animations for iOS Apps</a></p><p><a href="https://objccn.io/issue-3-1/" target="_blank" rel="noopener">绘制像素到屏幕上</a></p><p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS保持界面流畅的技巧</a></p><p><a href="https://bestswifter.com/uikitxing-neng-diao-you-shi-zhan-jiang-jie/" target="_blank" rel="noopener">UIKit性能调优实战讲解</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;性能优化是一个很广的话题，性能优化包括方方面面，比如代码的执行效率、大文件的读取和写入、网络缓存、流量的使用、动画流畅度、程序的启动时间、应用程序包的大小等等。&lt;/p&gt;
&lt;p&gt;这里只介绍关于图层方面的性能优化。&lt;/p&gt;
&lt;h2 id=&quot;了解Core-Animation&quot;&gt;&lt;a href=&quot;#了解Core-Animation&quot; class=&quot;headerlink&quot; title=&quot;了解Core Animation&quot;&gt;&lt;/a&gt;了解Core Animation&lt;/h2&gt;&lt;p&gt;说起图层，你必须能想到的是&lt;code&gt;Core Animation&lt;/code&gt;。在iOS上，几乎所有的东西都是通过&lt;code&gt;Core Animation&lt;/code&gt;绘制出来的。Core Animation 的核心是 OpenGL ES 的一个抽象物，简而言之，它让你直接使用 OpenGL ES 的功能，却不需要处理 OpenGL ES 做的复杂的事情。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.wuqihan.cn/categories/iOS/"/>
    
      <category term="性能优化" scheme="http://www.wuqihan.cn/categories/iOS/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="http://www.wuqihan.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Tagged Pointer</title>
    <link href="http://www.wuqihan.cn/2018/11/06/Tagged-Pointer/"/>
    <id>http://www.wuqihan.cn/2018/11/06/Tagged-Pointer/</id>
    <published>2018-11-06T11:18:48.000Z</published>
    <updated>2019-11-06T11:39:51.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一道面试题"><a href="#一道面试题" class="headerlink" title="一道面试题"></a>一道面试题</h2><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *target;</span><br><span class="line"><span class="hljs-comment">//.... </span></span><br><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">"parallel"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span> ; i++) &#123;</span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="hljs-keyword">self</span>.target = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"ksddkjalkjd%d"</span>,i];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>结果会崩溃。原因setTarget是线程不安全的，可能会出现已经释放的内存再次释放，造成崩溃。解决办法很多，在这里不过多讨论。</p><p>如果把代码改成下面这样就不会发生崩溃了：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *target;</span><br><span class="line"><span class="hljs-comment">//.... </span></span><br><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">"parallel"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span> ; i++) &#123;</span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="hljs-keyword">self</span>.target = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"%d"</span>,i];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为苹果从64位程序开始，引入了<code>Tagged Pointer</code>概念，导致self.taget的值直接保存在了指针值中。</p><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>在苹果64位处理器上，堆内存对齐采用的是16字节对齐。所以任何指向堆内存的指针都是如下形式：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x---------------0/8</span><br></pre></td></tr></table></figure><p>最后一个十六进制数字<em>始终是</em> <code>0或者8</code>。</p><blockquote><p>我用真机测试最低位都是8 用模拟器测试最低位都是0 （具体原因不清楚。总之指向堆内存的指针最低位都是一样的，要么全是8要么全是0）</p></blockquote><p>使用16字节内存对齐，也就意味着，如果堆上需要存储的数据实际大小只有1字节，可它还是会多占用15个字节来达到内存对齐，这是不是很浪费？</p><p>那么比如NSNumber，如果数值仅仅为1，<code>NSNumber num = @1</code>。那如果不使用Tagged Pointer还是需要占用16个字节来保存1，以及一个8字节的指针指向16字节的堆内存。</p><h2 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h2><p>从64位程序开始（iPhone5s是配备了首个采用 64 位架构的 A7 双核处理器），苹果引入了<code>Tagged Pointer</code>的概念，为了节省内存和提升效率。</p><p>主要用于<strong>NSString</strong>、<strong>NSNumber</strong>、<strong>NSDate</strong>、<strong>NSIndexPath</strong>等存储小规模数据的对象。这些使用了<code>Tagged Pointer</code>优化的对象，他们的指针不再是指向堆内存的地址，而是直接将值保存在了指针中（<strong>苹果为了数据安全，对Tagged Pointer指针的值做了数据混淆</strong>）。</p><p>使用<code>Tagged Pointer</code>仅仅是针对存储的值比较小的时候，如果存储的值过大，8个字节的指针无法保存，还是会在堆中分配内存。</p><p>在objc源码中，用<code>_objc_isTaggedPointer</code>函数来判断是否为<code>Tagged Pointer</code>，源码如下：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> </span><br><span class="line">_objc_isTaggedPointer(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">uintptr_t</span>)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看 <code>_OBJC_TAG_MASK</code>的值</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__</span></span><br><span class="line">    <span class="hljs-comment">// 64-bit Mac - tag bit is LSB</span></span><br><span class="line"><span class="hljs-meta">#   <span class="hljs-meta-keyword">define</span> OBJC_MSB_TAGGED_POINTERS 0</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span></span><br><span class="line">    <span class="hljs-comment">// Everything else - tag bit is MSB</span></span><br><span class="line"><span class="hljs-meta">#   <span class="hljs-meta-keyword">define</span> OBJC_MSB_TAGGED_POINTERS 1</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> OBJC_MSB_TAGGED_POINTERS</span></span><br><span class="line"><span class="hljs-meta">#   <span class="hljs-meta-keyword">define</span> _OBJC_TAG_MASK (1UL&lt;&lt;63)</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span></span><br><span class="line"><span class="hljs-meta">#   <span class="hljs-meta-keyword">define</span> _OBJC_TAG_MASK 1UL</span></span><br><span class="line"><span class="hljs-comment">//在mac平台 _OBJC_TAG_MASK = 1UL</span></span><br><span class="line"><span class="hljs-comment">//其他平台 _OBJC_TAG_MASK = 1UL&lt;&lt;63 (1左移63位)</span></span><br></pre></td></tr></table></figure><p>在<strong>iOS</strong>平台上，系统通过指针的最高有效位是否为1(也就是第64位)，来判断是否为<code>Tagged Pointer</code>，在<strong>macOS</strong>平台上则是根据最低有效位。</p><p>这里我们来验证一下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *a = @&quot;a&quot;;</span><br><span class="line">NSObject *object = [[NSObject alloc] init];</span><br><span class="line">NSLog(@&quot;%@ %p\n%p&quot;,[a class],a,object);</span><br></pre></td></tr></table></figure><p>console输出为：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__NSCFConstantString <span class="hljs-number">0x10dc68020</span></span><br><span class="line"><span class="hljs-number">0x600002c38940</span></span><br></pre></td></tr></table></figure><p>通过上面的代码，发现这里的a不是TaggedPointer，a实际是指向了常量区。为什么这样说呢？因为我这里多添加了一个object变量，object指针肯定是指向堆中，但是a指针的值却比object指针值小了很多很多。所以，a不是在堆中，且栈的地址又是大于堆地址，所以排除堆和栈，那就是说这里的字符串”a”是保存在数据段常量区的。因为iOS内存分布结构，地址从小到大依次是：代码段、数据段、堆、栈。</p><p>那为什么这里的a不是<code>Tagged Pointer</code>呢。因为常量字符串本来就是在常量区啊。。。<code>Tagged Pointer</code>优化的是指向堆内存的指针。所以修改下代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">NSString</span> *a = [[<span class="hljs-string">@"a"</span> mutableCopy] <span class="hljs-keyword">copy</span>];</span><br><span class="line"><span class="hljs-built_in">NSObject</span> *object = [[<span class="hljs-built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@ %p"</span>,[a <span class="hljs-keyword">class</span>],a);</span><br></pre></td></tr></table></figure><blockquote><p>为什么不直接使用 <code>NSString *a = [@&quot;a&quot; copy];</code>?</p><p>因为苹果在这里做了优化，对一个常量区字符串copy，没有意义啊，所以直接返回了@”a”;</p><p>为什么要mutableCopy后再加copy？</p><p>因为mutableCopy后，变成了可变对象，可变对象不可能为Tagged Pointer，所以需要在copy一下变为不可变对象。</p><p>(我这里这样做，没有任何意义，仅仅是为了这次测试，开发中不会这样写代码)。</p></blockquote><p>console输出为：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSTaggedPointerString <span class="hljs-number">0xae2f7c76826f6e01</span></span><br><span class="line"><span class="hljs-number">0x60000104c170</span></span><br></pre></td></tr></table></figure><p>可以看大，a的类型变为了<code>NSTaggedPointerString</code>，a指针的值为<code>0xae2f7c76826f6e01</code>。</p><p>最高位是0xa 转换为2进制为 1010，二进制最高位为1，所以是<code>Tagged Pointer</code>。</p><h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><p>如果对Tagged Pointer有了了解，下面这个问题就很好解决了</p><p>假设有下面这段代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSObject</span> (<span class="hljs-title">AssociatedObject</span>) </span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">CGFloat</span> someProperty; </span><br><span class="line"><span class="hljs-keyword">@end</span> </span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NSObject</span> (<span class="hljs-title">AssociatedObject</span>) </span></span><br><span class="line"><span class="hljs-keyword">@dynamic</span> someProperty; </span><br><span class="line">- (<span class="hljs-keyword">void</span>)setSomeProperty:(<span class="hljs-built_in">CGFloat</span>)someProperty&#123; </span><br><span class="line"><span class="hljs-keyword">return</span> objc_setAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">@selector</span>(someProperty), @(someProperty), OBJC_ASSOCIATION_ASSIGN); </span><br><span class="line">&#125; </span><br><span class="line">- (<span class="hljs-built_in">CGFloat</span>)someProperty&#123; </span><br><span class="line"><span class="hljs-keyword">return</span> [objc_getAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">@selector</span>(someProperty)) floatValue]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//代码1</span></span><br><span class="line"><span class="hljs-keyword">self</span>.view.someProperty = <span class="hljs-number">100</span>;</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>, @(<span class="hljs-keyword">self</span>.view.someProperty));</span><br></pre></td></tr></table></figure><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//代码2</span></span><br><span class="line"><span class="hljs-keyword">self</span>.view.someProperty = <span class="hljs-number">999999999999999.1</span>;</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>, @(<span class="hljs-keyword">self</span>.view.someProperty));</span><br></pre></td></tr></table></figure><p>分别执行上面两段代码1 和 2。会发生什么问题嘛？</p><p>代码1不会崩溃，代码2会崩溃。因为@(100)没有malloc分配内存，但是数值过大会分配内存，所以需要使用retain。但是上面代码使用的assign。所以调用get方法时，会访问到坏内存。</p><p>上面这个问题引用自<a href="http://sketchk.xyz/2018/07/29/A-problem-caused-by-Tagged-Pointer/" target="_blank" rel="noopener">由Tagged Pointer联想到的一个问题</a>。具体更详细的解释参考这篇文章就行（我这里就是把这个问题记录下来，方便自己以后回顾，因为经常遇到收藏的文章，过一段时间再去访问文章就不见了。可能是作者服务器挂了或者文章被删除了==）。</p><blockquote><p>参考资料：</p><p><a href="https://swift.gg/2018/10/08/tagged-pointer-strings/" target="_blank" rel="noopener">Tagged Pointer字符串</a></p><p><a href="https://blog.devtang.com/2014/05/30/understand-tagged-pointer/" target="_blank" rel="noopener">深入理解Tagged Pointer</a></p><p><a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="noopener">Let’s Build Tagged Pointers</a></p><p><a href="[https://qiubaiying.github.io/2017/12/26/%E4%BB%8E%E4%B8%80%E9%81%93%E7%BD%91%E6%98%93%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B5%85%E8%B0%88-Tagged-Pointer/](https://qiubaiying.github.io/2017/12/26/从一道网易面试题浅谈-Tagged-Pointer/">从一道网易面试题浅谈Tagged Pointer</a>)</p><p><a href="https://www.jianshu.com/p/3176e30c040b" target="_blank" rel="noopener">聊聊伪指针Tagged Pointer</a></p><p><a href="http://sketchk.xyz/2018/07/29/A-problem-caused-by-Tagged-Pointer/" target="_blank" rel="noopener">由Tagged Pointer联想到的一个问题</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一道面试题&quot;&gt;&lt;a href=&quot;#一道面试题&quot; class=&quot;headerlink&quot; title=&quot;一道面试题&quot;&gt;&lt;/a&gt;一道面试题&lt;/h2&gt;&lt;figure class=&quot;highlight objc hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;strong&lt;/span&gt;) &lt;span class=&quot;hljs-built_in&quot;&gt;NSString&lt;/span&gt; *target;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//.... &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;dispatch_queue_t&lt;/span&gt; queue = dispatch_queue_create(&lt;span class=&quot;hljs-string&quot;&gt;&quot;parallel&quot;&lt;/span&gt;, DISPATCH_QUEUE_CONCURRENT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;1000000&lt;/span&gt; ; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;dispatch_async&lt;/span&gt;(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.target = [&lt;span class=&quot;hljs-built_in&quot;&gt;NSString&lt;/span&gt; stringWithFormat:&lt;span class=&quot;hljs-string&quot;&gt;@&quot;ksddkjalkjd%d&quot;&lt;/span&gt;,i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.wuqihan.cn/categories/iOS/"/>
    
      <category term="内存管理" scheme="http://www.wuqihan.cn/categories/iOS/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Tagged Pointer" scheme="http://www.wuqihan.cn/tags/Tagged-Pointer/"/>
    
      <category term="内存管理" scheme="http://www.wuqihan.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>详解Objective-C对象</title>
    <link href="http://www.wuqihan.cn/2018/08/03/%E8%AF%A6%E8%A7%A3Objective-C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.wuqihan.cn/2018/08/03/详解Objective-C对象/</id>
    <published>2018-08-02T16:46:45.000Z</published>
    <updated>2019-12-03T15:20:08.942Z</updated>
    
    <content type="html"><![CDATA[<p>两年前写过一篇文章：<a href="http://www.wuqihan.cn/2016/05/08/Objective-C%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/">Objective-C类对象</a>。当初对OC的理解还仅仅是刚入门，也没有遇到问题看源码的习惯，所以两年后，重新对Objective-C对象做一个总结。</p><a id="more"></a><h2 id="objc-class与objc-object"><a href="#objc-class与objc-object" class="headerlink" title="objc_class与objc_object"></a>objc_class与objc_object</h2><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Class类：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_class</span> *<span class="hljs-title">Class</span>;</span></span><br></pre></td></tr></table></figure><p>id:</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_object</span> *<span class="hljs-title">id</span>;</span></span><br></pre></td></tr></table></figure><p>objc_class:</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="hljs-comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="hljs-keyword">cache_t</span> cache;             <span class="hljs-comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="hljs-keyword">class_data_bits_t</span> bits;    <span class="hljs-comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//....... 省略</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>objc_object:</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">truct objc_object &#123;</span><br><span class="line"><span class="hljs-keyword">private</span>:</span><br><span class="line">    <span class="hljs-keyword">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    <span class="hljs-function">Class <span class="hljs-title">ISA</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    <span class="hljs-function">Class <span class="hljs-title">getIsa</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//....... 省略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过以上代码可以得出结论：</p><p>Objective-C的面向对象都是基于C\C++的数据结构实现的。</p><p>NSObject对象本质上是C结构体，其只有一个变量<code>isa</code>，<code>isa</code>类型是<code>Class</code>(这样说并不算严谨，其实现在isa是一个联合体类型，下文会讲到)，<code>Class</code>是指向结构体<code>objc_class</code>的指针。</p><p><code>objc_class</code>又继承自<code>objc_object</code>。所以类也是结构体对象，我们平时称之为类对象。</p><h2 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h2><p>自定义一个Person类：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">NSString</span> *_name;</span><br><span class="line">    <span class="hljs-built_in">NSInteger</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o person</span><br></pre></td></tr></table></figure><p>使用上面的命令将上述文件编译为c++，可以看到Person类的实质为：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NSObject_IMPL</span> &#123;</span></span><br><span class="line">Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person_IMPL</span> &#123;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NSObject_IMPL</span> <span class="hljs-title">NSObject_IVARS</span>;</span></span><br><span class="line">NSString *_name;</span><br><span class="line">NSInteger _age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以整理为：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">struct</span> Person_IMPL &#123;</span><br><span class="line">Class isa;</span><br><span class="line"><span class="hljs-built_in">NSString</span> *_name;</span><br><span class="line"><span class="hljs-built_in">NSInteger</span> _age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：因为NSObject中，isa是第一个成员变量，所以isa的地址，也就是这个结构体在内存中的地址。</p><h2 id="一个NSObject占用多少内存"><a href="#一个NSObject占用多少内存" class="headerlink" title="一个NSObject占用多少内存"></a>一个NSObject占用多少内存</h2><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">NSObject</span> *object = [[<span class="hljs-built_in">NSObject</span> alloc] init]</span><br></pre></td></tr></table></figure><p>一个object使用了8个字节的空间，因为里面有一个指针，一个指针是8个字节，所以使用了8个字节。通过<code>class_getInstanceSize</code> 获取是8。</p><p>（为什么指针是8个字节。CPU64位，地址总线就是64位，64位= 8b）</p><p>但是在64位系统下。一个object系统会分配16个字节，因为iOS堆空间内存分配都是16字节的倍数。可以通过 <code>malloc_size</code> 函数查询为16。</p><ul><li><code>class_getInstanceSize</code>对象至少需要占多少内存(涉及内存对齐，一般是结构体的大小必须是最大成员大小的倍数。内存对齐规则很多，暂时不需要特别详细的理解。知道有内存对齐就行了。)</li><li><code>malloc_size</code> 系统真实分配了多少内存，(iOS堆空间内存分配都是16字节的倍数)</li></ul><p>如下的Person类分别使用<code>class_getInstanceSize</code>和<code>malloc_size</code>计算出大小，分别是几呢？</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span>: <span class="hljs-title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">NSString</span> *_name;</span><br><span class="line">    <span class="hljs-built_in">NSInteger</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><p>答案是24和32。因为Person类，内部有_name属性和 _age两个属性，分别都是8个字节，再加上通过继承获得的isa指针，所以是24个字节。又因为系统分配都是16字节的倍数，所以系统真实会分配32字节。</p><h2 id="对象、类对象、元类对象"><a href="#对象、类对象、元类对象" class="headerlink" title="对象、类对象、元类对象"></a>对象、类对象、元类对象</h2><p><img src="https://i.loli.net/2019/12/02/35CyexBGoZTtjVw.png" alt="objc_class.png" style="zoom:50%;"></p><p>这个图很经典了。要强调的点是右上角的<code>Root Class(meta)</code>。它的isa指向自己，superclass指向<code>Root Class(class)</code>。这里的<code>Root Class</code>,其实就可以看做是<code>NSObject</code>，因为OC中<code>NSObject</code>就是<code>基类</code>。以及任何<code>meta-class</code>的<code>isa</code>指针都指向<code>Root Class(meta)</code>。</p><p>通过这幅图，可以清楚的了解到：<code>instance</code>、<code>class</code>、<code>meta-class</code>之间通过<code>isa</code>指针连接起来，父子类之间通过<code>superclass</code>指针连接起来。通过这样，不管是<code>instance</code>还是<code>class</code>，就都可以轻易的找到其所拥有的方法，属性等信息。</p><h3 id="instance"><a href="#instance" class="headerlink" title="instance"></a>instance</h3><p>通过alloc 创建的都是instance，alloc分配内存，init进行初始化。</p><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>为什么要有class对象？因为苹果使用class对象来保存instance的属性信息，对象方法信息，类所遵守的协议信息，成员变量信息等等，而不是保存在instance里，这样可以在内存中仅保存一个class对象即可。</p><p>我们经常说instance实例对象是保存在堆里面的，那class和meta-class呢。答案肯定是相同的，因为class和meta-class的本质同样也是对象，所以肯定保存在堆区。我尝试去验证了一下，验证的方法谈不上巧妙，挺愚蠢的，但是能够验证结论就行。验证方法如下：</p><p>我们知道iOS程序在内存中的布局<code>从低到高</code>如下：</p><p><code>代码区</code> -&gt; <code>常量区</code> -&gt; <code>全局区(已初始化)</code> -&gt; <code>全局区(未初始化)</code> -&gt; <code>堆区</code> -&gt; <code>栈区</code></p><p>我尝试打印 常量区变量的地址，全局区变量的地址，堆区变量的地址、栈区变量的地址。最后再打印类对象的地址，看看类对象的地址和上面所说的我明确知道是哪个区的变量的地址接近，就证明类对象到底是在哪个区存放。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//num1是已初始化变量，存放在全局区的已初始化区</span></span><br><span class="line"><span class="hljs-keyword">int</span> num1 = <span class="hljs-number">200</span>;</span><br><span class="line"><span class="hljs-comment">//num2是未初始化变量，存放在全局区的未初始化区</span></span><br><span class="line"><span class="hljs-keyword">int</span> num2;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="hljs-keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="hljs-built_in">NSString</span> *str = <span class="hljs-string">@"a"</span>;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"str指向常量区地址：%p"</span>,str);</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"num1指向全局区(已初始化)地址：%p"</span>,&amp;num1);</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"num2指向全局区(未初始化)地址：%p"</span>,&amp;num2);</span><br><span class="line">        <span class="hljs-comment">//object指针指向堆内存中的一块。 object指针本身又是保存在栈上</span></span><br><span class="line">        <span class="hljs-built_in">NSObject</span> *object = [[<span class="hljs-built_in">NSObject</span> alloc] init];</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"object指向的堆内存：%p"</span>,object);</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"object指针在栈上存放的地址：%p"</span>,&amp;object);</span><br><span class="line">        Class objectClass = object_getClass(object);</span><br><span class="line">        Class objectMetaClass = object_getClass(objectClass);</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"objectClass 指向的地址：%p"</span>,objectClass);</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"objectMetaClass 指向的地址：%p"</span>,objectMetaClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印如下</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str指向常量区地址：0x100001050</span><br><span class="line">num1指向全局区(已初始化)地址：0x1000012d0</span><br><span class="line">num2指向全局区(未初始化)地址：0x1000012d4</span><br><span class="line">object指向的堆内存：0x101887690</span><br><span class="line">object指针在栈上存放的地址：0x7ffeefbff570</span><br><span class="line">objectClass 指向的地址：0x100b37140</span><br><span class="line">objectMetaClass 指向的地址：0x100b370f0</span><br></pre></td></tr></table></figure><p>显然class 和 meta-class地址是介于 num2(全局区(未初始化)) 和 object指向的堆内存之间。又因为class和meta-class 肯定不可能是在全局区(未初始化)，所以那肯定是在堆区啦。</p><p>知道了class类对象是用来保存对象的属性信息，变量信息，方法信息等，那他到底是怎么保存这些信息的呢？</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="hljs-comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="hljs-keyword">cache_t</span> cache;             <span class="hljs-comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="hljs-keyword">class_data_bits_t</span> bits;    <span class="hljs-comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">        <span class="hljs-keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">  .... 省略</span></span><br><span class="line"><span class="hljs-comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//bits.data()</span></span><br><span class="line"><span class="hljs-keyword">class_rw_t</span>* data() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>查看源码，objc_class仅仅也只是有4个变量：</p><ol><li>isa</li><li>superclass</li><li>cache</li><li>bits</li></ol><p>isa，superclass是什么上文已经讲过了，cache看名字就知道是和缓存相关，这里暂时不介绍。那就只剩下bits这一个变量了，所以肯定是和bits有关。</p><p>查看class_rw_t *data(){}方法，返回值是class_rw_t：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="hljs-comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">class_ro_t</span> *ro;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">method_array_t</span> methods;</span><br><span class="line">    <span class="hljs-keyword">property_array_t</span> properties;</span><br><span class="line">    <span class="hljs-keyword">protocol_array_t</span> protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">char</span> *demangledName;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> index;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setFlags</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> <span class="hljs-built_in">set</span>)</span> </span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        OSAtomicOr32Barrier(<span class="hljs-built_in">set</span>, &amp;flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearFlags</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> clear)</span> </span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        OSAtomicXor32Barrier(clear, &amp;flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// set and clear must not overlap</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">changeFlags</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> <span class="hljs-built_in">set</span>, <span class="hljs-keyword">uint32_t</span> clear)</span> </span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        assert((<span class="hljs-built_in">set</span> &amp; clear) == <span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">uint32_t</span> oldf, newf;</span><br><span class="line">        <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">            oldf = flags;</span><br><span class="line">            newf = (oldf | <span class="hljs-built_in">set</span>) &amp; ~clear;</span><br><span class="line">        &#125; <span class="hljs-keyword">while</span> (!OSAtomicCompareAndSwap32Barrier(oldf, newf, (<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int32_t</span> *)&amp;flags));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> instanceSize;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * name;</span><br><span class="line">    <span class="hljs-keyword">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="hljs-keyword">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="hljs-keyword">property_list_t</span> *baseProperties;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">method_list_t</span> *baseMethods() <span class="hljs-keyword">const</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>查看class_rw_t结构体代码。其中有几个变量： methods，properties，protocols，class_ro_t *ro。</p><p>看到这里就能明白了，通过bits.data()=&gt; (class_rw_t *)(bits &amp; FAST_DATA_MASK) ,获取class_rw_t结构体，该结构体保存了相关类的方法信息，属性信息，协议信息，以及成员变量信息等。class_ro_t这里，我猜测ro是readonly的意思，保存的是只读，不可变的类信息，包括成员变量，类名等信息</p><h3 id="meta-class"><a href="#meta-class" class="headerlink" title="meta-class"></a>meta-class</h3><p>通过<code>objc_getClass(class)</code>方法来获取meta-class(元类对象)。</p><p>每个类在内存中有且只有一个·对象。meta-class与class都是Class类型。主要存储类方法信息等。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = [[Person <span class="hljs-keyword">class</span>] <span class="hljs-keyword">class</span>];</span><br></pre></td></tr></table></figure><p>上面的代码获取的cls是class对象(类对象)，并不是meta-class对象(元类对象)。</p><p>原因在于，第一个class 方法是类方法，第二个class方法仍是类方法（为什么第二个class仍然是类方法，因为第一个class调用后得到的是类对象，类对象调用的肯定又类方法啦）。</p><p>看一下<code>+(Class)class:</code>方法的实现就明白了。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)<span class="hljs-keyword">class</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)<span class="hljs-keyword">class</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> object_getClass(<span class="hljs-keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class object_getClass(<span class="hljs-keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (obj) <span class="hljs-keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h2><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">union</span> <span class="hljs-keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="hljs-keyword">isa_t</span>(<span class="hljs-keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="hljs-keyword">uintptr_t</span> bits;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span></span><br><span class="line">        ISA_BITFIELD;  <span class="hljs-comment">// defined in isa.h</span></span><br><span class="line">        </span><br><span class="line"><span class="hljs-comment">//        uintptr_t nonpointer        : 1; /*0 表示普通的 isa 指针，1 表示使用优化，存储引用计数*/</span></span><br><span class="line"><span class="hljs-comment">//        uintptr_t has_assoc         : 1;</span></span><br><span class="line"><span class="hljs-comment">//        uintptr_t has_cxx_dtor      : 1;  /*表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快*/</span></span><br><span class="line"><span class="hljs-comment">//        uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/</span></span><br><span class="line"><span class="hljs-comment">//        uintptr_t magic             : 6;</span></span><br><span class="line"><span class="hljs-comment">//        uintptr_t weakly_referenced : 1;</span></span><br><span class="line"><span class="hljs-comment">//        uintptr_t deallocating      : 1;</span></span><br><span class="line"><span class="hljs-comment">//        uintptr_t has_sidetable_rc  : 1;  /*如果为1 表示该对象的引用计数值是否过大无法存储在 isa 指针*/</span></span><br><span class="line"><span class="hljs-comment">//        uintptr_t extra_rc          : 19;</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上文提到，instance的isa指针是指向class（类对象），呢也就是说isa指针的值就是class的地址。但是从上面的源码可以看出，isa是isa_t类型，isa_t是一个union。</p><p>查看如下源码，isa需要进行一次位运算，才能计算出真实地址：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">inline</span> Class </span><br><span class="line">objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line">  <span class="hljs-comment">// SUPPORT_INDEXD_ISA 始终未0</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (isa.nonpointer) &#123;</span><br><span class="line">        <span class="hljs-keyword">uintptr_t</span> slot = isa.indexcls;</span><br><span class="line">        <span class="hljs-keyword">return</span> classForIndex((<span class="hljs-keyword">unsigned</span>)slot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> (Class)isa.bits;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span></span><br><span class="line">    <span class="hljs-keyword">return</span> (Class)(isa.bits &amp; ISA_MASK);</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码中发现，SUPPORT_INDEXD_ISA 这个宏始终未0，，且isa是联合体union，isa.bits其实就是isa的值。</p><p>我在Mac电脑上，x86架构下测试，发现instance的isa地址和class的地址是一样的。并且isa &amp; ISA_MASK后，结果仍然是isa的值。</p><p>于是我使用真机测试，发现isa的值和class的地址确实不一样了，需要isa &amp; ISA_MASK，才能获取class的地址</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">Class personClass = object_getClass(person);</span><br></pre></td></tr></table></figure><p><img src="../../../../../Library/Application Support/typora-user-images/image-20191203092933165.png" alt="image-20191203092933165"></p><h2 id="一道测试题"><a href="#一道测试题" class="headerlink" title="一道测试题"></a>一道测试题</h2><p>做一个小测试，检验上面的学习成果。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">BOOL</span> res1 = [[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>] isKindOfClass:[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]];</span><br><span class="line"><span class="hljs-built_in">BOOL</span> res2 = [[Person <span class="hljs-keyword">class</span>] isKindOfClass:[Person <span class="hljs-keyword">class</span>]];</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d %d"</span>,res1,res2);</span><br></pre></td></tr></table></figure><p>如下代码打印结果是什么？（<strong>这道题目本身就很扯，没有什么价值，会与不会无关紧要，仅仅就是加深对类对象、元类对象之间关系的理解。</strong>）</p><p>答案是 res1 = 1 ,res2 = 0。也就是第一个相等，第二个不相等。这个问题是在网上一篇文章看到的：<a href="https://www.jianshu.com/p/b26b6feb58f6" target="_blank" rel="noopener">https://www.jianshu.com/p/b26b6feb58f6</a> <strong>虽然作者给出的答案是正确的，但是解释却完全是错误的</strong>。(不知道为什么网上关于OC对象本质的文章真的是数不胜数，但是真心没有什么参考价值，要么是太浅显，要么就是各种错误)</p><p><code>NSObject</code> 有两个 <code>isKindOfClass</code>方法，一个是对象方法 一个是类方法：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (Class tcls = [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (tcls == cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="hljs-built_in">BOOL</span>)isSubclassOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (Class tcls = <span class="hljs-keyword">self</span>; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (tcls == cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面题目中的代码调用的很显然是<strong>+类方法</strong>，但是我看的这篇文章的作者却是在拿<strong>-对象方法</strong>在解释，这不是在误导群众嘛==。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>] isKindOfClass:[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]];</span><br><span class="line"></span><br><span class="line">+ (<span class="hljs-built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (Class tcls = object_getClass((<span class="hljs-keyword">id</span>)<span class="hljs-keyword">self</span>); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (tcls == cls) <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><p>这里只解释第一个为什么为1，也就是true，明白第一个自然第二个也就明白了。</p><p>[NSObject class]调用 +isKindOfClass方法<br>+isKindOfClass 内部是一个for循环，每次调用结束会 tcls = tcls-&gt;superclass<br>第一次for循环：<br><code>tcls</code> = object_getClass(self), 因为self是类对象，所以结果是<code>meta-class</code>，即元类对象</p><p><code>tcls</code>是<code>NSObject meta-class</code><br><code>cls</code> 是 <code>NSObject class</code></p><p>所以显然不相等；<br>第一次for循环结束：调用 tcls = tcls-&gt;superclass</p><p>因为<code>NSObject</code>是<code>rootClass</code>，所以<code>NSObject meta-class</code>的<code>superclass</code>指向的是<code>NSObject class</code>，所以调用完毕后，<code>tcls</code>就从<code>meta-class</code>变成了 <code>NSObject class</code><br>第二次for循环时：</p><p><code>tcls</code>是<code>NSObject class</code> ，<code>cls</code>也是<code>NSObject cls</code>，所以相等，返回<strong>true</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两年前写过一篇文章：&lt;a href=&quot;http://www.wuqihan.cn/2016/05/08/Objective-C%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/&quot;&gt;Objective-C类对象&lt;/a&gt;。当初对OC的理解还仅仅是刚入门，也没有遇到问题看源码的习惯，所以两年后，重新对Objective-C对象做一个总结。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.wuqihan.cn/categories/iOS/"/>
    
      <category term="Objective-C底层原理" scheme="http://www.wuqihan.cn/categories/iOS/Objective-C%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="类对象" scheme="http://www.wuqihan.cn/tags/%E7%B1%BB%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>汇编学习踩坑记录</title>
    <link href="http://www.wuqihan.cn/2018/05/28/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.wuqihan.cn/2018/05/28/汇编学习踩坑记录/</id>
    <published>2018-05-28T11:15:03.000Z</published>
    <updated>2019-09-03T11:45:58.535Z</updated>
    
    <content type="html"><![CDATA[<p>对于汇编学习，网上的资源相比高级语言算是挺少的了。这里，记录下在学习汇编过程踩过的坑和遇过的问题。</p><a id="more"></a><h2 id="mov-ax-ffffh"><a href="#mov-ax-ffffh" class="headerlink" title="mov ax ffffh"></a>mov ax ffffh</h2><p><strong>mov ax ffffh</strong>这段指令，编译器会报错。</p><p>原因：大于9ffffh的十六进制数据，如果a000h、a001h……ffffh等，在书写的时候都是以字母开头。而<strong>在汇编源程序中，数据不能以字母开头</strong>，所以要在前面加0。</p><p>应该改为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax 0ffffh</span><br></pre></td></tr></table></figure><h2 id="mov-ax-0h"><a href="#mov-ax-0h" class="headerlink" title="mov ax [0h]"></a>mov ax [0h]</h2><p>把地址为 1000h:[0h]的内存单元的内容赋值给ax时，我们可能会这样写</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000h</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,[0h]</span><br></pre></td></tr></table></figure><p>这段汇编代码没有任何问题，但是其中<strong>mov ax,[0h]</strong>在<code>masm</code>编译器中是亲测是无法达到预期的效果，会被解释为 <strong>mov ax,0h</strong></p><p>为了达到预期效果，可以把指令改为</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[0h]</span><br></pre></td></tr></table></figure><p>或者使用<code>emu8086</code>编写汇编代码，就不会出现上面的问题。</p><p>自从出现这个问题。我就再也不适用<code>masm</code>编译了，以免踩到跟多的坑。</p><h2 id="Debug-exe常用命令"><a href="#Debug-exe常用命令" class="headerlink" title="Debug.exe常用命令"></a>Debug.exe常用命令</h2><ul><li><p>r</p><p>查看各个寄存器</p></li><li><p>d</p><p>查看内存单元/寄存器中的内容</p></li><li><p>u</p><p>查看内存单元对应的指令</p></li><li><p>e</p><p>写入指令</p></li><li><p>t</p><p>执行下一条指令</p></li><li><p>g</p><p>g xxxx (xxxx为内存物理地址)。表示程序直接执行到 xxxx对应的指令。</p></li><li><p>p</p><p>如果下一条指令是int，要想正确执行下一条指令，是用p</p><p>如果遇到loop想自动执行完loop，可以使用p</p></li></ul><h2 id="寄存器中最大存储的十进制数为65535"><a href="#寄存器中最大存储的十进制数为65535" class="headerlink" title="寄存器中最大存储的十进制数为65535"></a>寄存器中最大存储的十进制数为65535</h2><p>x86 CPU为16位，也就是说寄存器为16位，最大存储两个字节，一个字。</p><p>寄存器存储的最大16进制数为ffffh = 16^4-1=65535</p><p>所以在使用十进制赋值的时候，注意不要超过65535</p><h2 id="如果段中的数据占N个字节，则程序加载后，该段实际占有空间为多少？"><a href="#如果段中的数据占N个字节，则程序加载后，该段实际占有空间为多少？" class="headerlink" title="如果段中的数据占N个字节，则程序加载后，该段实际占有空间为多少？"></a>如果段中的数据占N个字节，则程序加载后，该段实际占有空间为多少？</h2><p>《汇编语言》第三版这本书 给的答案是：（N/16+1)*16</p><p>这个答案是 <code>错误</code></p><p>如果当N = 16时，如果按照答案，得到的是32，其实还是16。如果不确定，可以自己动手测试一下(经过我自己的测试、确实不是32，而是16)</p><p>准确答案是：</p><ul><li><p><strong>当N可以被16整除时</strong></p><p>占有的空间为<code>(N/16)*16</code></p></li><li><p><strong>当N不可以被16整除时</strong></p><p>占有的空间为<code>(N/16+1)*16</code></p></li></ul><p>上面两种情况总结成一个通用的公式：<code>((N+15)/16)*16</code></p><blockquote><p>8086汇编中 每个段都是以16字节来对齐的</p></blockquote><p>至于为什么这样子设计，我觉得应该是根据8086CPU特殊的寻址方式(段地址*16+偏移地址 )有关。比如一个段中的数据占了17个内存单元，那下一个段，肯定不是从第18个内存单元开始，因为段地址起始地址，必须是16的整数倍。所以如果一个段中的数据占17个内存单元，那紧挨着它的下一个段肯定是从第33个内存单元(也就是编号32开始)开始。</p><p>如果理解了上面的问题，可以动手做一下下面的题目，巩固对上面的理解</p><p><img src="https://i.loli.net/2019/09/03/hHUOXtumjiCQgkw.png" alt="汇编题目.png"></p><p>答案：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">a segment </span><br><span class="line">db 1,2,3,4,5,6,7,8</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line">db 1,2,3,4,5,6,7,8</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">c segment</span><br><span class="line">db 0,0,0,0,0,0,0,0</span><br><span class="line">c ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">mov ax,a</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov bx,0  </span><br><span class="line">mov cx,8</span><br><span class="line">s:mov al,ds:[bx]</span><br><span class="line">add al,ds:[bx+16] ; 注意！！！这里是16 不是8 我第一次写的时候写成了8 结果在调试的时候发现了这个错误</span><br><span class="line">mov ds:[bx+32],al ; 注意！！！这里是32 不是16</span><br><span class="line">add bx,1</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于汇编学习，网上的资源相比高级语言算是挺少的了。这里，记录下在学习汇编过程踩过的坑和遇过的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wuqihan.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="汇编语言" scheme="http://www.wuqihan.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="8086汇编" scheme="http://www.wuqihan.cn/tags/8086%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>CPU寻址能力到底怎么理解？</title>
    <link href="http://www.wuqihan.cn/2018/05/19/CPU%E5%AF%BB%E5%9D%80%E8%83%BD%E5%8A%9B%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F/"/>
    <id>http://www.wuqihan.cn/2018/05/19/CPU寻址能力到底怎么理解？/</id>
    <published>2018-05-18T17:04:33.000Z</published>
    <updated>2019-11-01T15:25:05.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>首先讲解一下<code>存储器</code></p><p><code>存储器</code>是计算机重要组成部分，他是用来存储数据和部件。存储器的种类很多，按各种说法分类也有很多。下面主要讲解一种通常普遍的说法</p><p>现代计算机存储器按<strong>用途</strong>分类，可以分为：</p><ul><li><p>主存储器，简称主存</p><ul><li>RAM</li><li>ROM</li></ul></li><li><p>辅助存储器</p></li><li><p>Cache(高级缓冲存储器)   (它位于CPU与主存之间，是读写速度比内存还快的存储器，从名字应该就知道它的作用，主要是为了解决CPU和主存速度不匹配而设计的，因为CPU中寄存器的速度更更快，所以出现了速度能接近于CPU的Cache)</p><a id="more"></a></li></ul><blockquote><p>通常我们会把主存储器叫做内存。但是严格意义上说，内存是由主存（比如内存条）、Cache两部分组成。但是可能由于Cache相对于内存条容量特别小，以及很久之前的计算机没有Cache，所以很多情况，大家就默认内存就是主存的说法了。</p></blockquote><p>通过上面介绍存储器，我们可以知道 内存 是存储器的一部分，也叫主存。</p><p>内存是CPU能直接寻址的存储空间。计算机中所有的程序的运行都是在内存中进行的。</p><p>内存的特点是速率很快。（这点大家都应该知道。）</p><p>我们平时会说 “我的电脑内存太小，只有4G，需要加内存条”，这里所说的 <strong>4G</strong>是什么意思呢？</p><p>内存中含有大量的存储单元，<code>每个存储单元的大小都是1B</code>，所以上面所说的4G内存，意思就是它是有2<sup>2</sup>*2<sup>30</sup>个存储单元。</p><p>这些个存储单元组成在一起，就叫做 <code>内存空间</code>,那何为内存地址呢？在内存中，每个存储单元都有一个编号，这个编号通常用16进制表示，从0开始编号。这个编号就叫做内存地址。</p><p>理解了 <code>内存地址</code>和 <code>内存空间</code> 才能共清楚的明白CPU寻址。</p><h2 id="寻址空间"><a href="#寻址空间" class="headerlink" title="寻址空间"></a>寻址空间</h2><p>CPU<code>寻址</code>，也就是通过内存地址，找到对应的存储单元。上面已经提到过，一个存储单元是1B。</p><p>解释寻址能力之前，先来看下 <code>寻址空间</code> （<code>Addressing space</code>）的概念。</p><blockquote><p><code>寻址空间</code>一般指的是CPU对于<a href="https://baike.baidu.com/item/内存寻址/1012006" target="_blank" rel="noopener">内存寻址</a>的能力。通俗地说，就是能最多用到多少内存空间的一个问题。数据在<a href="https://baike.baidu.com/item/存储器/1583185" target="_blank" rel="noopener">存储器</a>(RAM)中存放是有规律的 ，CPU在运算的时候需要把数据提取出来就需要知道数据存放在哪里 ，这时候就需要挨家挨户的找，这就叫做寻址，但如果地址太多超出了CPU的能力范围，CPU就无法找到数据了。 CPU最大能查找多大范围的地址叫做寻址能力 ，CPU的寻址能力以<a href="https://baike.baidu.com/item/字节/1096318" target="_blank" rel="noopener">字节</a>为单位 ，如32位寻址的CPU可以寻址2的32次方大小的地址也就是4G，这也是为什么32位的CPU最大能搭配4G内存的原因 ，再多的话CPU就找不到了。</p></blockquote><p>上面提到了何为<code>寻址能力</code>？就是<code>CPU最大能查找多大范围的地址</code>。<strong>千万不要理解为CPU最大能查找多大的地址</strong> 虽然跟上一句比仅仅少了一个’范围’，但是完全是两个意思。 我最开始就理解成了 最大能查找到多大的地址。。。</p><p>或者也可以理解为：<strong>CPU最多能查找多少个地址</strong> （这里多少个地址，指得是多少个存储单元，存储单位最小单位是Byte，不是b） 。或者可以理解为 <strong>CPU可以对多少个存储单元进行寻址</strong></p><p>到了这里 应该就明白了<code>寻址能力</code>的概念，但是还不够。。</p><blockquote><p>注意：文中的“存储单元”或者“内存单元”意思是一样的。”内存空间”和”存储空间” 意思也是一样的。</p></blockquote><h2 id="寻址能力-Byte-or-Bite"><a href="#寻址能力-Byte-or-Bite" class="headerlink" title="寻址能力 Byte or Bite?"></a>寻址能力 Byte or Bite?</h2><p>思考一个问题：</p><blockquote><p>8086CPU的地址总线宽度是<code>20</code>，那么他的寻址能力是大呢</p></blockquote><p>看到这里如果不明白什么是地址总线，请看我的这篇文章 : <a href="http://www.wuqihan.cn/2018/05/15/入门汇编语言/">入门汇编语言</a></p><p>地址总线的宽度决定了CPU的寻址能力，宽度是20，也就代表有20根导线， 每根导线发射的是高、低电信号两种情况，所以寻址能力为 2<sup>20</sup>B = <code>1M</code> </p><p>但是这里可能会出现很多人都纳闷的问题，20根导线，不就是20位吗，所以应该是2<sup>20</sup>b。那为什么是 2<sup>20</sup>B ，而不是2<sup>20</sup>b 呢？ （B为Byte/字节，b为bite/位）</p><blockquote><p><code>位</code> ，表示的是二进制位，一般称为比特，即0或1，<strong>是计算机存储的最小单位</strong></p><p>字节是计算机中数据处理的基本单位；计算机以字节为单位存储和解释信息，规定一个字节由8个二进制位构成，即1B = 8b</p></blockquote><p>因为地址总线的宽度决定了CPU的 寻址能力，那何为寻址能力呢，说面提到了，寻址能力可以理解为CPU可以对多少个存储单元进行寻址，地址总线是20，那么就代表最多能找到2<sup>20</sup>个存储单元，又因为8086中一个存储单元是1B所以，这里是2<sup>20</sup>B</p><p>看到这里可能又会继续糊涂，因为你可能不明白存储单元、内存地址、内存空间到底是什么，他们之间有什么的联系，所以往下看……</p><h2 id="内存地址、内存单元和内存空间"><a href="#内存地址、内存单元和内存空间" class="headerlink" title="内存地址、内存单元和内存空间"></a>内存地址、内存单元和内存空间</h2><p>首先。在平时开发中，可能有时候你看到的内存地址是4位16进制（0x0001），有时候你看到的内存地址是8位16进制(0x00000001)。这两个内存地址都是表示编号大小为十进制1的内存地址，为什么一个用4位16进制？另外一个又用8位16进制？(注意，0x0001 和 0x00000001 仅仅是表示方式不一样，数值大小可是相等的，可别搞迷糊了！）</p><p><img src="https://i.loli.net/2019/08/18/aW98uSNHC54Jl6i.png" alt="8位16进制"></p><p><img src="https://i.loli.net/2019/08/18/eWXBPmOLKAdtYnD.png" alt="4位16进制"></p><p>这就是因为寻址能力的问题。CPU寻址能力达不到8位16进制，所以用4位16进制表示就可以，理论上你硬要用8位16进制表示也可以。只不过你寻址能力低，不可能超过4位。所以 寻址能力低，不会超过4位的就用4位16进制，能够超过4的cpu就用8位16进制。</p><p>接下来就解释一下<code>内存地址</code>和 <code>内存单元</code></p><p><code>内存地址</code> 仅仅是一个标号，代表一个内存单元。在计算机中存储器的容量是以字节B为基本单位的，所以一个内存地址代表一个字节 1B = 8b 的内存单元，也可以说一个内存单元占8b或1B的存储空间。</p><p>我们平时经常说32位操作 系统，最多支持4G内存空间。就是因为2<sup>32</sup>B = 4G</p><p>所以这里的结论就是：<code>用4位16进制表示的内存地址和用8位16进制表示的内存地址，其实都是代表一个8位/1字节的存储空间，把这8位/1字节的存储空间叫做一个内存单元</code></p><p>比如一个汉字“中”在计算机中是如何存储呢，一个汉字，需要两个存储单元，也就是2B大小，这2B存储空间是连续的，所以不需要全部找到，只需要找到最开始的一部分，就能找到这个“中”</p><p>所以，内存地址是内寸中存储数据的一个标识，并不是数据本身，通过内存地址可以知道内存当中存储的数据，这个数据可能占1个内存单元，也可能占多个内存单元。 </p><p>可以抽象的把内存空间比作房子🏡，如果想要找到房子，就需要通过🚪门牌号来找，所以内存地址就可以比作门牌号，那这个房子多大呢，就可以称为占了多少的内存空间。那这个房子里可能还包括有厨房、卧室、卫生间，这些统统不用继续找了，因为有了门牌号（内存地址），就能找到房子（数据，整个内存空间），找到房子自然就能找打屋里的厨房、卧室……(一个个内存单元)。另外，门牌号是贴在房子上的，所以内存地址不占用内存空间，不要和平时开发中的指针这一概念搞混淆。</p><blockquote><p>参考：</p><p><a href="[https://baike.baidu.com/item/%E5%AF%BB%E5%9D%80%E7%A9%BA%E9%97%B4](https://baike.baidu.com/item/寻址空间">《百度百科-寻址空间》</a>)</p><p><a href="http://www.asmedu.net/bbs/pasteinfo.jsp?part=1&amp;level=book&amp;kind=1002&amp;qkSg=2&amp;qID=27391&amp;readSg=1" target="_blank" rel="noopener">《汇编语言论坛》</a></p><p><a href="https://www.kancloud.cn/chandler/programming_road/695585" target="_blank" rel="noopener">《内存概念》</a></p><p><a href="https://www.cnblogs.com/VIPler/p/4282584.html" target="_blank" rel="noopener">《关于内存地址和内存空间的概念》</a></p><p><a href="https://www.cnblogs.com/Lanht/p/10780364.html" target="_blank" rel="noopener">《内存地址与内存空间》</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存&quot;&gt;&lt;a href=&quot;#内存&quot; class=&quot;headerlink&quot; title=&quot;内存&quot;&gt;&lt;/a&gt;内存&lt;/h2&gt;&lt;p&gt;首先讲解一下&lt;code&gt;存储器&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;存储器&lt;/code&gt;是计算机重要组成部分，他是用来存储数据和部件。存储器的种类很多，按各种说法分类也有很多。下面主要讲解一种通常普遍的说法&lt;/p&gt;
&lt;p&gt;现代计算机存储器按&lt;strong&gt;用途&lt;/strong&gt;分类，可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;主存储器，简称主存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RAM&lt;/li&gt;
&lt;li&gt;ROM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;辅助存储器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cache(高级缓冲存储器)   (它位于CPU与主存之间，是读写速度比内存还快的存储器，从名字应该就知道它的作用，主要是为了解决CPU和主存速度不匹配而设计的，因为CPU中寄存器的速度更更快，所以出现了速度能接近于CPU的Cache)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wuqihan.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="汇编语言" scheme="http://www.wuqihan.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="8086汇编" scheme="http://www.wuqihan.cn/tags/8086%E6%B1%87%E7%BC%96/"/>
    
      <category term="寻址能力" scheme="http://www.wuqihan.cn/tags/%E5%AF%BB%E5%9D%80%E8%83%BD%E5%8A%9B/"/>
    
      <category term="cpu" scheme="http://www.wuqihan.cn/tags/cpu/"/>
    
      <category term="内存" scheme="http://www.wuqihan.cn/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>优雅的使用NSNotification.Name</title>
    <link href="http://www.wuqihan.cn/2018/05/18/%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8NSNotification-name/"/>
    <id>http://www.wuqihan.cn/2018/05/18/优雅的使用NSNotification-name/</id>
    <published>2018-05-18T04:34:36.000Z</published>
    <updated>2019-12-02T16:48:52.612Z</updated>
    
    <content type="html"><![CDATA[<p>Swift 3之前使用通知：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-type">NSNotificationCenter</span>.defaultCenter().post(<span class="hljs-string">"kReceiveMessageNoti"</span>)</span><br></pre></td></tr></table></figure><p>Swift 3之后</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-type">NotificationCenter</span>.<span class="hljs-keyword">default</span>.post(<span class="hljs-type">Notification</span>.<span class="hljs-type">Name</span>(rawValue: <span class="hljs-string">"kReceiveMessageNoti"</span>))</span><br></pre></td></tr></table></figure><a id="more"></a><p>显然 这种使用全局字符串常亮的方法不是很好。</p><p>我在阅读<code>Almofire</code>的时候发现，作者是这样使用通知的：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Notification</span>.<span class="hljs-title">Name</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Task</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> <span class="hljs-type">DidResume</span> = <span class="hljs-type">Notification</span>.<span class="hljs-type">Name</span>(rawValue: <span class="hljs-string">"org.alamofire.notification.name.task.didResume"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-type">NotificationCenter</span>.<span class="hljs-keyword">default</span>.post(</span><br><span class="line">            name: <span class="hljs-type">Notification</span>.<span class="hljs-type">Name</span>.<span class="hljs-type">Task</span>.<span class="hljs-type">DidResume</span>,</span><br><span class="line">            object: <span class="hljs-keyword">self</span>,</span><br><span class="line">            userInfo: [<span class="hljs-type">Notification</span>.<span class="hljs-type">Key</span>.<span class="hljs-type">Task</span>: task]</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>利用<code>extension</code>为Notification.Name添加一个结构体，在结构体上添加 静态常量办法。直接使用静态常量就可以，但是作者又使用了 结构体，这样做的好处是为了给通知名称分类。</p><p>显然这种方法比我们直接使用常量字符串要好很多。下面。再给出我使用enum的方法</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DDNotificationName</span>: <span class="hljs-title">String</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">/// 注销成功</span></span><br><span class="line">    <span class="hljs-keyword">case</span> logoutSuccess</span><br><span class="line">    <span class="hljs-comment">/// 登录成功</span></span><br><span class="line">    <span class="hljs-keyword">case</span> loginSuccess</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//收到消息</span></span><br><span class="line">    <span class="hljs-keyword">case</span> receiveMessage</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">var</span> name: <span class="hljs-type">NSNotification</span>.<span class="hljs-type">Name</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-type">NSNotification</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"k"</span> + rawValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-type">NotificationCenter</span>.<span class="hljs-keyword">default</span>.post(name: <span class="hljs-type">DDNotificationName</span>.loginSuccess.name, object: <span class="hljs-literal">nil</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift 3之前使用通知：&lt;/p&gt;
&lt;figure class=&quot;highlight swift hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;NSNotificationCenter&lt;/span&gt;.defaultCenter().post(&lt;span class=&quot;hljs-string&quot;&gt;&quot;kReceiveMessageNoti&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Swift 3之后&lt;/p&gt;
&lt;figure class=&quot;highlight swift hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;NotificationCenter&lt;/span&gt;.&lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt;.post(&lt;span class=&quot;hljs-type&quot;&gt;Notification&lt;/span&gt;.&lt;span class=&quot;hljs-type&quot;&gt;Name&lt;/span&gt;(rawValue: &lt;span class=&quot;hljs-string&quot;&gt;&quot;kReceiveMessageNoti&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.wuqihan.cn/categories/Swift/"/>
    
    
      <category term="swift tips" scheme="http://www.wuqihan.cn/tags/swift-tips/"/>
    
  </entry>
  
  <entry>
    <title>入门汇编语言</title>
    <link href="http://www.wuqihan.cn/2018/05/15/%E5%85%A5%E9%97%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    <id>http://www.wuqihan.cn/2018/05/15/入门汇编语言/</id>
    <published>2018-05-15T13:07:50.000Z</published>
    <updated>2019-11-06T14:04:12.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="了解汇编语言"><a href="#了解汇编语言" class="headerlink" title="了解汇编语言"></a>了解汇编语言</h2><h3 id="编程语言的发展"><a href="#编程语言的发展" class="headerlink" title="编程语言的发展"></a>编程语言的发展</h3><ul><li>机器语言<ul><li>由0和1组成</li></ul></li><li>汇编语言 （<strong>Assembly Language</strong>）<ul><li>用符号代替了0和1，比机器语言便于阅读和机翼</li></ul></li><li>高级语言<ul><li>C\C++\Java\Swift等，更接近人类自然语言</li></ul></li></ul><a id="more"></a><p>分别用上面三种语言实现： 将寄存器BX的内容送人寄存器AX</p><p>机器语言： 10010100010101 </p><p>汇编语言：mov ax,bx</p><p>高级语言：ax = bx</p><p>由此可以看出，越低级的语言，越是难以理解。。。</p><p><img src="https://i.loli.net/2019/08/17/67PdqwxGugaCYmE.png" alt="汇编语言的发展"></p><ul><li><p><font color="#FF6347">汇编语言</font> 与 <font color="#FF6347"><strong>机器语言</strong></font> 一一对应，每一条机器指令都有与之对应的汇编指令</p></li><li><font color="#FF6347"><strong>汇编语言</strong></font> 可以通过编译得到<font color="#FF6347"><strong>机器语言</strong></font>，<font color="#FF6347"><strong>机器语言</strong></font>可以通过反汇编得到<font color="#FF6347"><strong>汇编语言</strong></font> </li><li><font color="#FF6347"><strong>高级语言</strong></font>可以通过编译得到<font color="#FF6347"><strong>汇编语言</strong></font> \ <font color="#FF6347"><strong>机器语言</strong></font>，但<font color="#FF6347"><strong>汇编语言</strong></font> \ <font color="#FF6347"><strong>机器语言</strong></font>几乎不可能还原成<font color="#FF6347"><strong>高级语言</strong></font></li></ul><h3 id="汇编语言的特点"><a href="#汇编语言的特点" class="headerlink" title="汇编语言的特点"></a>汇编语言的特点</h3><ul><li><code>所有高级语言（C、Swift、Java等）都是基于操作系统，无法脱离于操作系统之外。但是汇编是基于硬件（可以说是CPU）的语言。</code></li><li>可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度的发挥硬件的功能</li><li>汇编指令是机器指令的助记符，同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性</li><li>知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护</li><li>不区分大小写、比如 mov 和MOV是一样的</li><li>汇编语言种类很多<ul><li>8086汇编</li><li>Win32汇编</li><li>Win64汇编</li><li>AT&amp;T汇编（Mac、iOS模拟器）</li><li>ARM汇编（嵌入式设备，也就是手机电视车载系统之类） </li></ul></li></ul><h3 id="汇编语言VS高级语言"><a href="#汇编语言VS高级语言" class="headerlink" title="汇编语言VS高级语言"></a>汇编语言VS高级语言</h3><p>采用高级语言C++和汇编语言编写同一个功能 ： 将a+b的结果赋值给c，然后在屏幕上打印c的结果</p><table><thead><tr><th>语言</th><th>源文件大小</th><th>目标文件大小</th><th>可执行文件大小</th></tr></thead><tbody><tr><td><font color="#FF6347">汇编语言</font></td><td><font color="#FF6347">近400字节</font></td><td><font color="#FF6347">近200字节</font></td><td><font color="#FF6347">近600字节</font></td></tr><tr><td>C++</td><td>近150字节</td><td>近550字节</td><td>近9000字节</td></tr></tbody></table><h2 id="CPU总线"><a href="#CPU总线" class="headerlink" title="CPU总线"></a>CPU总线</h2><p><img src="https://i.loli.net/2019/08/17/NYDB6UtSolcFLr2.jpg" width="400" height="260" align="center"><br>每一个CPU芯片都有许多<code>管脚</code>（上图右边银色的触角），这些<code>管脚</code>和<code>总线</code>相连，CPU通过<code>总线</code>跟外部进行交互；</p><p>总线：一根根导线的集合</p><p>总线的分类：</p><ul><li>地址总线</li><li>数据总线</li><li>控制总线</li></ul><p><img src="https://i.loli.net/2019/08/18/rSysNhakF9p3V2M.png" alt="结构.png"></p><h3 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h3><p>它的宽度决定了CPU的 <code>寻址能力</code> （什么是寻址能力，指它能找到多大的地址）</p><p>8086的地址总线宽度是20，所以寻址能力即为2<sup>20</sup>B = 2<sup>10</sup>B <em> 2<sup> 10</sup>=1KB </em> 2<sup>10</sup> = 1KB * 1024 = 1M</p><blockquote><p>什么是<code>寻址能力</code>？<code>寻址能力</code>为什么如上面这样计算？</p><p>由于解释起来篇幅不短，所以新写一篇文章专门讨论 <a href="http://www.wuqihan.cn/2018/05/19/CPU寻址能力到底怎么理解？/">《CPU寻址能力到底怎么理解？》</a></p></blockquote><h3 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h3><p>它的宽度决定了CPU的单次数据传送量，也就是数据传送速度</p><p>8086的数据总线宽度是16，所以单次最大传递2个字节的数据。因为16根线，代表16位，8位等于1字节，所以是2字节。</p><font color="green">注意！！这里的数据总线千万不要和上面的地址总线搞混，完全是两码事儿</font><h3 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h3><p>它的宽度决定了CPU对其他器件的控制能力、能有多少种控制</p><p>控制总线  知道大概就行，不需要深究</p><h2 id="8086的寻址方式"><a href="#8086的寻址方式" class="headerlink" title="8086的寻址方式"></a>8086的寻址方式</h2><p>CPU访问内存单元时，要给出内存单元的地址，也就是内存地址</p><p>8086CPU虽然是16位CPU，但是它有20位地址总线，可以传送20位的地址，1M的寻址能力</p><p>内部地址16位，但是却能传送出20位的地址，原因是： <code>8086采用一种在内部用2个16位地址合成的方法来生成1个20位的物理地址</code></p><p><img src="https://i.loli.net/2019/08/28/HVx6WCMfve8I5lr.png" alt></p><p>地址加法器采用 <code>物理地址=段地址*16+偏移地址</code>的方法用段地址和偏移地址合成物理地址。例如，8086CPU要访问123C8H的内存单元是，可以通过1230H*10H+00C8H</p><h2 id="主要寄存器"><a href="#主要寄存器" class="headerlink" title="主要寄存器"></a>主要寄存器</h2><p><img src="https://i.loli.net/2019/08/28/tCGUrPq9BoKMpa5.jpg" alt="寄存器"> </p><p>8086有14个寄存器，都是16位。可以存放2个字节（2个字节是一个字word）</p><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，称为通用寄存器(有时也有特定用途)；通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对通用寄存器中的数据进行运算。</p><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>8086有4个段寄存器:CS、DS、SS、ES，当CPU需要访问内存时由这4个段寄存器提供内存单元的段地址。</p><h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><p>最常用的控制寄存器IP，通常和CS代码段寄存器搭配使用，为CS服务</p><p>CS为代码段寄存器，IP为指令指针寄存器，它们指示了CPU当前要读取指令的地址；</p><p>任意时刻，8086CPU都会将CS:IP指向 的指令作为下一条需要执行的指令。</p><p><img src="https://i.loli.net/2019/08/28/l6MsRdmqjJnUeHr.png" alt="指令的执行过程"></p><p>上图有执行顺序编号，详细执行过程如下：</p><ol><li><code>CS</code>、<code>IP</code>中的内容送入<code>地址加法器</code>，得到物理地址 20000H</li><li><code>地址加法器</code>将物理地址送入<code>输入输出控制电路</code></li><li><code>输入输出控制电路</code>将物理地址2000H送上 <code>地址总线</code></li><li>从地址为20000H的内存单元开始，存放的机器指令B8 23 01通过数据总线被送入CPU</li><li><code>输入输出控制电路</code>将机器指令B8 23 01送入 <code>指令缓冲器</code></li><li>读取一条指令后，IP中的值自动增加，以使CPU可以读取下一条指令。因为B82301是3个字节，所以IP中的值加3 ，此时CS:IP指向内存单元2000H:0003H</li><li><code>执行控制器</code>执行指令 B8 23 01即 mov ax,0123h</li><li>回到第1步，重复以上的步骤，只不过第一条中的CS仍然为2000H，但是iP已经在第6步中改为了0003H</li></ol><h2 id="汇编语言学习资料整理"><a href="#汇编语言学习资料整理" class="headerlink" title="汇编语言学习资料整理"></a>汇编语言学习资料整理</h2><p><a href="https://book.douban.com/subject/25726019/" target="_blank" rel="noopener">《汇编语言(第三版)》-王爽</a>  </p><p><img src="https://i.loli.net/2019/08/18/Jga6Iu49SPHy5n3.jpg"> </p><p>豆瓣9.2分 必看！！正在读这本书，真的是特别值得推荐！是我所有读过的国内计算机类书籍中我觉得写得最好的一本。</p><p><a href="http://www.asmedu.net/bbs/forum.jsp" target="_blank" rel="noopener">《汇编语言论坛》</a></p><p>已经很少有人讨论了。但是里面有很多以前讨论的问题和解答，很有参考价值</p><p><a href="https://www.bilibili.com/video/av22872043/" target="_blank" rel="noopener">《零基础入门学习汇编语言》- 小甲鱼</a></p><p>这是一套视频，没有看过，但是在网上查找汇编相关的资料的时候，发现很多网友都是看过这套视频，对于入门应该不错。 上大学的时候记得有看过他的入门C语言视频</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;了解汇编语言&quot;&gt;&lt;a href=&quot;#了解汇编语言&quot; class=&quot;headerlink&quot; title=&quot;了解汇编语言&quot;&gt;&lt;/a&gt;了解汇编语言&lt;/h2&gt;&lt;h3 id=&quot;编程语言的发展&quot;&gt;&lt;a href=&quot;#编程语言的发展&quot; class=&quot;headerlink&quot; title=&quot;编程语言的发展&quot;&gt;&lt;/a&gt;编程语言的发展&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;机器语言&lt;ul&gt;
&lt;li&gt;由0和1组成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;汇编语言 （&lt;strong&gt;Assembly Language&lt;/strong&gt;）&lt;ul&gt;
&lt;li&gt;用符号代替了0和1，比机器语言便于阅读和机翼&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高级语言&lt;ul&gt;
&lt;li&gt;C\C++\Java\Swift等，更接近人类自然语言&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wuqihan.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="汇编语言" scheme="http://www.wuqihan.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="8086汇编" scheme="http://www.wuqihan.cn/tags/8086%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Block</title>
    <link href="http://www.wuqihan.cn/2018/01/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Block/"/>
    <id>http://www.wuqihan.cn/2018/01/11/深入理解Block/</id>
    <published>2018-01-11T08:52:33.000Z</published>
    <updated>2019-10-13T09:41:41.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="block的本质"><a href="#block的本质" class="headerlink" title="block的本质"></a>block的本质</h2><p>block看上去是“带有自动变量值的匿名函数”，实际上是作为极普通的C语言源代码来处理的。通过支持Block的编译器，将含有Block语法的源代码转换为一般C语言编译器能够处理的源代码。</p><p>在实际编译时无法转换为我们能够理解的源代码，但clang(LLVM编译器)具有转换为我们可读源代码的功能。通过“-rewrite-objc”选项就能将含有Block语法的源代码转换为C++代码。</p><a id="more"></a><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">void</span> (^blk)(<span class="hljs-keyword">void</span>) = ^&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Block\n"</span>);&#125;;</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此源代码的Block语法最为简单，它省略了返回值类型以及参数列表。通过clang可变换为一下形式：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">void</span> *isa;</span><br><span class="line">  <span class="hljs-keyword">int</span> Flags;</span><br><span class="line">  <span class="hljs-keyword">int</span> Reserved;</span><br><span class="line">  <span class="hljs-keyword">void</span> *FuncPtr;<span class="hljs-comment">//函数指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//__main_block_impl_0结构体相当于基于objc_object结构体的Objective-C对象的结构体。</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span></span><br><span class="line">  <span class="hljs-comment">//结构体的构造函数 (C是不允许这么写的,C++才可以)</span></span><br><span class="line">  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) &#123;</span><br><span class="line">    <span class="hljs-comment">//通过isa指针，可以想到block实质是OC的对象</span></span><br><span class="line">    <span class="hljs-comment">// isa指向block的类对象objc_class结构体。block的类对象通过&amp;_NSConcreteStackBlock初始化。</span></span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    <span class="hljs-comment">//impl.FuncPtr保存block执行的内容。在这里就是__main_block_func_0这个c语言函数</span></span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//- 通过block使用的匿名函数实际上是被作为简单的c语言函数来处理。另外根据block语法所属的函数名(此处为main)和该block语法所在该函数出现的顺序值(此处为0)来给经clang变换的函数命名。</span></span><br><span class="line"><span class="hljs-comment">//- 该函数的参数__cself相当于c++实例方法中指向实例自身的变量this，或是OC中的self，即__cself为指向Block值得变量。</span></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Block\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">size_t</span> reserved;</span><br><span class="line">  <span class="hljs-keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">void</span> (*blk)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">//blk为什么能直接调用FuncPtr呢，不是应该blk-&gt;imp.FuncPtr吗，因为这里进行了强制转换，把blk</span></span><br><span class="line"><span class="hljs-comment">//转为了impl，为什么可以这样转呢，因为impl是blk的第一个变量，所以他们两个的地址其实是一样的。</span></span><br><span class="line">    ((<span class="hljs-keyword">void</span> (*)(·__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法中，初始化了block，并调用了执行了block，通过clang转换的源代码由于转换较多，看起来不是很清楚，这里优化去掉转换部分，具体如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//该源代码将__main_block_impl_0结构体类型的自动变量，即栈上生成的__main_block_impl_0结构体实例的指针，赋值给__main_block_impl_0结构体指针类型的变量。</span></span><br><span class="line"><span class="hljs-comment">//下面两行对应的代码是：void (^blk)(void) = ^&#123;printf("Block\n");&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//__main_block_impl_0的构造函数需要传入两个参数，上面源代码中构造函数参数有3个，最后一个有默认值，可以不传，所以这里传的是两个参数：</span></span><br><span class="line"><span class="hljs-comment">//- 第一个参数是block中所执行的具体内容，由block语法转换的C语言函数。</span></span><br><span class="line"><span class="hljs-comment">//- 第二个参数是静态全局变量初始化的__main_block_desc_0结构体实例指针。</span></span><br><span class="line"><span class="hljs-comment">// 对应这一部分源代码：</span></span><br><span class="line"><span class="hljs-comment">//  static struct __main_block_desc_0 &#123;</span></span><br><span class="line"><span class="hljs-comment">//  size_t reserved;</span></span><br><span class="line"><span class="hljs-comment">//  size_t Block_size;</span></span><br><span class="line"><span class="hljs-comment">//  &#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span></span><br><span class="line"><span class="hljs-comment">//  由此可知，该源代码使用block，即__main_block_impl_0结构体实例的大小进行初始化。</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> <span class="hljs-title">tmp</span> = __<span class="hljs-title">main_block_impl_0</span>(__<span class="hljs-title">main_block_func_0</span>,&amp;__<span class="hljs-title">main_block_desc_0_DATA</span>);</span><span class="hljs-comment">//这里调用的是__main_block_impl_0的构造函数</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> *<span class="hljs-title">blk</span> = &amp;<span class="hljs-title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//这就是简单地使用函数指针调用函数，FuncPtr函数传入的参数__cself,这里为blk，所以也证明了__cself指向block自身。把blc传给FuncPtr，为了就是在FuncPtr里面调用block</span></span><br><span class="line">blk-&gt;FuncPtr(blk);</span><br></pre></td></tr></table></figure><p>结论：<code>block</code>是指向<code>结构体</code>的<code>指针</code>，又因为该结构体含有<code>isa指针</code>，所以，可以说<code>block</code>本质就是<code>OC对象</code>。</p><h2 id="block变量捕获机制"><a href="#block变量捕获机制" class="headerlink" title="block变量捕获机制"></a>block变量捕获机制</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">int</span> dmy = <span class="hljs-number">256</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> val = <span class="hljs-number">10</span>;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt = <span class="hljs-string">"val = %d\n"</span>;</span><br><span class="line">    <span class="hljs-keyword">void</span> (^blk)(<span class="hljs-keyword">void</span>) = ^&#123;<span class="hljs-built_in">printf</span>(fmt,val);&#125;;</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面截获变量值的 源代码通过clang进行转换：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span></span><br><span class="line">  <span class="hljs-comment">/*block语法表达式中使用的自动变量被作为成员变量追加到了__main_block_impl_0结构体中：fmt、val没有使用的局部变量不会被追加*/</span></span><br><span class="line">  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt;</span><br><span class="line">  <span class="hljs-keyword">int</span> val;</span><br><span class="line">  <span class="hljs-comment">/*在初始化结构体实例时，根据传递给构造函数的参数对由自动变量追加的成员变量进行初始化。由此可知，在__main_block_impl_0结构体实例中，自动变量值被截获*/</span></span><br><span class="line">  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *_fmt, <span class="hljs-keyword">int</span> _val, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : fmt(_fmt), val(_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="hljs-comment">//bound by copy这里的注释表示，block对它引用的局部变量做了只读拷贝，也就是说block引用的是局部变量的副本。所以在执行block语法后，即使改写block中使用的局部变量的值也不会影响block执行时局部变量的值。</span></span><br><span class="line">  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt = __cself-&gt;fmt; <span class="hljs-comment">// bound by copy</span></span><br><span class="line">  <span class="hljs-keyword">int</span> val = __cself-&gt;val; <span class="hljs-comment">// bound by copy</span></span><br><span class="line">  <span class="hljs-built_in">printf</span>(fmt,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">size_t</span> reserved;</span><br><span class="line">  <span class="hljs-keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> dmy = <span class="hljs-number">256</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> val = <span class="hljs-number">10</span>;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt = <span class="hljs-string">"val = %d\n"</span>;</span><br><span class="line">    <span class="hljs-keyword">void</span> (*blk)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val));</span><br><span class="line"></span><br><span class="line">    ((<span class="hljs-keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，所谓“截获自动变量值”意味着在执行block语法时，block语法表达式所使用的自动变量值来保存到block的结构体实例中。</p><p>另外需要注意的是，block不能直接使用C语言数组类型的自动变量。为什么呢？因为block截获自动变量时，是通过将值传递给结构体的构造函数进行保存。因为c语言不允许这种赋值</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">char</span> a[<span class="hljs-number">10</span>])</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">char</span> b[<span class="hljs-number">10</span>] = a;<span class="hljs-comment">//此处报错：Array initializer must be an initializer or string literal</span></span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,b[<span class="hljs-number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="block说明符"><a href="#block说明符" class="headerlink" title="__block说明符"></a>__block说明符</h2><p>再来回顾前面截获自动变量值得例子</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^&#123;<span class="hljs-built_in">printf</span>(fmt,val);&#125;</span><br></pre></td></tr></table></figure><p>该源代码转换如下</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt = __cself-&gt;fmt; <span class="hljs-comment">// bound by copy</span></span><br><span class="line">  <span class="hljs-keyword">int</span> val = __cself-&gt;val; <span class="hljs-comment">// bound by copy</span></span><br><span class="line">  <span class="hljs-built_in">printf</span>(fmt,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>block中所使用的被截获自动变量就如“带有自动变量值的匿名函数”所说，仅截获自动变量。block中使用自动变量后，在block的结构体实例中重写该自动变量也不会改变原先截获的自动变量。</p><p>如果在block中修改截获自动变量的值会产生编译错误，因为在实现上不能改写截获自动变量的值。</p><p>解决这种问题有两个方法。</p><h3 id="第一种：C语言中有几种变量允许block改写值："><a href="#第一种：C语言中有几种变量允许block改写值：" class="headerlink" title="第一种：C语言中有几种变量允许block改写值："></a>第一种：C语言中有几种变量允许block改写值：</h3><ul><li>静态局部变量</li><li>静态全局变量</li><li>全局变量</li></ul><p>虽然block语法的匿名函数部分简单地变换为了c语言函数，但从这个变换的函数中访问静态全局变量/全局变量并没有任何改变，可直接使用。但是静态局部变量的情况下，转换后的函数原本就设置在含有block语法的函数外面，所以无法在变量作用域访问。</p><p>看一下下面的代码：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> global_val = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> static_global_val = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> static_val = <span class="hljs-number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">void</span> (^blk)(<span class="hljs-keyword">void</span>) = ^&#123;</span><br><span class="line">        global_val *= <span class="hljs-number">1</span>;</span><br><span class="line">        static_global_val *= <span class="hljs-number">2</span>;</span><br><span class="line">        static_val *= <span class="hljs-number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码转换后如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> global_val = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> static_global_val = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span></span><br><span class="line">  <span class="hljs-comment">//将静态局部变量的地址作为成员变量保存</span></span><br><span class="line">  <span class="hljs-keyword">int</span> *static_val;</span><br><span class="line">  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="hljs-keyword">int</span> *_static_val, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : static_val(_static_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> *static_val = __cself-&gt;static_val; <span class="hljs-comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">  global_val *= <span class="hljs-number">1</span>;</span><br><span class="line">  static_global_val *= <span class="hljs-number">2</span>;</span><br><span class="line">  (*static_val) *= <span class="hljs-number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">size_t</span> reserved;</span><br><span class="line">  <span class="hljs-keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> static_val = <span class="hljs-number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">void</span> (*blk)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val));</span><br><span class="line"></span><br><span class="line">    ((<span class="hljs-keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过转换后的代码可以得知，对静态全局变量和全局变量的访问与转换前完全相同，因为他们是全局变量，不管在哪里都可以访问到，没有作用域的限制。但是对于静态局部变量，为什么要使用指针来访问呢？</p><p>因为静态局部变量在其所在函数结束后，是仍然存在的（自动变量在函数结束后就不存在），但又因为在其他函数中无法引用到该静态局部变量，所以通过将静态局部变量的指针传递给block结构体的构造函数并作为成员变量保存，是超出作用域使用静态局部变量的最简单方法。</p><p>静态局部变量的这种方法也适用于自动变量的访问。但是我们为什么没有这么做呢？因为前面已经提到了，在变量作用域结束的同时，静态局部变量没有被废弃，而自动变量被废弃掉了，所以将不能通过指针访问原来的自动变量。</p><h3 id="第二种方法是使用”-block说明符”"><a href="#第二种方法是使用”-block说明符”" class="headerlink" title="第二种方法是使用”__block说明符”"></a>第二种方法是使用”__block说明符”</h3><p>”<code>__block</code>说明符“,更准确的表述方式为”__block存储域类说明符”。</p><p>下面是使用__block修饰自动变量的代码：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    __block <span class="hljs-keyword">int</span> val = <span class="hljs-number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">void</span> (^blk)(<span class="hljs-keyword">void</span>) = ^ &#123;</span><br><span class="line">        val = <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码变换后如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">Block_byref_val_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">void</span> *__isa;</span><br><span class="line">  __Block_byref_val_0 *__forwarding;</span><br><span class="line">  <span class="hljs-keyword">int</span> __flags;</span><br><span class="line">  <span class="hljs-keyword">int</span> __size;</span><br><span class="line">  <span class="hljs-keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span></span><br><span class="line">  __Block_byref_val_0 *val; <span class="hljs-comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    </span><br><span class="line">    __Block_byref_val_0 *val = __cself-&gt;val; <span class="hljs-comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">    (val-&gt;__forwarding-&gt;val) = <span class="hljs-number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((<span class="hljs-keyword">void</span>*)&amp;dst-&gt;val, (<span class="hljs-keyword">void</span>*)src-&gt;val, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="hljs-keyword">void</span>*)src-&gt;val, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">size_t</span> reserved;</span><br><span class="line">  <span class="hljs-keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="hljs-keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="hljs-keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(__Block_byref_val_0), <span class="hljs-number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">void</span> (*blk)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="hljs-number">570425344</span>));</span><br><span class="line">    ((<span class="hljs-keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是在自动变量上附加了__block说明符，源代码量就急剧增加。</p><p>__block修饰的val变量</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="hljs-keyword">int</span> val = <span class="hljs-number">10</span>;</span><br></pre></td></tr></table></figure><p>，转换成了：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">Block_byref_val_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">void</span> *__isa;</span><br><span class="line">  __Block_byref_val_0 *__forwarding;</span><br><span class="line">  <span class="hljs-keyword">int</span> __flags;</span><br><span class="line">  <span class="hljs-keyword">int</span> __size;</span><br><span class="line">  <span class="hljs-keyword">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里能够发现，__block修饰的自动变量也同block一样变成了__Block_byref_val<em>0结构体类型的自动变量，即栈上生成的\</em>_Block_byref_val_0结构体实例。</p><p>再来看一下__block变量赋值的代码：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ &#123;</span><br><span class="line">       val = <span class="hljs-number">1</span>;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>该源代码转换如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    </span><br><span class="line">    __Block_byref_val_0 *val = __cself-&gt;val; <span class="hljs-comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">    (val-&gt;__forwarding-&gt;val) = <span class="hljs-number">1</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>block的__main_block_impl<em>0结构体实例持有指向变量的\</em>_Block_byref_bal_0结构体实例的指针。__Block_byref_bal_0结构体实例的成员变量__forwarding持有指向该实例自身的指针。通过成员变量__forwarding访问成员变量val。</p><p>这里会遇到3个问题</p><p>1.为什么_<em>block变量的\</em>_Block_byref_val_0结构体不放在__main_block_impl_0结构体中？</p><p>这样做是为了在多个Block中使用__block变量。达到复用效果，从而节省不必要的空间开销。</p><p>2.block超出变量作用域可存在的理由</p><p>3.__block变量的结构体成员变量__forwarding存在的理由。</p><p>问题2和3，留到下面讲解</p><h2 id="Block存储域"><a href="#Block存储域" class="headerlink" title="Block存储域"></a>Block存储域</h2><p>通过前面的说明可知，block转换为block的结构体类型的自动变量，_<em>block变量转换为\</em>_block变量的结构体类型的自动变量。</p><p>block也是Objective-C对象，block的类有：</p><ul><li>_NSConcreteStackBlock</li><li>_NSConcreteGlobalBlock</li><li>_NSConcreteMallocBlock</li></ul><h3 id="全局block"><a href="#全局block" class="headerlink" title="全局block"></a>全局block</h3><p>特点：应用程序在它就在。</p><ul><li>在记录全局变量的地方写block的时候，block为全局block</li><li>不在书写全局变量的地方，只要不截获自动变量，不管用什么修饰符修饰，都是全局block。</li></ul><p>全局变量全部粗放在静态存储区，在程序开始执行时给全局变量分配存储区，程序执行完毕就释放。它们占据固定的存储单元。</p><h3 id="栈block"><a href="#栈block" class="headerlink" title="栈block"></a>栈block</h3><p>特点：声明周期由系统控制，超出其所在作用域即销毁。</p><p>截获自动变量且没有强指针引用的时候，为栈block。栈block因为存储在栈上，所以在超出其作用域时被销毁，不会存在了。</p><p>在ARC下。会默认添加__strong修饰符，所以很少会出现栈block。</p><p>大多数情况编译器会会在适当的地方添加修饰，把block从栈复制到堆，比如将block作为函数返回值时。不过在此之外的情况下需要手动生成代码，将block从栈复制到堆上。</p><p>编译器不能进行判断是什么样的状况呢？如下所示：</p><ul><li>向方法或函数的参数中传递block时</li></ul><p>但是如果在方法或函数内部适当地复制了传递过来的参数，那么就不必在调用该方法或函数前手动复制了。以下方法或函数不用手动复制：</p><ul><li>Cocoa框架的方法且方法名中含有usingBlock等时</li><li>GCD的api</li></ul><p>以下两个例子在ARC下都为栈block：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (id)getBlockArray &#123;</span><br><span class="line">    int val = 10;</span><br><span class="line">    return [[NSArrary alloc] initWithObjects:</span><br><span class="line">            ^&#123;NSLog(@&quot;blk0:%d&quot;,val);&#125;,</span><br><span class="line">            ^&#123;NSLog(@&quot;blk0:%d&quot;,val);&#125;,</span><br><span class="line">            nil</span><br><span class="line">           ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//栈block</span><br><span class="line">int i = 0;</span><br><span class="line">NSLog(@&quot;%@&quot;,^&#123;NSLog(@&quot;%d&quot;,i);&#125;);//输出结果 __NSStackBlock__: 0x7fff57aada78&gt;</span><br></pre></td></tr></table></figure><h3 id="堆block"><a href="#堆block" class="headerlink" title="堆block"></a>堆block</h3><p>特点：没有强指针引用即销毁，生命周期由程序员手动管理</p><p>栈block有强指针strong/copy引用就会被copy到堆中，变成堆block</p><p>通过对着3类block的解释，也解释了为什么block在超出其作用域仍然可以存在。</p><h2 id="block变量存储域"><a href="#block变量存储域" class="headerlink" title="__block变量存储域"></a>__block变量存储域</h2><p>block从栈复制到堆时对__block变量产生的影响：</p><table><thead><tr><th>__block变量的配置存储域</th><th>block从栈复制到堆时的影响</th></tr></thead><tbody><tr><td>栈</td><td>从栈复制到堆并被block持有</td></tr><tr><td>堆</td><td>被block持有</td></tr></tbody></table><p>在一个block中使用_<em>block变量，则当该block从栈复制到堆时，使用的所有\</em>_block变量也必定配置在栈上。这些__block变量也全部从栈复制到对上。此时block持有__block变量。即使在该block已复制到堆的情况下，复制Block也对所使用的__block变量没有任何影响。</p><p>在多个block中使用__block变量，因为最先会将所有的block配置在栈上，所以__block变量也会配置在栈上。在任何一个block从栈复制到堆时，__block变量也会一并从栈复制到堆并被该block所持有。当剩下的block从栈复制到堆时，被复制的block持有__block变量，并增加__block变量的引用计数。</p><p>如果配置在堆上的block被废弃，那么它会释放所持有的_<em>block变量，当该\</em>_block变量没有持有者时，就会释放。</p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/block1.jpg" alt="IMG_49827612A50D-1"></p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/block2.jpg" alt="01522122826_.pic_h"></p><p>到这里我们可以看出，此思考方式与OC的引用计数内存管理完全相同。</p><p>看如下源代码：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    __block <span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//在arc下，不用copy就可以了。因为默认会有__strong修饰符</span></span><br><span class="line">    <span class="hljs-keyword">void</span> (^blk)(<span class="hljs-keyword">void</span>) = [^&#123;++val;&#125; copy];</span><br><span class="line">    </span><br><span class="line">    ++val;</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">    <span class="hljs-comment">//打印结果为2。说明栈上的val结构体，和堆上的val结构体，指向同一块内存地址。为什么呢？下面会给出答案。</span></span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span></span><br><span class="line">  __Block_byref_val_0 *val; <span class="hljs-comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="hljs-comment">// bound by ref</span></span><br><span class="line">  ++(val-&gt;__forwarding-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="hljs-keyword">void</span>*)&amp;dst-&gt;val, (<span class="hljs-keyword">void</span>*)src-&gt;val, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="hljs-keyword">void</span>*)src-&gt;val, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">size_t</span> reserved;</span><br><span class="line">  <span class="hljs-keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="hljs-keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="hljs-keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//只留下main函数，其他部分这里省略</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(__Block_byref_val_0), <span class="hljs-number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">void</span> (*blk)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="hljs-number">570425344</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//注意这里！</span></span><br><span class="line">    ++(val.__forwarding-&gt;val);</span><br><span class="line">    </span><br><span class="line">    ((<span class="hljs-keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,(val.__forwarding-&gt;val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述源代码中，利用copy方法复制使用了_<em>block变量的block，block和\</em>_block变量两者均从栈复制到了堆上。代码中有两处使用到了val，一处是在block的匿名函数里，使用的是堆上的val，另一处是复制前栈上的__block变量的结构体实例的地址。</p><p>那是如何保证，不管__block变量是配置在栈上还是堆上，都能够正确的访问该变量呢？</p><p><strong>因为栈上的_<em>block变量用结构体实例在\</em>_block变量从栈复制到堆上时，会将成员变量__forwarding的值替换为复制目标上的__block变量结构体实例的地址。所以就算使用栈上的__block变量。访问的其实还是堆上的那个。</strong>如下图所示：</p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/block3.jpg" alt="mage-20180327152425"></p><p>通过该功能，无论是在block语法中、block语法外使用_<em>block变量，还是\</em>_block变量配置在栈上或堆上，都可以顺利地访问同一个__block变量。</p><h2 id="截获对象"><a href="#截获对象" class="headerlink" title="截获对象"></a>截获对象</h2><p>来看一下在block语法中使用对象的语法：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">blk_t blk;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">NSMutableArray</span> *array = [[<span class="hljs-built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    blk = ^(<span class="hljs-keyword">id</span> obj) &#123;</span><br><span class="line">        [array addObject:obj];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">blk([<span class="hljs-built_in">NSObject</span> new]);</span><br><span class="line">blk([<span class="hljs-built_in">NSObject</span> new]);</span><br><span class="line">blk([<span class="hljs-built_in">NSObject</span> new]);</span><br></pre></td></tr></table></figure><p>变量作用域结束的同时，变量array被废弃，其强引用失效，因此赋值给变量的array的NSMutableArray类的对象必定被释放并废弃。但是上述代码能够运行正常。这一结果意味着赋值给变量array的NSMutableArray类的对象在该源代码最后block的执行部分超出其作用域而存在。通过编译转换后的代码如下：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-keyword">blk_t</span>)</span><span class="hljs-params">(id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span></span><br><span class="line">  id <span class="hljs-built_in">array</span>;<span class="hljs-comment">//这里是在arc环境下，默认有__strong修饰符。强引用</span></span><br><span class="line">  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, id _array, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : <span class="hljs-built_in">array</span>(_array) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself, id obj) &#123;</span><br><span class="line">  id <span class="hljs-built_in">array</span> = __cself-&gt;<span class="hljs-built_in">array</span>; <span class="hljs-comment">// bound by copy</span></span><br><span class="line">  ((<span class="hljs-keyword">void</span> (*)(id, SEL, ObjectType))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)<span class="hljs-built_in">array</span>, sel_registerName(<span class="hljs-string">"addObject:"</span>), (id)obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="hljs-keyword">void</span>*)&amp;dst-&gt;<span class="hljs-built_in">array</span>, (<span class="hljs-keyword">void</span>*)src-&gt;<span class="hljs-built_in">array</span>, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="hljs-keyword">void</span>*)src-&gt;<span class="hljs-built_in">array</span>, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">size_t</span> reserved;</span><br><span class="line">  <span class="hljs-keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="hljs-keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="hljs-keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/* @autoreleasepool */</span></span><br><span class="line">    &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">     </span><br><span class="line">     <span class="hljs-keyword">blk_t</span> blk;</span><br><span class="line">     </span><br><span class="line">        &#123;</span><br><span class="line">            id <span class="hljs-built_in">array</span> = ((NSMutableArray *(*)(id, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)((NSMutableArray *(*)(id, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="hljs-string">"NSMutableArray"</span>), sel_registerName(<span class="hljs-string">"alloc"</span>)), sel_registerName(<span class="hljs-string">"init"</span>));</span><br><span class="line"></span><br><span class="line">            blk = ((<span class="hljs-keyword">void</span> (*)(id))&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, <span class="hljs-built_in">array</span>, <span class="hljs-number">570425344</span>));</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="hljs-comment">//(*blk-&gt;impl.FuncPtr)(blk, [NSObject new]);</span></span><br><span class="line">        ((<span class="hljs-keyword">void</span> (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSObject *(*)(id, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="hljs-string">"NSObject"</span>), sel_registerName(<span class="hljs-string">"new"</span>)));</span><br><span class="line">        ((<span class="hljs-keyword">void</span> (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSObject *(*)(id, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="hljs-string">"NSObject"</span>), sel_registerName(<span class="hljs-string">"new"</span>)));</span><br><span class="line">        ((<span class="hljs-keyword">void</span> (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSObject *(*)(id, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="hljs-string">"NSObject"</span>), sel_registerName(<span class="hljs-string">"new"</span>)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意被赋值NSMutableArray对象并被截获的自动变量array。我们可以发现，它是block结构体中的成员变量：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span></span><br><span class="line">    <span class="hljs-comment">//注意这里</span></span><br><span class="line">  id __strong <span class="hljs-built_in">array</span>;</span><br><span class="line">    </span><br><span class="line">  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, id _array, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : <span class="hljs-built_in">array</span>(_array) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在Objective-C中，C语言结构体不能含有附有_<em>strong修饰符的变量（换句话说：对象型变量不能作为C语言结构体的成员）。因为编译器不知道何时进行C语言结构体的初始化和废弃操作，不能很好地管理内存。但是Objective-C运行时库能够准确把握block从栈复制到堆以及堆上的block被废弃的时机，因此block结构体中即使含有对象型变量，也可以恰当地进行初始化和废弃。为此需要使用\</em>_main_block_desc_0结构体中增加的成员变量copy和dispose（这两个变量都是函数指针，指向函数），以及作为指针赋值给该成员变量的__main_block_copy_0函数和__main_block_dispose_0函数：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((<span class="hljs-keyword">void</span>*)&amp;dst-&gt;<span class="hljs-built_in">array</span>, (<span class="hljs-keyword">void</span>*)src-&gt;<span class="hljs-built_in">array</span>, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src)&#123;</span><br><span class="line">    _Block_object_dispose((<span class="hljs-keyword">void</span>*)src-&gt;<span class="hljs-built_in">array</span>, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察转换后的代码，上面两个函数包括使用指针全部都没有被调用。那么这些函数是从哪儿调用呢？</p><table><thead><tr><th>函数</th><th>调用时机</th></tr></thead><tbody><tr><td>copy函数</td><td>栈上的block复制到堆时</td></tr><tr><td>dispose函数</td><td>堆上的block被废弃时</td></tr></tbody></table><p>那么什么时候栈上的block会复制到堆呢？</p><ul><li>调用block的copy/strong实例方法</li><li>block作为函数返回值返回时</li><li>将block赋值给附有__storng修饰符id类型的类或block类型成员变量时</li><li>在方法中含有usingBlock的Cocoa框架方法或GCD的api中传递block时</li></ul><p>也就是说虽然从源代码来看，在上面这些情况下栈上的block被赋值到堆上，但其实可归结为_Block<em>copy函数被调用时block从栈复制到堆。相对的，在释放复制到堆上的block后，谁都不持有block而使其被废弃时调用disopose函数。这相当于对象的dealloc方法。有了这种构造，通过使用附有__strong修饰符的自动变量，block中截获的对象就能够超出其变量作用域而存在。虽然这种使用copy函数，dispose函数的方法在之前没有讲解，但实际上在\</em>_block变量中已经用到了。</p><h2 id="block修饰变量和对象"><a href="#block修饰变量和对象" class="headerlink" title="__block修饰变量和对象"></a>__block修饰变量和对象</h2><p><code>__block</code>说明符可指定任何类型的自动变量。下面指定用于赋值Objective-C对象的id类型自动变量。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="hljs-keyword">id</span> obj = [<span class="hljs-built_in">NSObject</span> new];</span><br></pre></td></tr></table></figure><p>其代码等同于：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="hljs-keyword">id</span> __<span class="hljs-keyword">strong</span> obj = [<span class="hljs-built_in">NSObject</span> new];</span><br></pre></td></tr></table></figure><p>改代码可通过clang转换如下：</p><p>在_<em>block变量为附有\</em>_strong修饰符的id类型或对象类型自动变量的情况下会发生同样的过程。当__block变量从栈复制到堆上时，使用_Block_object_assign函数，持有赋值给__block变量的对象。当堆上的__block变量被废弃时，则使用_Block_object_dispose函数释放赋值给__block变量的对象。</p><p>如果__block和__weak一起使用，则block不会被持有，所以不起作用。__block不能和__autoreleasing一起使用，会编译错误。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>block截获自动变量时不管截获的自动变量是对象类型还是基本类型，都会在block结构体内部建立一个成员变量进行存储，数据类型与与截获的自动变量数据类型相同。</li></ol><p>为什么不能修改截获的自动变量？</p><ul><li>对于值类型，是简单的值传递。（为什么不直接传递指针呢？因为值类型保存在栈上，就算传递了指针，值类型在函数结束后就销毁了。所以传递指针也没有意义。）</li><li>对于对象类型是指针浅复制（浅拷贝就是拷贝指向原来对象的指针，使原对象的引用计数+1，可以理解为创建了一个指向原对象的新指针而已，并没有创建一个全新的对象。所以我们可以通过复制后的变量修改这份内存，但是不能修改外部自动变量使其指向另一块内存区域）。</li></ul><ol><li><p>为什么使用__block后就可以修改截获的自动变量？</p><p>被修饰了_<em>block的自动变量不管是基本类型还是对象类型都会被封装到一个结构体类型变量中，表面上看到的是block截获的是自动变量，其实是这个结构体类型变量的指针，因此可以修改自动变量。并且当block从栈上复制到堆上时，栈上的\</em>_block修饰的自动变量的结构体类型变量的forwarding指针会指向堆上的__block修饰的自动变量的结构体类型变量。所以不管是在栈上还是堆上，在block内还是在block外修改使用__block修饰的自动变量，修改的都是同一块内存区域。</p></li></ol><blockquote><p>参考：</p><p><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00DE60G3S" target="_blank" rel="noopener">《Objective-C高级编程:iOS与OS X多线程和内存管理》</a></p><p><a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="noopener">《谈Objective-C block的实现-唐巧》</a></p><p><a href="http://www.desgard.com/iOS-Source-Probe/Objective-C/Runtime/%E6%B5%85%E8%B0%88%20block%EF%BC%882%EF%BC%89%20-%20%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F%E6%96%B9%E5%BC%8F.html" target="_blank" rel="noopener">《浅谈 block - 截获变量方式》</a></p><p><a href="https://www.cnblogs.com/acBool/p/5146639.html" target="_blank" rel="noopener">《iOS中的深复制与浅复制》</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;block的本质&quot;&gt;&lt;a href=&quot;#block的本质&quot; class=&quot;headerlink&quot; title=&quot;block的本质&quot;&gt;&lt;/a&gt;block的本质&lt;/h2&gt;&lt;p&gt;block看上去是“带有自动变量值的匿名函数”，实际上是作为极普通的C语言源代码来处理的。通过支持Block的编译器，将含有Block语法的源代码转换为一般C语言编译器能够处理的源代码。&lt;/p&gt;
&lt;p&gt;在实际编译时无法转换为我们能够理解的源代码，但clang(LLVM编译器)具有转换为我们可读源代码的功能。通过“-rewrite-objc”选项就能将含有Block语法的源代码转换为C++代码。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.wuqihan.cn/categories/iOS/"/>
    
      <category term="Objective-C底层原理" scheme="http://www.wuqihan.cn/categories/iOS/Objective-C%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Block" scheme="http://www.wuqihan.cn/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>macOS、Darwin、XNU</title>
    <link href="http://www.wuqihan.cn/2017/11/05/macOS%E3%80%81Darwin%E3%80%81XNU/"/>
    <id>http://www.wuqihan.cn/2017/11/05/macOS、Darwin、XNU/</id>
    <published>2017-11-05T14:19:09.000Z</published>
    <updated>2019-11-05T14:31:59.263Z</updated>
    
    <content type="html"><![CDATA[<p>OS X is the platform, Darwin is the operating system, and XNU is the kernel. Namely, the XNU kernel is the core piece of software that provides resource management, hardware abstraction, and scheduling. Darwin consists of the XNU kernel and basic software run by there kernel to provide a UNIX environment. OS X is built atop Darwin and provides a collection of frameworks and services that implement the user interface and main application libraries. Darwin and XNU are open source software, but the frameworks that make up the OS X platform on top of Darwin, are not.</p><a id="more"></a><blockquote><p>引用自：<a href="https://www.quora.com/Whats-the-difference-between-Mac-OS-X-Darwin-OS-and-a-popular-Linux-distribution-like-Ubuntu-What-can-be-done-on-Darwin" target="_blank" rel="noopener">https://www.quora.com/Whats-the-difference-between-Mac-OS-X-Darwin-OS-and-a-popular-Linux-distribution-like-Ubuntu-What-can-be-done-on-Darwin</a></p><p>这里说的OS X，就是macOS，在10.12版本开始(2016年)，苹果OS X正式改名为macOS。</p></blockquote><p>maxOS/iOS是平台，Darwin是操作系统，XNU是内核。即，XNU内核是提供资源管理，硬件抽象和调度的核心软件。Darwin由XNU内核和由该内核运行的基本软件组成，以提供UNIX环境。macOS和iOS都是构建在Darwin之上，并提供了实现用户界面和主要应用程序库的框架和服务的集合。Darwin和XNU是开源软件，但基于Darwin之上的macOS/iOS平台的框架是闭源的。</p><p><img src="https://i.loli.net/2019/11/05/atdEfhUTZMD2JXw.png" alt="Mac_OS_X_architecture.png"></p><blockquote><p>推荐阅读：</p><p><a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/Architecture/Architecture.html" target="_blank" rel="noopener">Apple Kernel Programming</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OS X is the platform, Darwin is the operating system, and XNU is the kernel. Namely, the XNU kernel is the core piece of software that provides resource management, hardware abstraction, and scheduling. Darwin consists of the XNU kernel and basic software run by there kernel to provide a UNIX environment. OS X is built atop Darwin and provides a collection of frameworks and services that implement the user interface and main application libraries. Darwin and XNU are open source software, but the frameworks that make up the OS X platform on top of Darwin, are not.&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wuqihan.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="操作系统" scheme="http://www.wuqihan.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Darwin" scheme="http://www.wuqihan.cn/tags/Darwin/"/>
    
      <category term="macOS" scheme="http://www.wuqihan.cn/tags/macOS/"/>
    
      <category term="XNU" scheme="http://www.wuqihan.cn/tags/XNU/"/>
    
  </entry>
  
  <entry>
    <title>如何继承类簇（例如NSString）</title>
    <link href="http://www.wuqihan.cn/2017/05/15/%E5%A6%82%E4%BD%95%E7%BB%A7%E6%89%BF%E7%B1%BB%E7%B0%87/"/>
    <id>http://www.wuqihan.cn/2017/05/15/如何继承类簇/</id>
    <published>2017-05-15T08:51:53.000Z</published>
    <updated>2018-08-18T03:09:24.799Z</updated>
    
    <content type="html"><![CDATA[<p>在今天之前 如果有人问我 如果给NSString添加一个方法 ，我最先想到的方法肯定就是使用Category。一直觉得NSString是不能被继承的，因为它是类簇，其实如果真的想继承，也是有办法的。<br>        在Cocoa框架里有许多类簇，比如NSArray，NSString，NSNumber（具体什么是类簇就不解释了。网上关于类簇的介绍很多）。</p><p>具体关于如何为类簇添加子类，需要遵守几条规则：</p><blockquote><ol><li>子类应该继承自类簇中的抽象基类。</li><li>子类应该自定义自己的数据存储方式。（开发者编写NSArray子类时，必须用一个实例变量来存放数组中的对象。这似乎与大家预想的不同，我们以为NSArray自己肯定会保存那些对象，所以在子类中就无须再保存一份了。但是大家要记住，NSArray本身只不过是包在其他隐藏对象外面的壳，它仅仅定义了所有数组都需具备的一些接口。对于这个自定义的数组类来说，可以用NSArray来保存其实例）。</li><li>子类应当覆写超类文档中指明需要覆写的方法。</li></ol></blockquote><a id="more"></a><p>接下来就动手实现如何继承NSArray 和 NSString。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">"WUArray.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">WUArray</span>()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">NSArray</span> *_storeArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">WUArray</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">instancetype</span>)initWithArray:(<span class="hljs-built_in">NSArray</span> *)array &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) &#123;</span><br><span class="line">        _storeArray = [<span class="hljs-built_in">NSArray</span> arrayWithArray:array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#pragma mark - override</span></span><br><span class="line">- (<span class="hljs-built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> _storeArray.count;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="hljs-keyword">id</span>)objectAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> [_storeArray objectAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><p>######以上为WUArray.m文件</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">"WUString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">WUString</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">NSString</span> *_storeString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">WUString</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">instancetype</span>)initWithString:(<span class="hljs-built_in">NSString</span> *)aString &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">self</span> init]) &#123;</span><br><span class="line">        _storeString = [[<span class="hljs-built_in">NSString</span> stringWithString:aString] <span class="hljs-keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-built_in">NSUInteger</span>)length &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> [_storeString length];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">unichar</span>)characterAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> [_storeString characterAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><p>######以上为WUString.m 文件</p><p>实现完之后 来验证一下：<br><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WUString *str = [[WUString alloc] initWithString:<span class="hljs-string">@"123456789"</span>];</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,[str substringFromIndex:<span class="hljs-number">5</span>]); <span class="hljs-comment">//控制台打印输出为 6789</span></span><br><span class="line">    </span><br><span class="line">    WUArray *array = [[WUArray alloc] initWithArray:@[<span class="hljs-string">@"h"</span>,<span class="hljs-string">@"e"</span>,<span class="hljs-string">@"l"</span>,<span class="hljs-string">@"l"</span>,<span class="hljs-string">@"0"</span>]];</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,[array componentsJoinedByString:<span class="hljs-string">@"."</span>]); <span class="hljs-comment">//控制台打印输出为 h.e.l.l.o</span></span><br></pre></td></tr></table></figure></p><p>在继承的时候 关于要具体覆写超类的哪几个方法，NSString的头文件里面写的有：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* NSString primitives. A minimal subclass of NSString just needs to implement these two, along with an init method appropriate for that subclass. We also recommend overriding getCharacters:range: for performance.</span><br><span class="line"> */</span><br><span class="line">@property (readonly) NSUInteger length;</span><br><span class="line">- (unichar)characterAtIndex:(NSUInteger)index;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在今天之前 如果有人问我 如果给NSString添加一个方法 ，我最先想到的方法肯定就是使用Category。一直觉得NSString是不能被继承的，因为它是类簇，其实如果真的想继承，也是有办法的。&lt;br&gt;        在Cocoa框架里有许多类簇，比如NSArray，NSString，NSNumber（具体什么是类簇就不解释了。网上关于类簇的介绍很多）。&lt;/p&gt;
&lt;p&gt;具体关于如何为类簇添加子类，需要遵守几条规则：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;子类应该继承自类簇中的抽象基类。&lt;/li&gt;
&lt;li&gt;子类应该自定义自己的数据存储方式。（开发者编写NSArray子类时，必须用一个实例变量来存放数组中的对象。这似乎与大家预想的不同，我们以为NSArray自己肯定会保存那些对象，所以在子类中就无须再保存一份了。但是大家要记住，NSArray本身只不过是包在其他隐藏对象外面的壳，它仅仅定义了所有数组都需具备的一些接口。对于这个自定义的数组类来说，可以用NSArray来保存其实例）。&lt;/li&gt;
&lt;li&gt;子类应当覆写超类文档中指明需要覆写的方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RAC(四)信号高阶操作</title>
    <link href="http://www.wuqihan.cn/2017/03/10/RAC-%E5%9B%9B-%E4%BF%A1%E5%8F%B7%E9%AB%98%E9%98%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.wuqihan.cn/2017/03/10/RAC-四-信号高阶操作/</id>
    <published>2017-03-10T06:42:50.000Z</published>
    <updated>2019-07-11T13:36:31.609Z</updated>
    
    <content type="html"><![CDATA[<h3 id="高阶信号"><a href="#高阶信号" class="headerlink" title="高阶信号"></a>高阶信号</h3><p>对数组的操作可以有二维数组，多维数组。同样，信号也是可以嵌套的，经常会遇到二维信号，也就是信号中发送的值也为信号。</p><a id="more"></a><h4 id="升阶和降阶"><a href="#升阶和降阶" class="headerlink" title="升阶和降阶"></a>升阶和降阶</h4><p><strong>(下图菱形图例代表信号，圆圈代表值)</strong></p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac4_1.jpg" alt="image-20180418143626144"></p><h4 id="创建高阶信号"><a href="#创建高阶信号" class="headerlink" title="创建高阶信号"></a>创建高阶信号</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSiganl *siganl = [RACSignal <span class="hljs-keyword">return</span>:@<span class="hljs-number">1</span>];</span><br><span class="line"></span><br><span class="line">RACSiganl *signalHighOrder = [RACSiganl <span class="hljs-keyword">return</span>:signal];</span><br><span class="line">RACSiganl *anotherSignal = [signal map:^<span class="hljs-keyword">id</span>(<span class="hljs-keyword">id</span> value) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> [RACSignal <span class="hljs-keyword">return</span>:value];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="订阅高级信号"><a href="#订阅高级信号" class="headerlink" title="订阅高级信号"></a>订阅高级信号</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSiganl *siganl = @[@<span class="hljs-number">1</span>,@<span class="hljs-number">2</span>,@<span class="hljs-number">3</span>].rac_sequence.signal;</span><br><span class="line">RACSignal *highOrderSignal = [signal map:^<span class="hljs-keyword">id</span>(RACSiganl *aSiganl) &#123;</span><br><span class="line">    [aSignal subscribeNext:^(<span class="hljs-keyword">id</span> x) &#123;</span><br><span class="line">        <span class="hljs-comment">//...</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="降阶操作"><a href="#降阶操作" class="headerlink" title="降阶操作"></a>降阶操作</h3><h4 id="SwitchToLatests"><a href="#SwitchToLatests" class="headerlink" title="SwitchToLatests"></a>SwitchToLatests</h4><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac4_2.jpg" alt="image-20180418144538812"></p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac4_3.jpg" alt="image-20180418144441907"></p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac4_4.jpg" alt="image-20180418144546449"></p><p>使用switchToLatests方法降阶时，需要注意的是<strong>新的信号会把旧的信号截断</strong></p><h4 id="if-then-else"><a href="#if-then-else" class="headerlink" title="if/then/else"></a>if/then/else</h4><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac4_5.jpg" alt="image-20180418144726566"></p><p>看一下ifThenElse方法的实现代码，可以很容易理解。它的本质还是使用了SwitchToLatests。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)if:(RACSignal *)boolSignal then:(RACSignal *)trueSignal else:(RACSignal *)falseSignal &#123;</span><br><span class="line">NSCParameterAssert(boolSignal != nil);</span><br><span class="line">NSCParameterAssert(trueSignal != nil);</span><br><span class="line">NSCParameterAssert(falseSignal != nil);</span><br><span class="line"></span><br><span class="line">return [[[boolSignal</span><br><span class="line">map:^(NSNumber *value) &#123;</span><br><span class="line">NSCAssert([value isKindOfClass:NSNumber.class], @&quot;Expected %@ to send BOOLs, not %@&quot;, boolSignal, value);</span><br><span class="line"></span><br><span class="line">return (value.boolValue ? trueSignal : falseSignal);</span><br><span class="line">&#125;]</span><br><span class="line">switchToLatest]</span><br><span class="line">setNameWithFormat:@&quot;+if: %@ then: %@ else: %@&quot;, boolSignal, trueSignal, falseSignal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的方法还有SwitchCasesDefaultSignal:</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)<span class="hljs-keyword">switch</span>:(RACSignal *)signal cases:(<span class="hljs-built_in">NSDictionary</span> *)cases <span class="hljs-keyword">default</span>:(RACSignal *)defaultSignal &#123;</span><br><span class="line"><span class="hljs-built_in">NSCParameterAssert</span>(signal != <span class="hljs-literal">nil</span>);</span><br><span class="line"><span class="hljs-built_in">NSCParameterAssert</span>(cases != <span class="hljs-literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">id</span> key <span class="hljs-keyword">in</span> cases) &#123;</span><br><span class="line"><span class="hljs-keyword">id</span> value __attribute__((unused)) = cases[key];</span><br><span class="line"><span class="hljs-built_in">NSCAssert</span>([value isKindOfClass:RACSignal.class], <span class="hljs-string">@"Expected all cases to be RACSignals, %@ isn't"</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">NSDictionary</span> *<span class="hljs-keyword">copy</span> = [cases <span class="hljs-keyword">copy</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> [[[signal</span><br><span class="line">map:^(<span class="hljs-keyword">id</span> key) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (key == <span class="hljs-literal">nil</span>) key = RACTupleNil.tupleNil;</span><br><span class="line"></span><br><span class="line">RACSignal *signal = <span class="hljs-keyword">copy</span>[key] ?: defaultSignal;</span><br><span class="line"><span class="hljs-keyword">if</span> (signal == <span class="hljs-literal">nil</span>) &#123;</span><br><span class="line"><span class="hljs-built_in">NSString</span> *description = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-built_in">NSLocalizedString</span>(<span class="hljs-string">@"No matching signal found for value %@"</span>, <span class="hljs-string">@""</span>), key];</span><br><span class="line"><span class="hljs-keyword">return</span> [RACSignal error:[<span class="hljs-built_in">NSError</span> errorWithDomain:RACSignalErrorDomain code:RACSignalErrorNoMatchingCase userInfo:@&#123; <span class="hljs-built_in">NSLocalizedDescriptionKey</span>: description &#125;]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> signal;</span><br><span class="line">&#125;]</span><br><span class="line">switchToLatest]</span><br><span class="line">setNameWithFormat:<span class="hljs-string">@"+switch: %@ cases: %@ default: %@"</span>, signal, cases, defaultSignal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Flatten"><a href="#Flatten" class="headerlink" title="Flatten"></a>Flatten</h4><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac4_6.jpg" alt="image-20180418144742256"></p><p>flatten与SwitchToLatests不同的是，新的信号不会截断旧的信号。它相当于是使用<strong>**merge:</strong>方法把信号中的所有信号都合并在了一起。</p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac4_7.jpg" alt="image-20180418144755171"></p><p>flatten：这个带参数的方法 的参数类型是NSUInteger。拿上图举例子就是说，当前这个参数为2，那这个值就代表的是当前最多展开的信号，signalA中有4个信号，最多同时展开两个信号。也就是说，首先能够一次订阅前两个信号，如果这里两个信号都没执行完， 就不能订阅第三个，当 前两个信号其中有一个信号结束之后，才会去订阅第三个信号，这样依次类推。 </p><h4 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h4><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac4_8.jpg" alt="image-20180418144801999"></p><p>对于一个返回a信号、b信号的高阶信号调用flatten:1，等价于[a信号 concat:b信号]。</p><p>对于高级信号，也有一个- (RACSIgnal *)concat;方法，就是相当于调用flatten:1</p><h4 id="FlattenMap"><a href="#FlattenMap" class="headerlink" title="FlattenMap"></a>FlattenMap</h4><p>flattenMap就是 先map为高阶信号在调用flatten降阶</p><p>看一下 RACStream.m文件中 flattenMap: 、flatten、map：的实现</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(<span class="hljs-keyword">id</span> value))block &#123;</span><br><span class="line">Class <span class="hljs-keyword">class</span> = <span class="hljs-keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> bind:^&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ^(<span class="hljs-keyword">id</span> value, <span class="hljs-built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="hljs-keyword">id</span> stream = block(value) ?: [<span class="hljs-keyword">class</span> empty];</span><br><span class="line"><span class="hljs-built_in">NSCAssert</span>([stream isKindOfClass:RACStream.class], <span class="hljs-string">@"Value returned from -flattenMap: is not a stream: %@"</span>, stream);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> stream;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="hljs-string">@"[%@] -flattenMap:"</span>, <span class="hljs-keyword">self</span>.name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (__kindof RACStream *)flatten &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> flattenMap:^(<span class="hljs-keyword">id</span> value) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> value;</span><br><span class="line">&#125;] setNameWithFormat:<span class="hljs-string">@"[%@] -flatten"</span>, <span class="hljs-keyword">self</span>.name];</span><br><span class="line">&#125;</span><br><span class="line">- (__kindof RACStream *)map:(<span class="hljs-keyword">id</span> (^)(<span class="hljs-keyword">id</span> value))block &#123;</span><br><span class="line"><span class="hljs-built_in">NSCParameterAssert</span>(block != <span class="hljs-literal">nil</span>);</span><br><span class="line"></span><br><span class="line">Class <span class="hljs-keyword">class</span> = <span class="hljs-keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> flattenMap:^(<span class="hljs-keyword">id</span> value) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> [<span class="hljs-keyword">class</span> <span class="hljs-keyword">return</span>:block(value)];</span><br><span class="line">&#125;] setNameWithFormat:<span class="hljs-string">@"[%@] -map:"</span>, <span class="hljs-keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过看方法的实现，可以看出，flatten和map方法都是基于flattenMap:的，还有filter：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)filter:(<span class="hljs-built_in">BOOL</span> (^)(<span class="hljs-keyword">id</span> value))block &#123;</span><br><span class="line"><span class="hljs-built_in">NSCParameterAssert</span>(block != <span class="hljs-literal">nil</span>);</span><br><span class="line"></span><br><span class="line">Class <span class="hljs-keyword">class</span> = <span class="hljs-keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> flattenMap:^ <span class="hljs-keyword">id</span> (<span class="hljs-keyword">id</span> value) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (block(value)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> [<span class="hljs-keyword">class</span> <span class="hljs-keyword">return</span>:value];</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span>.empty;</span><br><span class="line">&#125;</span><br><span class="line">&#125;] setNameWithFormat:<span class="hljs-string">@"[%@] -filter:"</span>, <span class="hljs-keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看flattenMap方法实现。发现它是基于bind:方法的。RAC中的方法几乎所有都是基于bind方法实现的，它是RAC的核心方法。<strong>这个bind方法感觉比较复杂，我暂时也不太理解，以后再研究</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;高阶信号&quot;&gt;&lt;a href=&quot;#高阶信号&quot; class=&quot;headerlink&quot; title=&quot;高阶信号&quot;&gt;&lt;/a&gt;高阶信号&lt;/h3&gt;&lt;p&gt;对数组的操作可以有二维数组，多维数组。同样，信号也是可以嵌套的，经常会遇到二维信号，也就是信号中发送的值也为信号。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/categories/Objective-C/"/>
    
    
      <category term="ReactiveCocoa" scheme="http://www.wuqihan.cn/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>RAC(三)RACSignal各类操作</title>
    <link href="http://www.wuqihan.cn/2017/01/08/RAC-%E4%B8%89-RACSignal%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.wuqihan.cn/2017/01/08/RAC-三-RACSignal基本使用/</id>
    <published>2017-01-08T05:20:24.000Z</published>
    <updated>2019-07-11T13:40:48.989Z</updated>
    
    <content type="html"><![CDATA[<h3 id="获得一个信号的方式"><a href="#获得一个信号的方式" class="headerlink" title="获得一个信号的方式"></a>获得一个信号的方式</h3><h4 id="单元信号"><a href="#单元信号" class="headerlink" title="单元信号"></a>单元信号</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal <span class="hljs-keyword">return</span>:<span class="hljs-string">@"Some value"</span>];</span><br><span class="line">RACSignal *signal2 = [RACSignal error:errorObject];</span><br><span class="line">RACSignal *signal3 = [RACSignal empty];</span><br><span class="line">RACSignal *signal4 = [RACSignal never];</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="动态信号"><a href="#动态信号" class="headerlink" title="动态信号"></a>动态信号</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal5 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="hljs-keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@<span class="hljs-number">1</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="hljs-number">2</span>];</span><br><span class="line">    [subscriber sendError:errorObject];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="hljs-keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="Cocoa桥接"><a href="#Cocoa桥接" class="headerlink" title="Cocoa桥接"></a>Cocoa桥接</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal6 = [button rac_signalForSelector:<span class="hljs-keyword">@selector</span>(setFrame:)];</span><br><span class="line">RACSignal *signal7 = [button rac_signalForControlEvents:<span class="hljs-built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">RACSignal *signal8 = [button rac_willDeallocSignal];</span><br><span class="line">RACSignal *signal9 = RACObserve(button, backgroundColor);</span><br></pre></td></tr></table></figure><h4 id="信号变换"><a href="#信号变换" class="headerlink" title="信号变换"></a>信号变换</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal10 = [signal1 map:^<span class="hljs-keyword">id</span> _Nullable(<span class="hljs-built_in">NSString</span>*  _Nullable value) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> [value substringFromIndex:<span class="hljs-number">1</span>];</span><br><span class="line">    &#125;]</span><br></pre></td></tr></table></figure><h4 id="序列转换"><a href="#序列转换" class="headerlink" title="序列转换"></a>序列转换</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal11 = [RACSequence <span class="hljs-keyword">return</span>:@<span class="hljs-number">1</span>].signal;</span><br></pre></td></tr></table></figure><h3 id="订阅一个信号的方式"><a href="#订阅一个信号的方式" class="headerlink" title="订阅一个信号的方式"></a>订阅一个信号的方式</h3><p><strong>注意Signal是push-driven(推驱动)</strong></p><h4 id="基本订阅方法-subscribe"><a href="#基本订阅方法-subscribe" class="headerlink" title="基本订阅方法 subscribe"></a>基本订阅方法 subscribe</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[signal1 subscribeNext:^(<span class="hljs-keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,x);</span><br><span class="line">&#125; error:^(<span class="hljs-built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,error);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"complete"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(view,backgroundColor) = signal10;</span><br></pre></td></tr></table></figure><h4 id="Cocoa桥接-1"><a href="#Cocoa桥接-1" class="headerlink" title="Cocoa桥接"></a>Cocoa桥接</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[view rac_liftSelector:<span class="hljs-keyword">@selector</span>(convertPoint:toView:) withSignals:signal1,signal2, <span class="hljs-literal">nil</span>];</span><br><span class="line">[view rac_liftSelector:<span class="hljs-keyword">@selector</span>(convertPoint:toView:) withSignalsFromArray:@[signal1,signal2]];</span><br><span class="line">[view rac_liftSelector:<span class="hljs-keyword">@selector</span>(convertPoint:toView:) withSignalOfArguments:signal5];</span><br></pre></td></tr></table></figure><h3 id="分析订阅过程"><a href="#分析订阅过程" class="headerlink" title="分析订阅过程"></a>分析订阅过程</h3><p>RACSignal的常见用法：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="hljs-comment">// part 1:[RACSignal createSignal]来获得signal</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="hljs-keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// part 3: 进入didSubscribe，通过[subscriber sendNext:]来执行next block</span></span><br><span class="line">        [subscriber sendNext:@<span class="hljs-number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="hljs-number">2</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<span class="hljs-comment">//这里忽略RACDisposable，暂时不讲</span></span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line"><span class="hljs-comment">// part 2 : [signal subscribeNext:]来获得subscriber，然后进行subscription，error和complete不讨论与next一样。（RACSignal里面保存的事件分为3中。一种是值value，一种是error，一种是complete。）</span></span><br><span class="line">    [signal subscribeNext:^(<span class="hljs-keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="hljs-comment">//...</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RACSignal的Subscription过程概括起来可以分为三个步骤：</p><h4 id="步骤一：-RACSignal-createSignal-来获得signal"><a href="#步骤一：-RACSignal-createSignal-来获得signal" class="headerlink" title="步骤一：[RACSignal createSignal]来获得signal"></a>步骤一：[RACSignal createSignal]来获得signal</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//RACSignal.m中：</span></span><br><span class="line">+ ( RACSignal *)createSignal:( RACDisposable * (^)( <span class="hljs-keyword">id</span> &lt; RACSubscriber &gt; subscriber))didSubscribe &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> [ RACDynamicSignal   createSignal :didSubscribe];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//RACDynamicSignal.m中</span></span><br><span class="line">+ ( RACSignal *)createSignal:( RACDisposable * (^)( <span class="hljs-keyword">id</span> &lt; RACSubscriber &gt; subscriber))didSubscribe &#123;</span><br><span class="line">  RACDynamicSignal *signal = [[ <span class="hljs-keyword">self</span>   alloc ] init ];</span><br><span class="line"> signal-&gt; _didSubscribe = [didSubscribe <span class="hljs-keyword">copy</span> ];</span><br><span class="line">  <span class="hljs-keyword">return</span> [signal setNameWithFormat : <span class="hljs-string">@"+createSignal:"</span> ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[RACSignal createSignal]会调用子类RACDynamicSignal的createSignal来返回一个signal，并在signal中保存后面的 didSubscribe这个block</p><h4 id="步骤二：-signal-subscribeNext-来获得subscriber，然后进行subscription"><a href="#步骤二：-signal-subscribeNext-来获得subscriber，然后进行subscription" class="headerlink" title="步骤二：[signal subscribeNext:]来获得subscriber，然后进行subscription"></a>步骤二：[signal subscribeNext:]来获得subscriber，然后进行subscription</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//RACSignal.m中：</span></span><br><span class="line">- ( RACDisposable *)subscribeNext:( <span class="hljs-keyword">void</span> (^)( <span class="hljs-keyword">id</span> x))nextBlock &#123;</span><br><span class="line">  RACSubscriber *o = [ RACSubscriber   subscriberWithNext :nextBlock error : <span class="hljs-literal">NULL</span>   completed : <span class="hljs-literal">NULL</span> ];</span><br><span class="line">  <span class="hljs-keyword">return</span> [ <span class="hljs-keyword">self</span>  subscribe :o];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//RACSubscriber.m中：</span></span><br><span class="line">+ ( <span class="hljs-keyword">instancetype</span> )subscriberWithNext:( <span class="hljs-keyword">void</span> (^)( <span class="hljs-keyword">id</span> x))next error:( <span class="hljs-keyword">void</span> (^)( <span class="hljs-built_in">NSError</span> *error))error completed:( <span class="hljs-keyword">void</span> (^)( <span class="hljs-keyword">void</span> ))completed &#123;</span><br><span class="line">  RACSubscriber *subscriber = [[ <span class="hljs-keyword">self</span>   alloc ] init ];</span><br><span class="line"> subscriber-&gt; _next = [next <span class="hljs-keyword">copy</span> ];</span><br><span class="line"> subscriber-&gt; _error = [error <span class="hljs-keyword">copy</span> ];</span><br><span class="line"> subscriber-&gt; _completed = [completed <span class="hljs-keyword">copy</span> ];</span><br><span class="line">  <span class="hljs-keyword">return</span> subscriber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//RACDynamicSignal.m中：</span></span><br><span class="line">- (RACDisposable *)subscribe:(<span class="hljs-keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">    RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">    subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class="hljs-keyword">self</span> disposable:disposable];</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.didSubscribe != <span class="hljs-literal">NULL</span>) &#123;</span><br><span class="line">        RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">            RACDisposable *innerDisposable = <span class="hljs-keyword">self</span>.didSubscribe(subscriber);</span><br><span class="line">            [disposable addDisposable:innerDisposable];</span><br><span class="line">        &#125;];</span><br><span class="line">        [disposable addDisposable:schedulingDisposable];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>[signal subscribeNext]先会获得一个subscriber，这个subscriber中保存了nextBlock、errorBlock、completedBlock</li><li>由于这个signal其实是RACDynamicSignal类型的，这个[self subscribe]方法会调用步骤一中保存的didSubscribe，参数就是1中的subscriber</li></ol><h4 id="步骤三：进入didSubscribe，通过-subscriber-sendNext-来执行next-block"><a href="#步骤三：进入didSubscribe，通过-subscriber-sendNext-来执行next-block" class="headerlink" title="步骤三：进入didSubscribe，通过[subscriber sendNext:]来执行next block"></a>步骤三：进入didSubscribe，通过[subscriber sendNext:]来执行next block</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//RACSubscriber.m中：</span></span><br><span class="line">- (<span class="hljs-keyword">void</span>)sendNext:(<span class="hljs-keyword">id</span>)value &#123;</span><br><span class="line">    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">void</span> (^nextBlock)(<span class="hljs-keyword">id</span>) = [<span class="hljs-keyword">self</span>.next <span class="hljs-keyword">copy</span>];</span><br><span class="line">        <span class="hljs-keyword">if</span> (nextBlock == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">return</span>;</span><br><span class="line">        nextBlock(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="signal的subscription过程回顾"><a href="#signal的subscription过程回顾" class="headerlink" title="signal的subscription过程回顾"></a>signal的subscription过程回顾</h4><p>从上面的三个步骤，我们看出：</p><ul><li>先通过createSignal和subscribeNext这两个调用，声明了流中value到来时的处理方式</li><li>didSubscribe block块中异步处理完毕之后，subscriber进行sendNext，自动处理</li></ul><h3 id="RACTuple"><a href="#RACTuple" class="headerlink" title="RACTuple"></a>RACTuple</h3><p>RAC定义的一种数据类型。类似Swift中的tuple。这里不多介绍。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RACTuple *tuple = RACTuplePack(@<span class="hljs-number">1</span>,<span class="hljs-string">@"haha"</span>);</span><br><span class="line"><span class="hljs-keyword">id</span> first = tuple.first;</span><br><span class="line"><span class="hljs-keyword">id</span> last = tuple.last;</span><br><span class="line"><span class="hljs-keyword">id</span> idnex1 = tuple[<span class="hljs-number">1</span>];</span><br><span class="line">RACTupleUnpack(<span class="hljs-built_in">NSNumber</span> *num,<span class="hljs-built_in">NSString</span> *str) = tuple;</span><br></pre></td></tr></table></figure><h3 id="RACSignal各类操作"><a href="#RACSignal各类操作" class="headerlink" title="RACSignal各类操作"></a>RACSignal各类操作</h3><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_1.jpg" alt="image-20180418141948795"></p><h4 id="对值操作"><a href="#对值操作" class="headerlink" title="对值操作"></a>对值操作</h4><h5 id="map-mapReplace"><a href="#map-mapReplace" class="headerlink" title="map/mapReplace"></a>map/mapReplace</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_2.jpg" alt="image-20180418142054959"></p><h5 id="reduceEach"><a href="#reduceEach" class="headerlink" title="reduceEach"></a>reduceEach</h5><p>只能用在tuple上。tuple个数少了会挂，多了只去和参数相同的个数。</p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_3.jpg" alt="image-20180418142116897"></p><h5 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_4.jpg" alt="image-20180418142914659"></p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>not/and/or/reduceApply/materialize/dematerialize;</p><h4 id="对数量操作"><a href="#对数量操作" class="headerlink" title="对数量操作"></a>对数量操作</h4><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_5.jpg" alt="image-20180418142238131"></p><h5 id="ignore-ignoreValues-distinctUntilChanged"><a href="#ignore-ignoreValues-distinctUntilChanged" class="headerlink" title="ignore/ignoreValues/distinctUntilChanged"></a>ignore/ignoreValues/distinctUntilChanged</h5><p>这几个根据英文很容易理解</p><h5 id="take"><a href="#take" class="headerlink" title="take"></a>take</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_6.jpg" alt="image-20180418142354763"></p><h5 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_7.jpg" alt="image-20180418142404053"></p><h5 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_8.jpg" alt="image-20180418142450462"></p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_9.jpg" alt="image-20180418142504248"></p><h5 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a>startWith</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_10.jpg" alt="image-20180418142541910"></p><h5 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_11.jpg" alt="image-20180418142600575"></p><h5 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_12.jpg" alt="image-20180418142618562"></p><h5 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_13.jpg" alt="image-20180418142824458"></p><h5 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_14.jpg" alt="image-20180418142845070"></p><h4 id="副作用操作"><a href="#副作用操作" class="headerlink" title="副作用操作"></a>副作用操作</h4><p>doNext</p><h4 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h4><h5 id="Delay"><a href="#Delay" class="headerlink" title="Delay"></a>Delay</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_15.jpg" alt="image-20180418142954495"></p><h5 id="Throttle"><a href="#Throttle" class="headerlink" title="Throttle"></a>Throttle</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_16.jpg" alt="image-20180418143010615"></p><h4 id="组合操作"><a href="#组合操作" class="headerlink" title="组合操作"></a>组合操作</h4><h5 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_17.jpg" alt="image-20180418143043116"></p><h5 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_18.jpg" alt="image-20180418143118995"></p><p>merge用处很多，如下：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *appearSignal = [[<span class="hljs-keyword">self</span> rac_signalForSelector:<span class="hljs-keyword">@selector</span>(viewDidAppear:)]] mapReplace:@YES];</span><br><span class="line">RACSignal *disappearSignal = [[<span class="hljs-keyword">self</span> rac_signalForSelector:<span class="hljs-keyword">@selector</span>(viewWillDisAppear:)]] mapReplace:@NO];</span><br><span class="line">RACSignal *activeSignal = [RACSignal merge:@[appearSignal,disappearSignal]];</span><br></pre></td></tr></table></figure><h5 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_19.jpg" alt="image-20180418143328779"></p><h5 id="CombineLatest"><a href="#CombineLatest" class="headerlink" title="CombineLatest"></a>CombineLatest</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_20.jpg" alt="image-20180418143345994"></p><h5 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_21.jpg" alt="image-20180418143409171"></p><h5 id="TakeUntil"><a href="#TakeUntil" class="headerlink" title="TakeUntil"></a>TakeUntil</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_22.jpg" alt="image-20180418143453317"></p><h5 id="TakeUntilReplacement"><a href="#TakeUntilReplacement" class="headerlink" title="TakeUntilReplacement"></a>TakeUntilReplacement</h5><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac3_23.jpg" alt="image-20180418143511093"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;获得一个信号的方式&quot;&gt;&lt;a href=&quot;#获得一个信号的方式&quot; class=&quot;headerlink&quot; title=&quot;获得一个信号的方式&quot;&gt;&lt;/a&gt;获得一个信号的方式&lt;/h3&gt;&lt;h4 id=&quot;单元信号&quot;&gt;&lt;a href=&quot;#单元信号&quot; class=&quot;headerlink&quot; title=&quot;单元信号&quot;&gt;&lt;/a&gt;单元信号&lt;/h4&gt;&lt;figure class=&quot;highlight objc hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;RACSignal *signal1 = [RACSignal &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;@&quot;Some value&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RACSignal *signal2 = [RACSignal error:errorObject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RACSignal *signal3 = [RACSignal empty];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RACSignal *signal4 = [RACSignal never];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/categories/Objective-C/"/>
    
    
      <category term="ReactiveCocoa" scheme="http://www.wuqihan.cn/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>RAC(二)基础知识</title>
    <link href="http://www.wuqihan.cn/2017/01/01/RAC-%E4%BA%8C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.wuqihan.cn/2017/01/01/RAC-二-基础知识/</id>
    <published>2017-01-01T09:11:36.000Z</published>
    <updated>2019-07-11T13:41:31.691Z</updated>
    
    <content type="html"><![CDATA[<h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ul><li>RACStream RACSequence RACSignal</li><li>RACSubscriber</li><li>RACDisposable</li><li>RACScheduler</li><li>Cocoa框架适配工具</li></ul><a id="more"></a><h3 id="RACStream的两个子类：Sequence-amp-Signal"><a href="#RACStream的两个子类：Sequence-amp-Signal" class="headerlink" title="RACStream的两个子类：Sequence &amp; Signal"></a>RACStream的两个子类：Sequence &amp; Signal</h3><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac2_1.jpg" alt="image-20180414122918648"></p><p>RACStream表示一个数据流的类。这个流不一定是基于时间的，所以它有两个子类RACSequence和RACSignal。</p><ul><li>RACSequence是基于空间的数据流</li><li>RACSignal是基于时间的数据流</li></ul><p>对比RACSequence和RACSignal，基于空间的数据流和基于时间的数据流到底有什么区别？</p><ol><li><p><strong>Sequence是Pull-Driven(拉驱动)，Signal是Push-driven(推驱动)</strong></p><p>pull-driver表示数据的变化是由拉取者决定的。举个简单的例子，sequence就好比一本书，我们看书，想看到哪页就可以翻到哪页去看，看什么内容读取什么数据，是由我们决定，而不是由书（sequence）决定。</p><p>push-driver表示数据的变化是由推送者决定的，与pull-driver刚好相反。可以把Signal比作电视体育直播。看什么内容读取什么数据，是由电视(Signal)决定的，如果我们去上个卫生间也无法暂停体育直播，中间的数据就会错过。</p></li><li><p>Sequence里面可以仅仅存放任何类型的数据。RACSignal里面不仅包含数据，也包含信号的状态（后面会了解到信号状态）。</p></li></ol><h3 id="RACSequence的简单使用"><a href="#RACSequence的简单使用" class="headerlink" title="RACSequence的简单使用"></a>RACSequence的简单使用</h3><p>RACSequence使用的情况很少。这里就简单介绍一下常用方法</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//创建</span></span><br><span class="line">   RACSequence *sequence1 = [RACSequence <span class="hljs-keyword">return</span>:@<span class="hljs-number">1</span>];</span><br><span class="line">   RACSequence *sequence2 = [RACSequence sequenceWithHeadBlock:^<span class="hljs-keyword">id</span> _Nullable&#123;</span><br><span class="line">       <span class="hljs-keyword">return</span> @<span class="hljs-number">2</span>;</span><br><span class="line">   &#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">       <span class="hljs-keyword">return</span> sequence1;</span><br><span class="line">   &#125;];</span><br><span class="line">   RACSequence *sequence3 = @[@<span class="hljs-number">1</span>,@<span class="hljs-number">2</span>,@<span class="hljs-number">3</span>].rac_sequence;</span><br><span class="line">   </span><br><span class="line">   <span class="hljs-comment">//变换</span></span><br><span class="line">   RACSequence *mappedSequence = [sequence1 map:^<span class="hljs-keyword">id</span> _Nullable(<span class="hljs-built_in">NSNumber</span>* value) &#123;</span><br><span class="line">       <span class="hljs-keyword">return</span> @(value.integerValue*<span class="hljs-number">3</span>);</span><br><span class="line">   &#125;];</span><br><span class="line">   RACSequence *concatedSequence = [sequence2 concat:mappedSequence];</span><br><span class="line">   RACSequence *mergerdSequence = [RACSequence zip:@[concatedSequence,sequence3]];</span><br><span class="line">   </span><br><span class="line">   <span class="hljs-comment">//遍历</span></span><br><span class="line">   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,mergerdSequence.head);</span><br><span class="line">   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">id</span> value <span class="hljs-keyword">in</span> mergerdSequence) &#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="RACSignal的简单使用"><a href="#RACSignal的简单使用" class="headerlink" title="RACSignal的简单使用"></a>RACSignal的简单使用</h3><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//创建</span></span><br><span class="line">   RACSignal *signal1 = [RACSignal <span class="hljs-keyword">return</span>:<span class="hljs-string">@"hello"</span>];</span><br><span class="line">   RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="hljs-keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">       [subscriber sendNext:@<span class="hljs-number">1</span>];</span><br><span class="line">       [subscriber sendNext:@<span class="hljs-number">2</span>];</span><br><span class="line">       [subscriber sendCompleted];</span><br><span class="line">       <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;</span><br><span class="line">   &#125;];</span><br><span class="line">   RACSignal *signal3 = RACObserve(<span class="hljs-keyword">self</span>.view, backgroundColor);</span><br><span class="line">   </span><br><span class="line">   <span class="hljs-comment">//变换</span></span><br><span class="line">   RACSignal *mappedSignal = [signal1 map:^<span class="hljs-keyword">id</span> _Nullable(<span class="hljs-built_in">NSString</span>* value) &#123;</span><br><span class="line">       <span class="hljs-keyword">return</span> [value stringByAppendingString:<span class="hljs-string">@" word"</span>];</span><br><span class="line">   &#125;];</span><br><span class="line">   RACSignal *concatedSignal = [mappedSignal concat:signal2];</span><br><span class="line">   RACSignal *mergeSignal = [mappedSignal merge:@[concatedSignal,signal3]];</span><br><span class="line">   </span><br><span class="line">   <span class="hljs-comment">//遍历</span></span><br><span class="line">   [mergeSignal subscribeNext:^(<span class="hljs-keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,x);</span><br><span class="line">   &#125; completed:^&#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"completed"</span>);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure><p>这里仅仅是对RACSignal做初步了解。具体方法到底怎么用。后面的文章会讲到。</p><h3 id="RACSubscriber-amp-RACDisposable"><a href="#RACSubscriber-amp-RACDisposable" class="headerlink" title="RACSubscriber &amp; RACDisposable"></a>RACSubscriber &amp; RACDisposable</h3><p>Subscription(订阅者)表⽰等待或者能够等待信号发送事件的任意对象。在框架中使用RACSubscriber协议表示,也即任意实现了RACSubscriber协议的对象都可以是订阅者。可以通过调⽤ -subscribeNext:error:completed:⽅法来创建订阅。RACStream和RACSignal类的大多操作也会⾃己创建订阅。订阅会对Signals对象引⽤计数加1,当信号发送错误或者完成事件后,会⾃动被处理,不需要⽤户关⼼内存管理。当然,⽤户也可以⼿动处理。</p><p>RACDisposable类⽤于取消订阅或者清理资源。</p><p>下图展示了Subscriber、Disposable、Signal三者的关系</p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/rac2_2.jpg" alt="image-20180414154509246"></p><h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><ul><li>用来做调度</li><li>代替GCD</li><li>异步与并发</li></ul><p>scheduler由RACScheduler类表示,它是信号执行任务时所在的队列(queue)或者信号执⾏完后将结果放到队列⾥执行,可以认为就是gcd⾥的queues。scheduler⽀持取消操作,⽽且它总是串行地执⾏任务。这有利于避免死锁。RACScheduler有时候也类似NSOperationQueue,但它不允许任务间相互依赖。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;核心组件&quot;&gt;&lt;a href=&quot;#核心组件&quot; class=&quot;headerlink&quot; title=&quot;核心组件&quot;&gt;&lt;/a&gt;核心组件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;RACStream RACSequence RACSignal&lt;/li&gt;
&lt;li&gt;RACSubscriber&lt;/li&gt;
&lt;li&gt;RACDisposable&lt;/li&gt;
&lt;li&gt;RACScheduler&lt;/li&gt;
&lt;li&gt;Cocoa框架适配工具&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/categories/Objective-C/"/>
    
    
      <category term="ReactiveCocoa" scheme="http://www.wuqihan.cn/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>RAC(一)函数响应式编程概述</title>
    <link href="http://www.wuqihan.cn/2016/12/14/RAC-%E4%B8%80-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://www.wuqihan.cn/2016/12/14/RAC-一-函数式编程概述/</id>
    <published>2016-12-14T04:05:11.000Z</published>
    <updated>2019-07-09T13:29:05.222Z</updated>
    
    <content type="html"><![CDATA[<p>ReactiveCocoa是一种新的编程范式(即函数响应式编程)，而不是一个基础库。是在面向对象语言的基础上，对函数响应式编程的实现。本文主要讲解函数式编程和响应式编程。</p><a id="more"></a><h3 id="编程是什么？"><a href="#编程是什么？" class="headerlink" title="编程是什么？"></a>编程是什么？</h3><p>根据冯诺依曼体系结构。编程就是：对输入设备进行采样，最终通过计算设备进行计算，得到的结果通过输出设备输出，这就是编程。</p><p>编程也可以是：根据业务需求，形成一种业务模式，最后通过把这个模式转换为代码实现的一个过程。</p><h3 id="面向过程-vs-面向对象"><a href="#面向过程-vs-面向对象" class="headerlink" title="面向过程 vs 面向对象"></a>面向过程 vs 面向对象</h3><p>“面向过程”和“面向对象”指的是编程思想，它们属于同一种编程范式，都是命令式编程。</p><h3 id="命令式编程-vs-函数式编程"><a href="#命令式编程-vs-函数式编程" class="headerlink" title="命令式编程 vs 函数式编程"></a>命令式编程 vs 函数式编程</h3><p>所有的命令式编程都被设计来高效地使用冯诺依曼体系结构的计算机。实际上，最初的命令式语言的目的就是取代汇编语言，对机器指令进行进一步抽象。因此，命令式语言带有强烈的硬件结构特征。命令式语言的核心特性有：模拟存储单元的变量、基于传输操作的赋值语句，以及迭代形式的循环运算。命令式语言的基础是<strong>语句</strong>（特别是赋值），它们通过修改存储器的值而产生副作用的方式去影响后续的计算。</p><p>函数式语言设计的基础是数学函数，函数式程序设计把程序的输出定义为其输入的一个数学函数，在这里没有内部状态，也没有副作用。函数式语言进行计算的主要是将函数作用与给定参数之上。函数式语言没有命令式语言所必需的那种变量，可以没有赋值语句，也可以没有循环。一个程序就是函数定义和函数应用的说明；一个程序的执行就是对函数应用的求值。</p><p>看下面两段代码，功能都为求一个数的阶乘（n!），下面两段代码分别代表了命令式编程 和 函数式编程。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//命令式编程</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">factorial1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= x; ++i) &#123;</span><br><span class="line">        result *= i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//函数式编程</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">factorial2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> x * factorial2(x<span class="hljs-number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难理解，两个方法的作用相同。都为求一个数的阶乘（n!）。那么两段代码有什么区别呢？</p><ul><li><p>看待运算不懂</p><p>factorial1把运算看做是cpu的运算，有存储，创建、计算，返回值（基于冯诺依曼体系结构）。</p><p>factorial2更接近数学计算，更多的是描述一种运算。n的阶乘是什么呢？那就是n! = n * (n-1)!。所以factorial2就是在表述这种运算。</p></li><li><p>factorial1是基于语句的(赋值语句、for循环语句)，factorial2是基于表达式的（表达式是指有值返回的就叫做表达式）。</p></li><li><p>factorial1是基于状态量的，就是代码中的result，要赋值，比较。factorial2是基于不变量的，代码中没有任何修改值的操作。</p></li></ul><p>factorial1 与 factorial2的对比，也就是命令式编程与函数式编程的对比。像我们平时接触的c、oc、java都是命令式编程很少会接触到纯函数式编程的编程语言,比如Erlang、clojure、Scala。</p><h3 id="总结函数式编程的特点"><a href="#总结函数式编程的特点" class="headerlink" title="总结函数式编程的特点"></a>总结函数式编程的特点</h3><ul><li><p>函数是“第一等公民”</p><p>所谓“第一等公民”，指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p></li><li><p>只用表达式，不用语句</p><p>“表达式”是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p><p>原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。”语句”属于对系统的读写操作，所以就被排斥在外。</p><p>当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。</p></li><li><p>没有“副作用”</p><p>所谓“副作用”，指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</p><p>函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p><p>这个不太容易理解，通俗一点的说，我们平时使用命令式编程开发工程中有经常会有如下场景：fun1()调用完之后才能调用fun2()。那这种情况在函数式编程中就不会出现。因为每个函数都是没有副作用的，不影响外部变量，所以func1()还是func2谁先调用，都无所谓。</p></li><li><p>不修改状态</p><p>上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。在其他类型的语言中，变量往往用来保存”状态”。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。</p></li><li><p>引用透明</p><p>引用透明，指的是函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</p><p>有了前面的第三点和第四点，这点是很显然的。其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫”引用不透明”，很不利于观察和理解程序的行为。</p></li><li><p>惰性计算<strong>（？？有点疑问<a href="http://www.nowamagic.net/academy/detail/1220550" target="_blank" rel="noopener">函数式编程的惰性求值</a>）</strong>  </p></li></ul><h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><p>在计算机中，响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。</p><p>例如，在命令式编程环境中，a=b+c表示将表达式的结果赋给a，而之后改变b或c的值不会影响a。但在响应式编程中，a的值会随着b或c的更新而更新。</p><p>电子表格程序就是响应式编程的一个例子。单元格可以包含字面值或类似”=B1+C1”的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化 。</p><p>在ios开发中，autolayout就是使用了响应式编程。响应式编程理解起来应该会简单一点，这里就不多解释。</p><h3 id="ReactiveCocoa是什么？"><a href="#ReactiveCocoa是什么？" class="headerlink" title="ReactiveCocoa是什么？"></a>ReactiveCocoa是什么？</h3><p>上面讲了函数式编程 和 响应式编程。那么ReactiveCocoa 就是结合了函数式编程和响应式编程的特点：</p><ul><li>函数式编程：将运算过程尽量写成一些列的函数调用。</li><li>响应式编程：面对离散数据流以及对离散数据流进行操作。</li></ul><p>，提供<strong>基于时间变化的数据流</strong>的组合和变换，将输入转化为输出在时间上的持续过程的一种方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ReactiveCocoa是一种新的编程范式(即函数响应式编程)，而不是一个基础库。是在面向对象语言的基础上，对函数响应式编程的实现。本文主要讲解函数式编程和响应式编程。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/categories/Objective-C/"/>
    
    
      <category term="ReactiveCocoa" scheme="http://www.wuqihan.cn/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>iOS内存管理详解</title>
    <link href="http://www.wuqihan.cn/2016/08/20/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://www.wuqihan.cn/2016/08/20/iOS内存管理/</id>
    <published>2016-08-20T08:16:43.000Z</published>
    <updated>2019-07-11T13:27:07.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理-引用计数"><a href="#内存管理-引用计数" class="headerlink" title="内存管理/引用计数"></a>内存管理/引用计数</h2><p>Objective-C的内存管理方式：引用计数</p><h3 id="内存管理的思考方式"><a href="#内存管理的思考方式" class="headerlink" title="内存管理的思考方式"></a>内存管理的思考方式</h3><table><thead><tr><th style="text-align:left">对象操作</th><th>Objective-C方法</th></tr></thead><tbody><tr><td style="text-align:left">生成并持有对象</td><td>alloc/new/copy/mutableCopy等方法</td></tr><tr><td style="text-align:left">持有对象</td><td>retain方法</td></tr><tr><td style="text-align:left">释放对象</td><td>release方法</td></tr><tr><td style="text-align:left">废弃对象</td><td>dealloc方法</td></tr></tbody></table><p>​    <a id="more"></a></p><p>​    这些有关Objective-C内存管理的方法，实际上不包括在该语言中，而是包含在Cocoa框架中用于OS X、iOS应用开发。<strong>Cocoa框架中Foundation框架类库的NSObject类担负内存管理的职责</strong>。</p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/arc1.jpg" alt="IMG_3B1C737308BF-1"></p><ul><li><p>自己生成的对象，自己持有</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 自己生成并持有对象</span></span><br><span class="line"><span class="hljs-keyword">id</span> obj = [[<span class="hljs-built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure><p>使用alloc/new/copy/mutableCopy的方法，取得的对象都是自己生成并持有的。</p><p>用这些以外的方法取得的对象，因为非自己生成，所以自己不是对象的持有者。</p><p>copy方法利用基于NSCopying方法约定，由各类实现的copyWithZone:方法生成并持有对象的副本，mutable与copy类似  。用copy/mutableCopy方法生成的对象，虽然是对象的副本，但同allco、new方法一样，在“自己生成并持有对象”这点上没有改变。</p></li><li><p>非自己生成的对象，自己也能持有</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">取得非自己生成对象，不持有</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-keyword">id</span> obj = [<span class="hljs-built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">自己持有</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line">[obj reatin];</span><br></pre></td></tr></table></figure><p>通过retain方法，非自己生成的像 可以被自己所持有。</p></li><li><p>不再需要自己持有的对象时释放</p><p>用alloc/new/copy/mutableCopy方法生成并持有的对象，或者用retain方法持有的对象，一旦不再需要，务必要用release方法进行释放。</p></li><li><p>无法释放非自己持有的对象</p></li></ul><blockquote><p>内存管理黄金法则：</p><p>The basic rule to apple is everything thatincreases the reference counter with alloc,[mutable]copy[WithZone:] or retainis in charge of the corresponding [auto]release.</p><p>如果一个对象使用了alloc，[mutable] copy，retain，那么你必须使用相应的[auto]release</p></blockquote><h3 id="苹果对于引用计数的实现"><a href="#苹果对于引用计数的实现" class="headerlink" title="苹果对于引用计数的实现"></a>苹果对于引用计数的实现</h3><p>在NSObject类的alloc类方法上设置断点，追踪程序的执行。以下列出了执行所调用的方法和函数：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+alloc</span><br><span class="line">+allocWithZone:</span><br><span class="line">class_createInstance</span><br><span class="line"><span class="hljs-built_in">calloc</span></span><br></pre></td></tr></table></figure><p>alloc类方法首先调用allocWithZone:类方法，然后调用class_createInstance函数，最后通过调用calloc来分配内存块。</p><p>retainCount/retain/release实例方法又是怎么实现呢？同刚才的方法一样，下面列出各个方法分别调用的方法和函数：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-retainCount</span><br><span class="line">__CFDoExternRefOperation</span><br><span class="line">CFBasicHashGetCountOfKey</span><br></pre></td></tr></table></figure><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-retain</span><br><span class="line">__CFDoExternRefOperation</span><br><span class="line">CFBasicHashAddValue</span><br></pre></td></tr></table></figure><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-release</span><br><span class="line">__CFDoExternRefOperation</span><br><span class="line">CFBasicHashRemoveValue</span><br><span class="line">(CFBasicHashRemoveValue返回<span class="hljs-number">0</span>时，-release调用dealloc)</span><br></pre></td></tr></table></figure><p>各个方法都通过同一个__CFDoExternRefOperation函数，调用了一系列名称相似的函数。如这些函数名的前缀”CF”所示，她们包含于CoreFoundation框架源代码中，即是CFRuntime.c的CFDoExternRefOperation函数。为了理解其实现，下面简化该函数的源代码：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> __CFDoExternRefOperation(<span class="hljs-keyword">uintptr_t</span> op, id obj) &#123;</span><br><span class="line"></span><br><span class="line">    CFBasicHashRef table = 取得对象的散列表(obj);</span><br><span class="line">    <span class="hljs-keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="hljs-keyword">case</span> OPERATION_retainCount:</span><br><span class="line">        count = CFBasicHashGetCountOfKey(table, obj);</span><br><span class="line">        <span class="hljs-keyword">return</span> count;</span><br><span class="line">        <span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">case</span> OPERATION_retain:</span><br><span class="line">        count = CFBasicHashAddValue(table, obj);</span><br><span class="line">        <span class="hljs-keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">case</span> OPERATION_release:</span><br><span class="line">        count = CFBasicHashRemoveValue(table, obj);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> == count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__CFDoExternRefOperation通过switch语句 针对不同的操作来进行具体的方法调用，retainCount/retain/release实例方法也许如下面代码所示：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-built_in">NSUInteger</span>)retainCount</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">NSUInteger</span>)____CFDoExternRefOperation(OPERATION_retainCount,<span class="hljs-keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">id</span>)<span class="hljs-keyword">retain</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">id</span>)____CFDoExternRefOperation(OPERATION_retain,<span class="hljs-keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)release</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> ____CFDoExternRefOperation(OPERATION_release,<span class="hljs-keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上，可以看出苹果的大概实现就是将引用计数保存在引用计数表的记录中，而不是保存在对象占用内存块头部中。采用散列表(引用计数表)来管理引用计数。</p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/arc2.jpg" alt="IMG_75C55E500AB3-1"></p><p>这样的好处是：</p><ul><li>不用在每个对象内存块中考虑引用计数所占的内存</li><li>引用技术表各记录中存有内存地址，可从各个记录追溯到各对象的内存块（即使出现故障导致对象占用的内存块损坏，但只要引用计数表没有被破坏，就能够确认各个内存块的位置）</li></ul><p>另外，在利用工具检测内存泄漏时，引用计数表的各记录也有助于检测各对象的持有者是否存在。</p><h2 id="Autorelease"><a href="#Autorelease" class="headerlink" title="Autorelease"></a>Autorelease</h2><p>使用autorelease，可使取得的对象存在但自己不持有对象。autorelease提供 这样的功能，使对象在超出指定的生存范围时能够自动并正确地释放(自动调用release方法)。</p><h3 id="autorelease的具体使用方法如下"><a href="#autorelease的具体使用方法如下" class="headerlink" title="autorelease的具体使用方法如下"></a>autorelease的具体使用方法如下</h3><ol><li>生成并持有NSAutoreleasePool对象</li><li>调用已分配对象的autorelease实例方法</li><li>废弃NSAutoreleasePool对象</li></ol><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/arc3.jpg" alt="image-20180408170302393"></p><p>NSAutoreleasePool对象的生存周期相当于C语言变量的作用域。对于所有调用过autorelease实例方法的对象，在废弃NSAutoreleasePool对象时，都将调用release实例方法。</p><p>用源代码表示如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSAutoReleasePool *pool = [[NSAutoReleasePool alloc] init];</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line">[pool drain];</span><br></pre></td></tr></table></figure><blockquote><p>NSAutoreleasePool对象的销毁是调用 drain() 方法</p></blockquote><p>ARC中使用NSAutoReleasePool：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//在&#123;&#125;中存放的对象会在&#125;后释放掉</span></span><br></pre></td></tr></table></figure><h3 id="使用NSAutoreleasePool减少内存峰值"><a href="#使用NSAutoreleasePool减少内存峰值" class="headerlink" title="使用NSAutoreleasePool减少内存峰值"></a>使用NSAutoreleasePool减少内存峰值</h3><p>在大量产生autorelease的对象时，只要不废弃NSAutoReleasePool对象，那么生成的对象就不能被释放，因此有时会产生内存不足的现象。典型的例子是读入大量图象的同时改变其尺寸。图象文件读入到NSData对象，并生成UIImage对象，改变该对象的尺寸后生成新的UIImage对象。这种情况下，就会大量生成autorelease对象。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, i &lt; 图像数, ++i) &#123;</span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">     *读入图像</span></span><br><span class="line"><span class="hljs-comment">     *大量产生autorelease对象</span></span><br><span class="line"><span class="hljs-comment">     *由于没有废弃NSAutoreleasePool对象</span></span><br><span class="line"><span class="hljs-comment">     *最终导致内存不足</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此情况下，有必要在适当地方生成、持有或废弃NSAutoreleasePool对象。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; 图像数; ++i) &#123;</span><br><span class="line">    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">     *读入图像</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    [pool drain];</span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">    *通过[pool drain],</span></span><br><span class="line"><span class="hljs-comment">    *autorelease的对象被一起废弃</span></span><br><span class="line"><span class="hljs-comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="autorelease对象什么时候释放"><a href="#autorelease对象什么时候释放" class="headerlink" title="autorelease对象什么时候释放"></a>autorelease对象什么时候释放</h3><p>很多人的答案是“当前作用域大括号结束时释放”，显然没有正确理解autorelease的机制。在没有手动添加autoreleasepool的情况下，<strong>autorelease对象是在当前runloop迭代结束时释放的</strong>。而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop。</p><p>看下面代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__<span class="hljs-keyword">weak</span> <span class="hljs-keyword">id</span> reference = <span class="hljs-literal">nil</span>;</span><br><span class="line">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    __autoreleasing Person *p = [[Person alloc] init];</span><br><span class="line">    reference = p;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,reference);<span class="hljs-comment">//Console: &lt;Person: 0x60000000f170&gt;</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="hljs-keyword">void</span>)viewWillAppear:(<span class="hljs-built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,reference);<span class="hljs-comment">//Console: &lt;Person: 0x60000000f170&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)viewDidAppear:(<span class="hljs-built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,reference);<span class="hljs-comment">//Console: (null)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这个vc在loadView之后便add到了window层级上，所以<code>viewDidLoad</code>和<code>viewWillAppear</code>是在同一个runloop调用的，因此在<code>viewWillAppear</code>中，这个autorelease的变量依然有值。当然我们也可以手动干预autorelease对象的释放时机：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__<span class="hljs-keyword">weak</span> <span class="hljs-keyword">id</span> reference = <span class="hljs-literal">nil</span>;</span><br><span class="line">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        __autoreleasing Person *p = [[Person alloc] init];</span><br><span class="line">        reference = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,reference);<span class="hljs-comment">//Console: (null)</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="hljs-keyword">void</span>)viewWillAppear:(<span class="hljs-built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,reference);<span class="hljs-comment">//Console: (null)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)viewDidAppear:(<span class="hljs-built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,reference);<span class="hljs-comment">//Console: (null)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="苹果对于autorelease的实现"><a href="#苹果对于autorelease的实现" class="headerlink" title="苹果对于autorelease的实现"></a>苹果对于autorelease的实现</h3><p>autorelease实例方法的本质就是调用NSAutoreleasePool对象的addObject方法。</p><p>系统在每个runloop迭代中都加入了自动释放池的Push和Pop方法。具体为runloop开始的时候调用AutoreleasePoolPage的Push方法，结束的时候调用Pop方法。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">objc_autoreleasePoolPush</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">objc_autoreleasePoolPop</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ctxt)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么AutoreleasePoolPage是什么东西呢？</p><p>AutoReleasePoolPage是一个C++的类，在NSObject.mm中定义是：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoreleasePoolPage</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">magic_t</span> <span class="hljs-keyword">const</span> magic;</span><br><span class="line">    id *next;</span><br><span class="line">    <span class="hljs-keyword">pthread_t</span> <span class="hljs-keyword">const</span> thread;</span><br><span class="line">    AutoreleasePoolPage * <span class="hljs-keyword">const</span> parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> <span class="hljs-keyword">const</span> depth;</span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> hiwat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>magic 用于对当前 AutoreleasePoolPage`<strong>完整性</strong>的校验</p></li><li><p>thread 保存了当前所在的线程</p></li></ul><p>每一个自动释放池都是由一系列的AutoreleasePoolPage组成的，并且每一个AutoreleasePoolPage的大小都是4096字节(0x1000)</p><p>自动释放池中的AutoreleasePoolPage是以<strong>双向链表</strong>的形式链接起来的：</p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/arc4.jpg" alt="image-20180420215336249"></p><p>parent 和 child 就是用来构造双向链表的指针。</p><h3 id="autorelease和runloop的关系"><a href="#autorelease和runloop的关系" class="headerlink" title="autorelease和runloop的关系"></a>autorelease和runloop的关系</h3><p>runloop开始启动的时候会创建autoreleasePool，结束的时候会销毁autoreleasePool</p><h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><p>引用计数内存管理的本质部分在ARC中并没有改变。ARC只是自动帮我们处理“引用计数”的相关部分。</p><h3 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h3><p>ARC有效时，id类型和对象类型同C语言其他类型不同，其类型上必须附加所有权修饰符。所有权修饰符一共有4中。</p><ul><li><p>__strong</p><p>__strong修饰符是id类型和对象类型默认的所有权修饰符。__strong修饰符表示对对象的“强引用”，持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放。</p><p>__strong修饰符修饰的变量，不仅仅只在变量作用域中，在赋值上也能够正确地管理其对象的所有者。</p><p>通过__strong修饰符，不必再键入retain或者release，完美地满足了“引用技术内存管理的思考方式”</p></li><li><p>__weak</p><p>多用来解决“循环引用”的问题。</p><p>__weak修饰符还有另外一个优点，在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于nil被赋值的状态（空弱引用）。</p></li><li><p>__unsafe_unretained</p><p>__unsafe_unretained修饰符正如其名unsafe所示，是不安全的所有权修饰符。尽管ARC式的内存管理是编译器的工作，但附有 __unsafe_unretained修饰符的变量不属于编译器的内存管理对象。</p><p>和__weak一样都是弱引用。但是当引用的对象被废弃后，指针不会置为nil，会造成野指针</p></li><li><p>__autoreleasing</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* ARC无效 */</span></span><br><span class="line"><span class="hljs-built_in">NSAutoreleasePool</span> *pool = [[<span class="hljs-built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="hljs-keyword">id</span> obj = [[<span class="hljs-built_in">NSObject</span> alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line">[pool drain];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* ARC有效 与上面代码等价 */</span></span><br><span class="line"><span class="hljs-keyword">@autoreleasepool</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">id</span> __autoreleaseing obj = [[<span class="hljs-built_in">NSObject</span> alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ARC有效时，autorelease功能是起作用的。用@autorelasepool块替代NSAutoreleasePool类，用附有__autoreleasing修饰符的变量替代autorelease方法。</p><p>对象赋值给附有__autorelease修饰符的变量等价于在ARC无效时调用对象的autorelease方法，即对象被注册到autoreleasepool。</p><p>显示地附加_<em>autoreleaseing修饰符同显示地附加\</em>_strong修饰符一样罕见，所以在ARC中经常非显示地使用___autoreleasing修饰符。</p><p>非显示地使用__autoreleaseing修饰符的列子：</p><p>1)  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id __weak obj1 = obj0;</span><br><span class="line">NSLog(@&quot;class=%@&quot;,[obj1 class]);</span><br></pre></td></tr></table></figure><p>下面的代码与上面的相同：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id __weak obj1 = obj0;</span><br><span class="line">id __autoreleasing tmp = obj1;</span><br><span class="line">NSLog(@&quot;class=%@&quot;,[tmp class]);</span><br></pre></td></tr></table></figure><p><strong>在访问到weak修饰符的变量时必须访问注册到autoreleasepool的对象</strong>。这是因为weak修饰符只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。如果把要访问的对象注册到autoreleasepool中，那么在@autoreleasepool块结束之前都能确保该对象存在。因此，使用富有weak修饰符的变量时就必定要使用注册到autoreleasepool中的对象。</p><p>2）</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="hljs-keyword">id</span>)array &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSMutableArray</span> new];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述源代码等同于：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="hljs-keyword">id</span>)array &#123;</span><br><span class="line">    <span class="hljs-keyword">id</span> obj = [<span class="hljs-built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="hljs-keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于return使得对象变量超出其作用域，所以该强引用对应的自己持有的对象会被自动释放，但该对象作为返回值，编译器会自动将其注册到autoreleasePool。</p><p>3)</p><p>id的指针或对象的指针在没有显示指定时会被附加上__autoreleasing修饰符</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSError *error = nil;</span><br><span class="line">Bool result = [obj performOperationWithError:&amp;error];</span><br></pre></td></tr></table></figure><p>该方法的声明为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)performOperationWithError:(NSError **)error;</span><br></pre></td></tr></table></figure><p>等同于一下源代码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)performOperationWithError:(NSError * __autoreleasing*)error;</span><br></pre></td></tr></table></figure></li></ul><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li><p>不能使用retain/release/retainCount/autorelease</p></li><li><p>不能使用NSAllocateObject/NSDeallocateObject</p></li><li><p>须遵守内存管理的方法命名规则</p></li><li><p>不要显示调用dealloc</p></li><li><p>使用@autoreleasepool块代替NSAutoreleasePool</p></li><li><p>不能使用区域(NSZone)</p><p>不管ARC是否有效，区域在现在的运行时系统中已单纯地被忽略</p></li><li><p>对象型变量不能作为C语言结构体的成员</p><p>C语言的规约上没有方法来管理结构体成员的生命周期。因为ARC把内存管理的工作分配给编译器，所以编译器必须能够知道并管理对象的生命周期。例如C语言的自动变量(局部变量)可使用该变量的作用于来管理对象。但是对于C语言的结构体成员来说，这在标准上就是不可实现的。</p><p>如果非要把对象型变量加入到结构体重时，可强制转换为void *或是附加见面所述的__unsafe_unretained修饰符（附有___unsafe_unretained修饰符的变量不属于编译器的内存管理对象。如果管理时不注意赋值对象的所有者，便有可能遭遇内存泄漏或程序崩溃）</p></li><li><p>显示转换id和void *</p><p>通过_<em>bridge，id和void能够相互转换。但是\</em>_bridge转换，其安全性与赋值给__unsafe_unretained修饰符相近，甚至会更低。如果管理时不注意赋值对象的所有者，就会因悬垂指针而导致程序崩溃。</p><p>__bridge转换中还有另外两种转换，分别是__bridge_retained转换和__bridge_transfer转换</p></li></ul><p>## </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理-引用计数&quot;&gt;&lt;a href=&quot;#内存管理-引用计数&quot; class=&quot;headerlink&quot; title=&quot;内存管理/引用计数&quot;&gt;&lt;/a&gt;内存管理/引用计数&lt;/h2&gt;&lt;p&gt;Objective-C的内存管理方式：引用计数&lt;/p&gt;
&lt;h3 id=&quot;内存管理的思考方式&quot;&gt;&lt;a href=&quot;#内存管理的思考方式&quot; class=&quot;headerlink&quot; title=&quot;内存管理的思考方式&quot;&gt;&lt;/a&gt;内存管理的思考方式&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;对象操作&lt;/th&gt;
&lt;th&gt;Objective-C方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;生成并持有对象&lt;/td&gt;
&lt;td&gt;alloc/new/copy/mutableCopy等方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;持有对象&lt;/td&gt;
&lt;td&gt;retain方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;释放对象&lt;/td&gt;
&lt;td&gt;release方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;废弃对象&lt;/td&gt;
&lt;td&gt;dealloc方法&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;​&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/categories/Objective-C/"/>
    
    
      <category term="内存管理" scheme="http://www.wuqihan.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Grand Central Dispatch</title>
    <link href="http://www.wuqihan.cn/2016/07/18/Grand-Central-Dispatch/"/>
    <id>http://www.wuqihan.cn/2016/07/18/Grand-Central-Dispatch/</id>
    <published>2016-07-18T07:21:44.000Z</published>
    <updated>2019-07-11T13:30:33.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>什么是GCD<ul><li>全程：Grand Central Dispatch（强大的中枢调度器）</li><li>纯C语言，提供了非常强大的函数</li></ul></li><li>GCD的优势<ul><li>GCD会自动利用更多的CPU内核</li><li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li><li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</li></ul></li></ul><a id="more"></a><h3 id="任务和队列"><a href="#任务和队列" class="headerlink" title="任务和队列"></a>任务和队列</h3><ul><li>GCD中有两个核心概念<ul><li>任务：执行什么操作</li><li>队列：用来存放任务</li></ul></li><li>GCD的使用有两个步骤<ul><li>定制任务</li><li>将任务添加到队列中<ul><li>GCD会自动将队列中的任务取出来，放到对应的线程中执行</li><li>任务的取出遵循队列的FIFO（现金先出）原则</li></ul></li></ul></li></ul><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><ul><li><p>GCD中有两个用来执行任务的常用函数</p><ul><li><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     用同步的方式执行任务</span></span><br><span class="line"><span class="hljs-comment"></span></span><br><span class="line"><span class="hljs-comment">     @param queue#&gt; 队列 description#&gt;</span></span><br><span class="line"><span class="hljs-comment">     @param void block任务</span></span><br><span class="line"><span class="hljs-comment">     @return</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-built_in">dispatch_sync</span>(&lt;<span class="hljs-meta">#dispatch_queue_t  _Nonnull queue#&gt;, <span class="hljs-meta-string">&lt;#^(void)block#&gt;</span>);</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     用异步的方式执行任务</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(&lt;<span class="hljs-meta">#dispatch_queue_t  _Nonnull queue#&gt;, <span class="hljs-meta-string">&lt;#^(void)block#&gt;</span>);</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>还有个用来执行任务的函数：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;     <span class="hljs-comment">//第一个参数queue 不能是全局的并发队列</span></span><br><span class="line">&gt; <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">&gt; dispatch_barrier_async函数的作用与barrier的意思相同,在进程管理中起到一个栅栏的作用,它等待所有位于barrier函数之前的操作执行完毕后执行,并且在barrier函数执行之后,barrier函数之后的操作才会得到执行,该函数需要同dispatch_queue_create函数生成的concurrent Dispatch Queue  队列一起使用</span></span><br><span class="line"><span class="hljs-comment">&gt; */</span></span><br><span class="line">&gt;     dispatch_barrier_async(&lt;<span class="hljs-meta">#dispatch_queue_t  _Nonnull queue#&gt;, <span class="hljs-meta-string">&lt;#^(void)block#&gt;</span>);</span></span><br><span class="line">&gt;     dispatch_barrier_sync(&lt;<span class="hljs-meta">#dispatch_queue_t  _Nonnull queue#&gt;, <span class="hljs-meta-string">&lt;#^(void)block#&gt;</span>);</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>同步和异步的区别</p><ul><li>同步：只能在当前线程中执行任务，不具备开启新线程的能力</li><li>异步：只能在新的线程中执行任务，局别开启新线程的能力</li></ul><blockquote><p>同步、异步、并发、串行 要分清楚</p><ul><li>同步和异步主要影响：能不能开启新的线程<ul><li>同步：只是在当前线程中执行任务，不具备开启新线程的能力</li><li>异步：可以在新的线程中执行任务，具备开启新线程的能力</li></ul></li><li>并发和串行主要影响：任务的执行方式<ul><li>并发：允许多个任务并发（同时）执行</li><li>串行：一个任务执行完毕后，再执行下一个任务</li></ul></li></ul></blockquote></li><li><p>dispatch_async 和 dispatch_sync 还要一个很重要的区别</p><ul><li><p>异步执行 会立刻返回</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//验证异步执行会立刻返回</span></span><br><span class="line">   <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">       <span class="hljs-comment">//子线程</span></span><br><span class="line">       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;</span><br><span class="line">           <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"22222"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"33333"</span>);</span><br><span class="line">   <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">   先打印33333</span></span><br><span class="line"><span class="hljs-comment">   最后才是2222。。。</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>同步执行会等待执行结束后才返回</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//验证同步执行会等待执行结束后返回</span></span><br><span class="line">   <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">       <span class="hljs-comment">//因为是同步。不会开启线程，所以仍然是main线程</span></span><br><span class="line">       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;</span><br><span class="line">           <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"22222"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"33333"</span>);</span><br><span class="line">   <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">   先打印完所有22222</span></span><br><span class="line"><span class="hljs-comment">   最后才会打印33333</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br></pre></td></tr></table></figure><p>正是因为这个特性 在主线程同步调用任务在mainQueue里，就会造成死锁的情况。因为：<br>1）:dispatch_sync在等待block语句执行完成，而block语句需要在主线程里执行，所以dispatch_sync如果在主线程调用就会造成死锁<br>2）:dispatch_sync是同步的，本身就会阻塞当前线程，也即主线程。而又往主线程里塞进去一个block，所以就会发生死锁。</p></li></ul><h3 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h3><h4 id="队列的类型"><a href="#队列的类型" class="headerlink" title="队列的类型"></a>队列的类型</h4><ul><li>GCD的队列可以分为2大类型<ul><li>并发队列<ul><li>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）</li><li>并发功能只有在异步（dispatch_async）函数下才有效</li></ul></li><li>串行队列<ul><li>让任务一个接着一个地执行（一个任务执行完毕之后，再执行下一个任务）</li></ul></li></ul></li></ul><h4 id="如何创建并发队列"><a href="#如何创建并发队列" class="headerlink" title="如何创建并发队列"></a>如何创建并发队列</h4><p>第一种方法：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_create(<span class="hljs-string">"com.a"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><p>第二种方法：使用系统提供的 Global Dispatch Queue</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//第一个设置优先级，仅仅是大致优先级。第二个暂时没用</span></span><br></pre></td></tr></table></figure><h4 id="如何创建串行队列"><a href="#如何创建串行队列" class="headerlink" title="如何创建串行队列"></a>如何创建串行队列</h4><p>第一种方法：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_create(<span class="hljs-string">"com.b"</span>, <span class="hljs-literal">NULL</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意：《iOS与OS X多线程和内存管理》中讲到 使用dispatch_queue_create()创建的DispatchQueue在ARC中也需要手动调用dispatch_release（）方法释放。经过验证，iOS6以后的ARC中就不需要了。</p></blockquote><p>这里需要注意使用Serial Disparch Queue时，其生成个数的问题，Concurrent Dispatch Queue能够并行执行多个追加处理（也就是会开启多条线程去处理追加到队列中的的多个任务），而Serial Dispatch Queue同时只能执行一个追加处理（也就是只能开启一条线程）。</p><p>但是当通过dispatch_queue_create()生成多个Serial Dispatch Queue时，各个Serial Dispatch Queue将并行执行（<strong>前提是使用异步方式</strong>）。虽然在一个Serial Dispatch Queue中同时只能执行一个追加处理，但如果将处理分别追加到4个Serial Dispatch Queue中，各个Serial Dispatch Queue执行一个，即为并行执行4个处理。≈ 如下图：</p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/gcd1.png" alt="多个Serial Dispatch Queue"></p><p>如果生成2000个Serial Dispatch Queue，那么就生成2000个线程，如果过多使用，就会消耗大量内存，引起大量的上下文切换，大幅度降低系统的性能。</p><p>第二种方法：直接使用主队列（主队列是串行队列）</p><h3 id="GCD的其他函数"><a href="#GCD的其他函数" class="headerlink" title="GCD的其他函数"></a>GCD的其他函数</h3><h4 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h4><ol><li><p>变更Dispatch Queue的执行优先级。<br>dispatch_queue_create函数生成的Dispatch Queue不管是Serial Dispatch Queue还是Concurrent Dispatch Queue，都使用与默认优先级Global Dispatch Queue相同执行优先级的线程。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.oukavip.www&quot;,NULL);</span><br><span class="line">    dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);</span><br><span class="line">   dispatch_set_target_queue(serialQueue, globalQueue);</span><br><span class="line">   // 第一个参数为要设置优先级的queue,第二个参数是参照物，既将第一个queue的优先级和第二个queue的优先级设置一样。</span><br><span class="line">//第一个参数如果指定系统提供的Main/Global Dispatch Queue则不知道会出现什么情况，因此这些均不可以指定。</span><br></pre></td></tr></table></figure></li><li><p>将Dispatch Queue指定为dispatch_set_target_queue函数的参数还可以作成Dispatch Queue的执行阶层，那么原本应并行执行的多个Serial Dispatch Queue，在目标Serial Dispatch Queue上只能同时执行一个处理。（修改用户队列的目标队列，使多个Queue在目标Queue上一次只有一个执行）</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> targetQueue = dispatch_queue_create(<span class="hljs-string">"targetQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="hljs-string">"queue1"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="hljs-built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="hljs-string">"queue1"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//设置参考</span></span><br><span class="line">    dispatch_set_target_queue(queue1, targetQueue);</span><br><span class="line">    dispatch_set_target_queue(queue2, targetQueue);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"job3 in"</span>);</span><br><span class="line">        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2.</span>f];</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"job3 out"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"job2 in"</span>);</span><br><span class="line">        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1.</span>f];</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"job2 out"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"job1 in"</span>);</span><br><span class="line">        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">3.</span>f];</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"job1 out"</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>打印输出为：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">48.144492</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">3693</span>:<span class="hljs-number">336603</span>] job3 in</span><br><span class="line"><span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">50.148901</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">3693</span>:<span class="hljs-number">336603</span>] job3 out</span><br><span class="line"><span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">50.149213</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">3693</span>:<span class="hljs-number">336603</span>] job2 in</span><br><span class="line"><span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">51.153663</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">3693</span>:<span class="hljs-number">336603</span>] job2 out</span><br><span class="line"><span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">51.154019</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">3693</span>:<span class="hljs-number">336603</span>] job1 in</span><br><span class="line"><span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">54.157262</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">3693</span>:<span class="hljs-number">336603</span>] job1 out</span><br></pre></td></tr></table></figure><p>通过打印的结果说明我们设置了queue1和queue2队列以targetQueue队列为参照对象，那么queue1和queue2中的任务将按照targetQueue的队列处理。</p><p>在必须将不可并行执行的处理追加到多个Serial Dispatch Queue中时，如果使用dispatch_set_target_queue函数将目标制定为某一个Serial Dispatch Queue，即可防止处理并行执行。</p><p>适用场景：一般都是把一个任务放到一个串行的queue中，如果这个任务被拆分了，被放置到多个串行的queue中，但实际还是需要这个任务同步执行，那么就会有问题，因为多个串行queue之间是并行的。这时候dispatch_set_target_queue将起到作用。</p></li></ol><h4 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h4><p>想在指定时间后执行处理，可使用dispatch_after函数来实现。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//在3秒后将指定的block追加到Main Dispatch Queue中</span></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">3</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"waited at last three seconds."</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>dispatch_after函数并不是在指定时间后执行处理，而只是在指定时间追加处理到Dispatch Queue。此源代码与在3秒后用dispatch_async函数追加block到Main Dispatch Queue相同。</p><p>因为Main Dispatch Queue在主线程的RunLoop中执行，所以在比如每隔1/60秒执行的RunLoop中，block最快在3秒后执行，最慢在3+1/60秒后执行。并且Main Dispatch Queue有大量处理追加或主线程的处理本身有延迟时，这个时间会更长。如果想在大致延迟时间执行处理，该函数是非常有效的。</p><h4 id="disparch-group-t"><a href="#disparch-group-t" class="headerlink" title="disparch_group_t"></a>disparch_group_t</h4><p>无论向什么样的Dispatch Queue中追加处理，使用Dispatch Group都可以监视这些处理执行的结束。一旦检测到所有处理执行结束，就可将结束的处理追加到Dispatch Queue中。这就是使用Dispatch Group的原因。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);</span><br><span class="line">   dispatch_group_t group = dispatch_group_create();</span><br><span class="line">   </span><br><span class="line">   dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"blk0"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"blk1"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_group_async(group, dispatch_queue_create(<span class="hljs-string">"com.wuqh.queue"</span>, <span class="hljs-literal">NULL</span>), ^&#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"blk2"</span>);</span><br><span class="line">       [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">5</span>];</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"blk2done"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"done"</span>);</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>另外，在Dispatch Gourp中也可以使用dispatch_group_wait函数仅等待全部处理执行结束。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"blk0"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"blk1"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, dispatch_queue_create(<span class="hljs-string">"com.wuqh.queue"</span>, <span class="hljs-literal">NULL</span>), ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"blk2"</span>);</span><br><span class="line">        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">5</span>];</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"blk2done"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-comment">//程序会一直停留在此处等待gourp中的任务，直到全部执行完毕才会继续向下执行。</span></span><br><span class="line"><span class="hljs-comment">//也就是说，意味着一旦调用dispatch_group_wait函数，该函数就处于调用的状态而不返回。即执行dispatch</span></span><br><span class="line"><span class="hljs-comment">//_group_wait函数的线程停止。在经过dispatch_group_wait函数中指定时间或任务全部执行结束之前</span></span><br><span class="line"><span class="hljs-comment">//执行该函数的线程停止</span></span><br><span class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure><p>也可以指定等待时间。disparch_group_wait，有一个long类型的返回值，返回值为0，表示全部执行结束，返回值不为0，表示虽然经过了指定时间，但还有某些处理没有执行完。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">long</span> result = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">3</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>)));</span><br><span class="line">    <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"没有全部执行结束执行结束"</span>);</span><br><span class="line">    &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"全部执行结束"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>指定time为DISPATCH_TIME_NOW，则不用任何等待即可判定属于Dispatch Group的处理是否执行结束。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">long</span> result = dispatch_group_wait(group, DISPATCH_TIME_NOW);</span><br></pre></td></tr></table></figure><h4 id="dispatch-a-sync"><a href="#dispatch-a-sync" class="headerlink" title="dispatch_(a)sync"></a>dispatch_(a)sync</h4><p>dispatch_async函数的”async“意味着“非同步”，就是将指定的block”非同步”地追加到指定的队列中。dispatch_async函数不作任何等待，如下图：</p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/gcd2.jpg" alt="mage-20180315162245"></p><p>dispatch_sync意味着“同步”。函数会一直等待执行结束，“等待”意味着当前线程停止。如下图：</p><p><img src="https://coding.net/u/wqh_iOS/p/tuchuang/git/raw/master/2018/gcd3.jpg" alt="mage-20180315162057"></p><p>注意：dispatch_sync函数容易引起问题，即死锁。例如在主线程中执行以下源代码就会死锁：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="hljs-comment">//。。。</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>使用async，或者Serail Dispatch Queue都会遇到死锁，如下：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"..."</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">"com.gcd.error"</span>, <span class="hljs-literal">NULL</span>);</span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"..."</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="dispatchbarrier-a-sync"><a href="#dispatchbarrier-a-sync" class="headerlink" title="dispatchbarrier(a)sync"></a>dispatch<em>barrier</em>(a)sync</h4><p>在进程管理中起到一个栅栏的作用，它等待所有位于barrier函数之前的操作执行完毕后执行，并且在barrier函数执行之后，barrier函数之后的操作才会得到执行，该函数需要同dispatch_queue_create函数生成的Concureent Dispatch Queue队列一起使用。<strong>注意：与使用dispatch_get_global_queue()获得的队列一起使用无效</strong>。</p><p>作用：</p><ul><li>实现高效率的数据库访问和文件访问</li><li>避免数据竞争</li></ul><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">"com.gcd"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"----1----%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"----2----%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"----barrier----%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"----3----%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"----4----%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="hljs-comment">//先执行1和2，之后是barrier，最后是3和4</span></span><br></pre></td></tr></table></figure><p>同dispath_async一样，此函数也有一个这样的函数：dispatch_barrier_sync函数，此函数与dispatch_barrier_async的区别和 dispatch_async与dispatch_sync的区别相同：async不阻塞当前线程。</p><h4 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h4><p> dispatch_apply函数时dispatch_sync函数和Dispatch Group的关联API。该函数按指定的次数将指定的block追加到指定的Dispatch Queue中，并等待全部处理执行结束。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">NSArray</span> *array = [<span class="hljs-built_in">NSArray</span> arrayWithObjects:@<span class="hljs-number">0</span>,@<span class="hljs-number">1</span>,@<span class="hljs-number">2</span>,@<span class="hljs-number">3</span>,@<span class="hljs-number">4</span>,@<span class="hljs-number">5</span>,@<span class="hljs-number">6</span>,@<span class="hljs-number">7</span>,@<span class="hljs-number">8</span>,@<span class="hljs-number">9</span>, <span class="hljs-literal">nil</span>];</span><br><span class="line">dispatch_apply([array count], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^(size_t index) &#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"async:%@-%@"</span>,array[index],[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"done"</span>);<span class="hljs-comment">//同sync一样。最后才会打印done。</span></span><br></pre></td></tr></table></figure><p>由于dispatch_apply函数会等待执行结束，因此有时候也可以在dispatch_async函数中非同步地执行dispatch_apply函数。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">        dispatch_apply([array count],  dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^(size_t index) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"async:%@-%@"</span>,array[index],[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"success"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"done"</span>);<span class="hljs-comment">//因为async不需要等待，所以会立马执行，不会最后才打印。</span></span><br></pre></td></tr></table></figure><h4 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend/dispatch_resume"></a>dispatch_suspend/dispatch_resume</h4><p>当追加大量处理到Dispatch Queue时，在追加处理的过程中，有时希望不执行已追加的处理。在这种情况下，只要挂起Dispatch Queue即可，当可以执行时再恢复。</p><p>注意：dispatch_suspend/dispatch_resume对全局队列不起作用。</p><p>必须确保dispatch_suspend/dispatch_resume成对调用。那么这里有个问题？<strong>gcd中如何中途结束线程？</strong></p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">"com.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="hljs-comment">//提交第一个block，延时5秒打印。</span></span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    sleep(<span class="hljs-number">5</span>);</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"After 5 seconds..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-comment">//提交第二个block，也是延时5秒打印</span></span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    sleep(<span class="hljs-number">5</span>);</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"After 5 seconds again..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-comment">//延时一秒</span></span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"sleep 1 second..."</span>);</span><br><span class="line">sleep(<span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-comment">//挂起队列</span></span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"suspend..."</span>);</span><br><span class="line">dispatch_suspend(queue);</span><br><span class="line"><span class="hljs-comment">//延时10秒</span></span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"sleep 10 second..."</span>);</span><br><span class="line">sleep(<span class="hljs-number">10</span>);</span><br><span class="line"><span class="hljs-comment">//恢复队列</span></span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"resume..."</span>);</span><br><span class="line">dispatch_resume(queue);</span><br></pre></td></tr></table></figure><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">2017</span><span class="hljs-number">-08</span><span class="hljs-number">-18</span> <span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">41.261398</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">5222</span>:<span class="hljs-number">795121</span>] sleep <span class="hljs-number">1</span> second...</span><br><span class="line"><span class="hljs-number">2017</span><span class="hljs-number">-08</span><span class="hljs-number">-18</span> <span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">42.262096</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">5222</span>:<span class="hljs-number">795121</span>] suspend...</span><br><span class="line"><span class="hljs-number">2017</span><span class="hljs-number">-08</span><span class="hljs-number">-18</span> <span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">42.262496</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">5222</span>:<span class="hljs-number">795121</span>] sleep <span class="hljs-number">10</span> second...</span><br><span class="line"><span class="hljs-number">2017</span><span class="hljs-number">-08</span><span class="hljs-number">-18</span> <span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">46.263456</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">5222</span>:<span class="hljs-number">795188</span>] After <span class="hljs-number">5</span> seconds...</span><br><span class="line"><span class="hljs-number">2017</span><span class="hljs-number">-08</span><span class="hljs-number">-18</span> <span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">52.263457</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">5222</span>:<span class="hljs-number">795121</span>] resume...</span><br><span class="line"><span class="hljs-number">2017</span><span class="hljs-number">-08</span><span class="hljs-number">-18</span> <span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">57.264210</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">5222</span>:<span class="hljs-number">795191</span>] After <span class="hljs-number">5</span> seconds again...</span><br></pre></td></tr></table></figure><p>在dispatch_suspend挂起队列后，第一个block还是在运行，并且正常输出。</p><p>dispatch_suspend并不会立即暂停正在运行的block，而是在当前block执行完成后，暂停后续的block执行。</p><h4 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h4><p>dispatch_semaphore只有3个方法：</p><ul><li><p>dispatch_semaphore_create </p><p>执行dispatch_semaphore_create会根据传入的long类型参数创建对应数目的信号量</p></li><li><p>dispatch_semaphore_signal </p><p>执行dispatch_semaphore_singal会增加一个信号量</p></li><li><p>dispatch_semaphore_wait //等待信号量</p><p>执行dispatch_semaphore_wait如果信号量是0，就会根据传入的等待时间来等待，如果大于0则不会等待，并且会减去一个信号量</p></li></ul><p>作用：</p><ul><li><p>可以控制一个资源最多由多少个线程来访问。</p><p>如下代码所示，由于设定的信号值为2，先执行两个线程，等执行完其中一个，第三个才会继续执行。保证同一时间执行的线程数不超过2。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//crate的value表示，最多几个资源可访问</span></span><br><span class="line">   dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">2</span>);</span><br><span class="line">   <span class="hljs-built_in">dispatch_queue_t</span> quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="hljs-comment">//任务1</span></span><br><span class="line">   <span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">       dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"run task 1"</span>);</span><br><span class="line">       sleep(<span class="hljs-number">1</span>);</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"complete task 1"</span>);</span><br><span class="line">       dispatch_semaphore_signal(semaphore);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="hljs-comment">//任务2</span></span><br><span class="line">   <span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">       dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"run task 2"</span>);</span><br><span class="line">       sleep(<span class="hljs-number">1</span>);</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"complete task 2"</span>);</span><br><span class="line">       dispatch_semaphore_signal(semaphore);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="hljs-comment">//任务3</span></span><br><span class="line">   <span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">       dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"run task 3"</span>);</span><br><span class="line">       sleep(<span class="hljs-number">1</span>);</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"complete task 3"</span>);</span><br><span class="line">       dispatch_semaphore_signal(semaphore);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>也可以起到类似栅栏函数的作用。线程A和线程B：线程A执行完之后线程B再继续执行。</p><p>如下代码所示：先执行获取token方法，在执行request</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-comment">//这里使用dispatch_async，是为了不阻塞当前线程。</span></span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">        dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">0</span>);</span><br><span class="line">        [<span class="hljs-keyword">self</span> getToken:semaphore];</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        [<span class="hljs-keyword">self</span> request];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"继续执行啊"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//异步请求，获取token</span></span><br><span class="line">- (<span class="hljs-keyword">void</span>)getToken:(dispatch_semaphore_t)semaphore &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"getToken:%d"</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"getToken:Success"</span>);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//执行网络请求</span></span><br><span class="line">- (<span class="hljs-keyword">void</span>)request &#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"request"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>题外话：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="hljs-built_in">NSMutableArray</span> *array = [[<span class="hljs-built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">&gt;     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i) &#123;</span><br><span class="line">&gt;         <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">&gt;             [array addObject:[<span class="hljs-built_in">NSNumber</span> numberWithInt:i]];</span><br><span class="line">&gt;         &#125;);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>上面这段代码会执行错误。报错如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="hljs-built_in">malloc</span>: *** error <span class="hljs-keyword">for</span> object <span class="hljs-number">0x6040003805b0</span>: pointer being freed was <span class="hljs-keyword">not</span> allocated</span><br><span class="line">&gt; *** <span class="hljs-built_in">set</span> a breakpoint in malloc_error_break to debug</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>为什么、？</p></blockquote><h4 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h4><p>dispatch_once函数是保证在应用程序中只执行一次指定处理的API。单例模式经常用到此函数。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="hljs-comment">//code to be executed once</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="Dispatch-I-O"><a href="#Dispatch-I-O" class="headerlink" title="Dispatch I/O"></a>Dispatch I/O</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;什么是GCD&lt;ul&gt;
&lt;li&gt;全程：Grand Central Dispatch（强大的中枢调度器）&lt;/li&gt;
&lt;li&gt;纯C语言，提供了非常强大的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GCD的优势&lt;ul&gt;
&lt;li&gt;GCD会自动利用更多的CPU内核&lt;/li&gt;
&lt;li&gt;GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）&lt;/li&gt;
&lt;li&gt;程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/categories/Objective-C/"/>
    
    
      <category term="多线程" scheme="http://www.wuqihan.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程基础篇</title>
    <link href="http://www.wuqihan.cn/2016/07/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.wuqihan.cn/2016/07/08/多线程基础/</id>
    <published>2016-07-08T02:05:17.000Z</published>
    <updated>2019-11-05T14:32:16.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>学习多线程之前，首先要了解什么是进程和线程，以及进程与线程的关系：</p><p><a href="https://book.douban.com/subject/7916129/" target="_blank" rel="noopener">《OS X and iOS Kernel Programming</a>》这本书中对进程和线程分别做了如下定义：</p><blockquote><p>When the user launches an application, the operating system loads the program’s code and data into memory from disk and begins executing its code. A program being executed is known as a “process.” Unlike a program, a process is an active entity, and consists of a snapshot of the state of the program at a single instance during execution.</p><p>Modern operating systems no longer treat processes as the basic units of operation, instead work with threads. A thread is merely a distinct register state, and more than one can exist in a given process. All threads share the virtual memory space, descriptors and handles.</p></blockquote><p><code>上面有这样一句话：A thread is merely a distinct register state(线程仅仅是一个不同的寄存器状态)。我对于这句话的理解就是线程相对于真实存在的进程来说，是一个相对虚拟的概念，仅仅是用不同的寄存器状态来区分不同的线程。由于我本身对操作系统了解还不够深入，所以我也不确定我的理解完全正确。</code></p><a id="more"></a><ul><li>进程：<ul><li>进程是指在系统中运行的一个应用程序。（比如打开QQ,就是打开了一个进程）</li><li>每个进程之间是相互独立的，每个进程均运行在受保护的内存空间内</li></ul></li><li>线程：<ul><li>一个进程想要执行任务，必须得有线程（每个进程至少有一条线程）</li><li>进程中的所有任务都是在线程中执行的</li></ul></li><li>总结：<ul><li>进程有独立的空间地址，而线程只是一个进程中的不同执行路径。</li><li>进程是资源分配的基本单位(进程是一块包含了某些资源的内存区域)。</li><li>线程是CPU独立运行和独立调度的基本单位(可以理解为一个进程中执行的代码片段)。 </li></ul></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>了解了进程和线程之后，那什么是多线程呢？</strong></p><p>1个进程中可以开启多条线程，每条线程中可以并行（同时）执行不同的任务。</p><p><strong>并发(concurrency)和并行(parallel)的区别</strong></p><p>并发(concurrency)：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</p><p>并行(parallel)：当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行。</p><p><strong>多线程并发执行的原理？</strong></p><p>在同一时间内。CPU只能处理1条线程，只有1条线程在工作（执行）。多线程并发（同时）执行，其实是CPU快速地在多线程之间调度（切换），如果CPU调度线程的时间足够快。那就造成了多线程并发执行的假象。</p><p><strong>合理利用线程：</strong></p><ul><li>优点<ul><li>能适当提高程序的执行效率</li><li>能适当提高资源利用率（CPU、内存利用率）</li></ul></li><li>缺点<ul><li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序性能</li><li>线程越多，CPU在调度线程上的开销就越大</li><li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li></ul></li></ul><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p><img src="https://i.loli.net/2019/11/04/OEh7HvtCBMQz2xV.png" alt="thread-state.png"></p><p>下面分别阐述线程周期中的每一步：</p><ul><li><strong>创建</strong>：实例化线程对象</li><li><strong>就绪</strong>/开启：向线程对象发送start消息，线程对象被加入可调度线程池等待CPU调度。</li><li><strong>运行</strong>：CPU负责调度可调度线程池中线程的执行。线程执行完毕之前，状态可能会在就绪和运行之间来回切换。就绪和运行之间的状态变化由CPU负责，程序员不能干预。</li><li><strong>阻塞</strong>：当满足某个预定条件时，可以使用休眠或锁，阻塞线程执行。sleepForTimeInterval（休眠指定时长），sleepUntilDate(休眠到指定日期),@synchronized(self)：(互斥锁)、metux锁、OSSpinLock锁等等。<strong>被阻塞的线程不在可调度线程池中，一旦阻塞就会从可调度线程池中移除</strong>。等到就绪转态时，又会重新加入可调度线程池。</li><li><strong>死亡</strong>：正常死亡，线程执行完毕。非正常死亡，当满足某个条件后，在线程内部中执行/在主线程中止线程对象。（注意，网上看到有很多资料说，线程死亡后，线程对象从内存中移除。这种说法肯定是错误的。线程死亡并不代表线程对象一定就从内存中移除了，还是要遵循引用计数，如果有其他对象对线程引用，那内存就不会释放。）</li></ul><p>NSThread - exit 和cancel</p><ul><li><p><code>+exit()</code>     </p><ul><li>一旦强行终止线程，后续的所有代码都不会被执行</li><li>exit线程死后，线程不能起死回生，不能再调用线程的start，否则会崩溃</li></ul></li><li><p><code>-cancel()</code>：取消，并不会直接取消线程，只是给线程对象添加isCancelled标记。</p></li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">    </span><br><span class="line">    self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(test) object:nil];</span><br><span class="line">    [self.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test &#123;</span><br><span class="line">    for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">        NSLog(@&quot;%d&quot;,i);</span><br><span class="line">        if (i == 20) &#123;</span><br><span class="line">            [self.thread cancel];//不会立马结束</span><br><span class="line">            //[NSThread exit];//会立马结束</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iOS中多线程的实现方案"><a href="#iOS中多线程的实现方案" class="headerlink" title="iOS中多线程的实现方案"></a>iOS中多线程的实现方案</h2><table><thead><tr><th>实现方案</th><th style="text-align:left">特点</th><th style="text-align:left">使用语言</th><th>使用频率</th><th>线程生命周期</th></tr></thead><tbody><tr><td>pthread</td><td style="text-align:left">1）跨平台，可移植；<br> 2）使用起来有点麻烦</td><td style="text-align:left">C</td><td>几乎不用</td><td>由程序员进行管理</td></tr><tr><td>NSThread</td><td style="text-align:left">1）面向对象；<br>2）简单，可以直接操作线程对象</td><td style="text-align:left">OC</td><td>偶尔</td><td>由程序员进行管理</td></tr><tr><td>GCD</td><td style="text-align:left">1）旨在替代NSThread等线程技术 <br>2）充分利用设备的多核</td><td style="text-align:left">C</td><td>经常</td><td>自动管理</td></tr><tr><td>NSOperation</td><td style="text-align:left">1）底层是GCD；<br>2）比GCD多了一些更简单实用的功能；<br>3）实用更加面向对象</td><td style="text-align:left">OC</td><td>经常</td><td>自动管理</td></tr></tbody></table><h3 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h3><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// import &lt;phtread.h&gt;</span></span><br><span class="line"><span class="hljs-comment">//1.创建线程对象</span></span><br><span class="line">    pthread_t thread;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//2.创建线程</span></span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">     第一个参数:线程对象 传递地址</span></span><br><span class="line"><span class="hljs-comment">     第二个参数:线程的属性 NULL</span></span><br><span class="line"><span class="hljs-comment">     第三个参数:指向函数的指针</span></span><br><span class="line"><span class="hljs-comment">     第四个参数:函数需要接受的参数</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    pthread_create(&amp;thread, <span class="hljs-literal">NULL</span>, task, <span class="hljs-literal">NULL</span>);</span><br></pre></td></tr></table></figure><h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//第一种创建线程的方式：alloc init.</span></span><br><span class="line"><span class="hljs-comment">//特点：需要手动开启线程，可以拿到线程对象进行详细设置</span></span><br><span class="line"><span class="hljs-comment">//创建线程</span></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">第一个参数：目标对象</span></span><br><span class="line"><span class="hljs-comment">第二个参数：选择器，线程启动要调用哪个方法</span></span><br><span class="line"><span class="hljs-comment">第三个参数：前面方法要接收的参数（最多只能接收一个参数，没有则传nil）</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-built_in">NSThread</span> *thread = [[<span class="hljs-built_in">NSThread</span> alloc]initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(run:) object:<span class="hljs-string">@"wendingding"</span>];</span><br><span class="line"><span class="hljs-comment">//启动线程</span></span><br><span class="line">[thread start];    </span><br><span class="line"><span class="hljs-comment">//第二种创建线程的方式：分离出一条子线程</span></span><br><span class="line"><span class="hljs-comment">//特点：自动启动线程，无法对线程进行更详细的设置</span></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">第一个参数：线程启动调用的方法</span></span><br><span class="line"><span class="hljs-comment">第二个参数：目标对象</span></span><br><span class="line"><span class="hljs-comment">第三个参数：传递给调用方法的参数</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line">[<span class="hljs-built_in">NSThread</span> detachNewThreadSelector:<span class="hljs-keyword">@selector</span>(run:) toTarget:<span class="hljs-keyword">self</span> withObject:<span class="hljs-string">@"我是分离出来的子线程"</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//第三种创建线程的方式：后台线程</span></span><br><span class="line"><span class="hljs-comment">//特点：自动启动线程，无法进行更详细设置</span></span><br><span class="line">[<span class="hljs-keyword">self</span> performSelectorInBackground:<span class="hljs-keyword">@selector</span>(run:) withObject:<span class="hljs-string">@"我是后台线程"</span>];</span><br></pre></td></tr></table></figure><h4 id="设置线程的属性"><a href="#设置线程的属性" class="headerlink" title="设置线程的属性"></a>设置线程的属性</h4><figure class="highlight obj-c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//设置线程的属性</span></span><br><span class="line"><span class="hljs-comment">//设置线程的名称</span></span><br><span class="line">thread.name = <span class="hljs-string">@"线程A"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//设置线程的优先级,注意线程优先级的取值范围为0.0~1.0之间，1.0表示线程的优先级最高,如果不设置该值，那么理想状态下默认为0.5</span></span><br><span class="line">thread.threadPriority = <span class="hljs-number">1.0</span>;</span><br></pre></td></tr></table></figure><h4 id="线程的状态-1"><a href="#线程的状态-1" class="headerlink" title="线程的状态"></a>线程的状态</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//线程的各种状态：新建-就绪-运行-阻塞-死亡</span><br><span class="line">//常用的控制线程状态的方法</span><br><span class="line">[NSThread exit];//退出当前线程</span><br><span class="line">[NSThread sleepForTimeInterval:2.0];//阻塞线程</span><br><span class="line">[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:2.0]];//阻塞线程</span><br><span class="line">//注意：线程死了不能复生</span><br></pre></td></tr></table></figure><h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="hljs-keyword">void</span>)touchesBegan:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//    [self download2];</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//开启一条子线程来下载图片</span></span><br><span class="line">    [<span class="hljs-built_in">NSThread</span> detachNewThreadSelector:<span class="hljs-keyword">@selector</span>(downloadImage) toTarget:<span class="hljs-keyword">self</span> withObject:<span class="hljs-literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="hljs-keyword">void</span>)downloadImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-comment">//1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源</span></span><br><span class="line">    <span class="hljs-built_in">NSURL</span> *url = [<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@"http://p6.qhimg.com/t01d2954e2799c461ab.jpg"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//2.根据url地址下载图片数据到本地（二进制数据</span></span><br><span class="line">    <span class="hljs-built_in">NSData</span> *data = [<span class="hljs-built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//3.把下载到本地的二进制数据转换成图片</span></span><br><span class="line">    <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> imageWithData:data];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//4.回到主线程刷新UI</span></span><br><span class="line">    <span class="hljs-comment">//4.1 第一种方式</span></span><br><span class="line"><span class="hljs-comment">//    [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES];</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//4.2 第二种方式</span></span><br><span class="line"><span class="hljs-comment">//    [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES];</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//4.3 第三种方式</span></span><br><span class="line">    [<span class="hljs-keyword">self</span>.imageView performSelector:<span class="hljs-keyword">@selector</span>(setImage:) onThread:[<span class="hljs-built_in">NSThread</span> mainThread] withObject:image waitUntilDone:<span class="hljs-literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><blockquote><p>CGD源码：<a href="https://github.com/apple/swift-corelibs-libdispatch" target="_blank" rel="noopener">https://github.com/apple/swift-corelibs-libdispatch</a></p></blockquote><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>两个核心概念:队列和任务</li><li>同步函数和异步函数</li></ul><h4 id="GCD基本使用"><a href="#GCD基本使用" class="headerlink" title="GCD基本使用"></a>GCD基本使用</h4><ul><li>异步函数+并发队列：开启多条线程，并发执行任务</li><li>异步函数+串行队列：开启一条线程，串行执行任务</li><li>同步函数+并发队列：不开线程，串行执行任务</li><li>同步函数+串行队列：不开线程，串行执行任务</li><li>异步函数+主队列：不开线程，在主线程中串行执行任务</li><li>同步函数+主队列：不开线程，串行执行任务（注意死锁发生）</li></ul><p><strong>注意同步函数和异步函数在执行顺序上面的差异</strong></p><h4 id="GCD间线程通信"><a href="#GCD间线程通信" class="headerlink" title="GCD间线程通信"></a>GCD间线程通信</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//0.获取一个全局的队列</span></span><br><span class="line">    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//1.先开启一个线程，把下载图片的操作放在子线程中处理</span></span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">       <span class="hljs-comment">//2.下载图片</span></span><br><span class="line">        <span class="hljs-built_in">NSURL</span> *url = [<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@"http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg"</span>];</span><br><span class="line">        <span class="hljs-built_in">NSData</span> *data = [<span class="hljs-built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> imageWithData:data];</span><br><span class="line"></span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"下载操作所在的线程--%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//3.回到主线程刷新UI</span></span><br><span class="line">        <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">           <span class="hljs-keyword">self</span>.imageView.image = image;</span><br><span class="line">           <span class="hljs-comment">//打印查看当前线程</span></span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"刷新UI---%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="GCD其他常用函数"><a href="#GCD其他常用函数" class="headerlink" title="GCD其他常用函数"></a>GCD其他常用函数</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="hljs-comment">//栅栏函数（控制任务的执行顺序）</span></span><br><span class="line"> dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">     <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"--dispatch_barrier_async-"</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="hljs-comment">//延迟执行（延迟·控制在哪个线程执行）</span></span><br><span class="line">   dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">2.0</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">     <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"---%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 一次性代码（注意不能放到懒加载）</span></span><br><span class="line"> -(<span class="hljs-keyword">void</span>)once</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="hljs-comment">//整个程序运行过程中只会执行一次</span></span><br><span class="line">     <span class="hljs-comment">//onceToken用来记录该部分的代码是否被执行过</span></span><br><span class="line">     <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">     <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">         <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"-----"</span>);</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="hljs-comment">// 快速迭代（开多个线程并发完成迭代操作）</span></span><br><span class="line">    dispatch_apply(subpaths.count, queue, ^(size_t index) &#123;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="hljs-comment">// 队列组（同栅栏函数）</span></span><br><span class="line"> <span class="hljs-comment">//创建队列组</span></span><br><span class="line"> dispatch_group_t group = dispatch_group_create();</span><br><span class="line"> <span class="hljs-comment">//队列组中的任务执行完毕之后，执行该函数</span></span><br><span class="line"> dispatch_group_notify(dispatch_group_t group,<span class="hljs-built_in">dispatch_queue_t</span> queue,dispatch_block_t block);</span><br><span class="line"></span><br><span class="line"> <span class="hljs-comment">// 进入群组和离开群组</span></span><br><span class="line"> dispatch_group_enter(group);<span class="hljs-comment">//执行该函数后，后面异步执行的block会被gruop监听</span></span><br><span class="line"> dispatch_group_leave(group);<span class="hljs-comment">//异步block中，所有的任务都执行完毕，最后离开群组</span></span><br><span class="line"> <span class="hljs-comment">//注意：dispatch_group_enter|dispatch_group_leave必须成对使用</span></span><br></pre></td></tr></table></figure><h3 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h3><p>（1）基本概念</p><ul><li>NSOperation是对GCD的包装</li><li>两个核心概念【队列+操作】</li></ul><p>（2）基本使用</p><ul><li>NSOperation本身是抽象类，只能使用它的子类</li><li>三个子类分别是：NSBlockOperation、NSInvocationOperation以及自定义继承自NSOperation的类</li><li>NSOperation和NSOperationQueue结合使用实现多线程并发</li></ul><p>（3）相关代码</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//  01 NSInvocationOperation</span></span><br><span class="line">    <span class="hljs-comment">//1.封装操作</span></span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">     第一个参数：目标对象</span></span><br><span class="line"><span class="hljs-comment">     第二个参数：该操作要调用的方法，最多接受一个参数</span></span><br><span class="line"><span class="hljs-comment">     第三个参数：调用方法传递的参数，如果方法不接受参数，那么该值传nil</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-built_in">NSInvocationOperation</span> *operation = [[<span class="hljs-built_in">NSInvocationOperation</span> alloc]</span><br><span class="line">                                        initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(run) object:<span class="hljs-literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//2.启动操作</span></span><br><span class="line">    [operation start];</span><br><span class="line">-------------------------------------------------</span><br><span class="line">    <span class="hljs-comment">//  02 NSBlockOperation</span></span><br><span class="line">    <span class="hljs-comment">//1.封装操作</span></span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">     NSBlockOperation提供了一个类方法，在该类方法中封装操作</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-built_in">NSBlockOperation</span> *operation = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="hljs-comment">//在主线程中执行</span></span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"---download1--%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//2.追加操作，追加的操作在子线程中执行</span></span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"---download2--%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">         <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"---download3--%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//3.启动执行操作</span></span><br><span class="line">    [operation start];</span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="hljs-comment">// 03 自定义NSOperation</span></span><br><span class="line">    <span class="hljs-comment">//如何封装操作？</span></span><br><span class="line">    <span class="hljs-comment">//自定义的NSOperation,通过重写内部的main方法实现封装操作</span></span><br><span class="line">    -(<span class="hljs-keyword">void</span>)main</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"--main--%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h2&gt;&lt;p&gt;学习多线程之前，首先要了解什么是进程和线程，以及进程与线程的关系：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/7916129/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《OS X and iOS Kernel Programming&lt;/a&gt;》这本书中对进程和线程分别做了如下定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When the user launches an application, the operating system loads the program’s code and data into memory from disk and begins executing its code. A program being executed is known as a “process.” Unlike a program, a process is an active entity, and consists of a snapshot of the state of the program at a single instance during execution.&lt;/p&gt;
&lt;p&gt;Modern operating systems no longer treat processes as the basic units of operation, instead work with threads. A thread is merely a distinct register state, and more than one can exist in a given process. All threads share the virtual memory space, descriptors and handles.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;上面有这样一句话：A thread is merely a distinct register state(线程仅仅是一个不同的寄存器状态)。我对于这句话的理解就是线程相对于真实存在的进程来说，是一个相对虚拟的概念，仅仅是用不同的寄存器状态来区分不同的线程。由于我本身对操作系统了解还不够深入，所以我也不确定我的理解完全正确。&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.wuqihan.cn/categories/iOS/"/>
    
      <category term="多线程" scheme="http://www.wuqihan.cn/categories/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://www.wuqihan.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
