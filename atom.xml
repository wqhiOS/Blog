<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吴启晗的技术博客</title>
  
  <subtitle>hard work pays off</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wuqihan.cn/"/>
  <updated>2019-07-08T12:15:57.170Z</updated>
  <id>http://www.wuqihan.cn/</id>
  
  <author>
    <name>吴启晗</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>优雅的使用NSNotification.Name</title>
    <link href="http://www.wuqihan.cn/2018/05/18/%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8NSNotification-name/"/>
    <id>http://www.wuqihan.cn/2018/05/18/优雅的使用NSNotification-name/</id>
    <published>2018-05-18T04:34:36.000Z</published>
    <updated>2019-07-08T12:15:57.170Z</updated>
    
    <content type="html"><![CDATA[<p>Swift 3之前使用通知：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-type">NSNotificationCenter</span>.defaultCenter().post(<span class="hljs-string">"kReceiveMessageNoti"</span>)</span><br></pre></td></tr></table></figure><p>Swift 3之后</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-type">NotificationCenter</span>.<span class="hljs-keyword">default</span>.post(<span class="hljs-type">Notification</span>.<span class="hljs-type">Name</span>(rawValue: <span class="hljs-string">"kReceiveMessageNoti"</span>))</span><br></pre></td></tr></table></figure><a id="more"></a><p>显然 这种使用全局字符串常亮的方法不是很好。</p><p>我在阅读<code>Almofire</code>的时候发现，作者是这样使用通知的：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Notification</span>.<span class="hljs-title">Name</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Task</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> <span class="hljs-type">DidResume</span> = <span class="hljs-type">Notification</span>.<span class="hljs-type">Name</span>(rawValue: <span class="hljs-string">"org.alamofire.notification.name.task.didResume"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-type">NotificationCenter</span>.<span class="hljs-keyword">default</span>.post(</span><br><span class="line">            name: <span class="hljs-type">Notification</span>.<span class="hljs-type">Name</span>.<span class="hljs-type">Task</span>.<span class="hljs-type">DidResume</span>,</span><br><span class="line">            object: <span class="hljs-keyword">self</span>,</span><br><span class="line">            userInfo: [<span class="hljs-type">Notification</span>.<span class="hljs-type">Key</span>.<span class="hljs-type">Task</span>: task]</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>利用<code>extension</code>为Notification.Name添加一个结构体，在结构体上添加 静态常量办法。直接使用静态常量就可以，但是作者又使用了 结构体，这样做的好处是为了给通知名称分类。</p><p>显然这种方法比我们直接使用常量字符串要好很多。下面。再给出我使用enum的方法</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DDNotificationName</span>: <span class="hljs-title">String</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">/// 注销成功</span></span><br><span class="line">    <span class="hljs-keyword">case</span> logoutSuccess</span><br><span class="line">    <span class="hljs-comment">/// 登录成功</span></span><br><span class="line">    <span class="hljs-keyword">case</span> loginSuccess</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//收到消息</span></span><br><span class="line">    <span class="hljs-keyword">case</span> receiveMessage</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">var</span> name: <span class="hljs-type">NSNotification</span>.<span class="hljs-type">Name</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-type">NSNotification</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"k"</span> + rawValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-type">NotificationCenter</span>.<span class="hljs-keyword">default</span>.post(name: <span class="hljs-type">DDNotificationName</span>.loginSuccess.name, object: <span class="hljs-literal">nil</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift 3之前使用通知：&lt;/p&gt;
&lt;figure class=&quot;highlight swift hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;NSNotificationCenter&lt;/span&gt;.defaultCenter().post(&lt;span class=&quot;hljs-string&quot;&gt;&quot;kReceiveMessageNoti&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Swift 3之后&lt;/p&gt;
&lt;figure class=&quot;highlight swift hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-type&quot;&gt;NotificationCenter&lt;/span&gt;.&lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt;.post(&lt;span class=&quot;hljs-type&quot;&gt;Notification&lt;/span&gt;.&lt;span class=&quot;hljs-type&quot;&gt;Name&lt;/span&gt;(rawValue: &lt;span class=&quot;hljs-string&quot;&gt;&quot;kReceiveMessageNoti&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.wuqihan.cn/categories/Swift/"/>
    
    
      <category term="swift tips" scheme="http://www.wuqihan.cn/tags/swift-tips/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Block</title>
    <link href="http://www.wuqihan.cn/2018/01/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Block/"/>
    <id>http://www.wuqihan.cn/2018/01/11/深入理解Block/</id>
    <published>2018-01-11T08:52:33.000Z</published>
    <updated>2018-08-18T03:09:24.799Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fp58b4pem0j308c04owem.jpg" alt="961b7caed0225e03fea7cb75de43b540"></p><a id="more"></a><h4 id="Block的实质"><a href="#Block的实质" class="headerlink" title="Block的实质"></a>Block的实质</h4><p>Block是“带有自动变量值的匿名函数”，Block实际上是作为极普通的C语言源代码来处理的。通过支持Block的编译器，含有Block语法的源代码转换为一般C语言编译器能够处理的源代码，并作为极普通的C语言源代码被编译。</p><p>在实际编译时无法转换为我们能够理解的源代码，但clang(LLVM编译器)具有转换为我们可读源代码的功能。通过“-rewrite-objc”选项就能将含有Block语法的源代码转换为C++源代码。说是C++，其实也仅仅是使用了struct结构体，本质是C语言源代码。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">void</span> (^blk)(<span class="hljs-keyword">void</span>) = ^&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Block\n"</span>);&#125;;</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此源代码的Block语法最为简单，它省略了返回值类型以及参数列表。通过clang可变换为一下形式：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">void</span> *isa;</span><br><span class="line">  <span class="hljs-keyword">int</span> Flags;</span><br><span class="line">  <span class="hljs-keyword">int</span> Reserved;</span><br><span class="line">  <span class="hljs-keyword">void</span> *FuncPtr;<span class="hljs-comment">//函数指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//__main_block_impl_0结构体相当于基于objc_object结构体的Objective-C对象的结构体。</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span></span><br><span class="line">  <span class="hljs-comment">//结构体的构造函数</span></span><br><span class="line">  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) &#123;</span><br><span class="line">    <span class="hljs-comment">//通过isa指针，可以想到block实质是OC的对象</span></span><br><span class="line">    <span class="hljs-comment">// isa指向block的类对象objc_class结构体。block的类对象通过&amp;_NSConcreteStackBlock初始化。</span></span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    <span class="hljs-comment">//impl.FuncPtr保存block执行的内容。在这里就是__main_block_func_0这个c语言函数</span></span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//- 通过block使用的匿名函数实际上是被作为简单的c语言函数来处理。另外根据block语法所属的函数名(此处为main)和该block语法所在该函数出现的顺序值(此处为0)来给经clang变换的函数命名。</span></span><br><span class="line"><span class="hljs-comment">//- 该函数的参数__cself相当于c++实例方法中指向实例自身的变量this，或是OC中的self，即__cself为指向Block值得变量。</span></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Block\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">size_t</span> reserved;</span><br><span class="line">  <span class="hljs-keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">void</span> (*blk)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">    ((<span class="hljs-keyword">void</span> (*)(·__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法中，初始化了block，并调用了执行了block，通过clang转换的源代码由于转换较多，看起来不是很清楚，这里优化去掉转换部分，具体如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//该源代码将__main_block_impl_0结构体类型的自动变量，即栈上生成的__main_block_impl_0结构体实例的指针，赋值给__main_block_impl_0结构体指针类型的变量。</span></span><br><span class="line"><span class="hljs-comment">//下面两行对应的代码是：void (^blk)(void) = ^&#123;printf("Block\n");&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//__main_block_impl_0的构造函数需要传入两个参数，上面源代码中构造函数参数有3个，最后一个有默认值，可以不传，所以这里传的是两个参数：</span></span><br><span class="line"><span class="hljs-comment">//- 第一个参数是block中所执行的具体内容，由block语法转换的C语言函数。</span></span><br><span class="line"><span class="hljs-comment">//- 第二个参数是静态全局变量初始化的__main_block_desc_0结构体实例指针。</span></span><br><span class="line"><span class="hljs-comment">// 对应这一部分源代码：</span></span><br><span class="line"><span class="hljs-comment">//  static struct __main_block_desc_0 &#123;</span></span><br><span class="line"><span class="hljs-comment">//  size_t reserved;</span></span><br><span class="line"><span class="hljs-comment">//  size_t Block_size;</span></span><br><span class="line"><span class="hljs-comment">//  &#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span></span><br><span class="line"><span class="hljs-comment">//  由此可知，该源代码使用block，即__main_block_impl_0结构体实例的大小进行初始化。</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> <span class="hljs-title">tmp</span> = __<span class="hljs-title">main_block_impl_0</span>(__<span class="hljs-title">main_block_func_0</span>,&amp;__<span class="hljs-title">main_block_desc_0_DATA</span>);</span><span class="hljs-comment">//这里调用的是__main_block_impl_0的构造函数</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> *<span class="hljs-title">blk</span> = &amp;<span class="hljs-title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//这就是简单地使用函数指针调用函数，通过clang编译后的源代码可知，传入的参数__cself,这里为blk，所以也证明了__cself指向block自身。</span></span><br><span class="line">(*blk-&gt;impl.FuncPtr)(blk);</span><br></pre></td></tr></table></figure><h4 id="截获自动变量值"><a href="#截获自动变量值" class="headerlink" title="截获自动变量值"></a>截获自动变量值</h4><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">int</span> dmy = <span class="hljs-number">256</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> val = <span class="hljs-number">10</span>;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt = <span class="hljs-string">"val = %d\n"</span>;</span><br><span class="line">    <span class="hljs-keyword">void</span> (^blk)(<span class="hljs-keyword">void</span>) = ^&#123;<span class="hljs-built_in">printf</span>(fmt,val);&#125;;</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面截获自动变量值得源代码通过clang进行转换：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span></span><br><span class="line">  <span class="hljs-comment">/*block语法表达式中使用的自动变量被作为成员变量追加到了__main_block_impl_0结构体中：fmt、val没有使用的局部变量不会被追加*/</span></span><br><span class="line">  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt;</span><br><span class="line">  <span class="hljs-keyword">int</span> val;</span><br><span class="line">  <span class="hljs-comment">/*在初始化结构体实例时，根据传递给构造函数的参数对由自动变量追加的成员变量进行初始化。由此可知，在__main_block_impl_0结构体实例中，自动变量值被截获*/</span></span><br><span class="line">  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *_fmt, <span class="hljs-keyword">int</span> _val, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : fmt(_fmt), val(_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="hljs-comment">//bound by copy这里的注释表示，block对它引用的局部变量做了只读拷贝，也就是说block引用的是局部变量的副本。所以在执行block语法后，即使改写block中使用的局部变量的值也不会影响block执行时局部变量的值。</span></span><br><span class="line">  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt = __cself-&gt;fmt; <span class="hljs-comment">// bound by copy</span></span><br><span class="line">  <span class="hljs-keyword">int</span> val = __cself-&gt;val; <span class="hljs-comment">// bound by copy</span></span><br><span class="line">  <span class="hljs-built_in">printf</span>(fmt,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">size_t</span> reserved;</span><br><span class="line">  <span class="hljs-keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> dmy = <span class="hljs-number">256</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> val = <span class="hljs-number">10</span>;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt = <span class="hljs-string">"val = %d\n"</span>;</span><br><span class="line">    <span class="hljs-keyword">void</span> (*blk)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val));</span><br><span class="line"></span><br><span class="line">    ((<span class="hljs-keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，所谓“截获自动变量值”意味着在执行block语法时，block语法表达式所使用的自动变量值来保存到block的结构体实例中。</p><p>另外需要注意的是，block不能直接使用C语言数组类型的自动变量。为什么呢？因为block截获自动变量时，是通过将值传递给结构体的构造函数进行保存。因为c语言不允许这种赋值</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">char</span> a[<span class="hljs-number">10</span>])</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">char</span> b[<span class="hljs-number">10</span>] = a;<span class="hljs-comment">//此处报错：Array initializer must be an initializer or string literal</span></span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,b[<span class="hljs-number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="block说明符"><a href="#block说明符" class="headerlink" title="__block说明符"></a>__block说明符</h4><p>再来回顾前面截获自动变量值得例子</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^&#123;<span class="hljs-built_in">printf</span>(fmt,val);&#125;</span><br></pre></td></tr></table></figure><p>该源代码转换如下</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt = __cself-&gt;fmt; <span class="hljs-comment">// bound by copy</span></span><br><span class="line">  <span class="hljs-keyword">int</span> val = __cself-&gt;val; <span class="hljs-comment">// bound by copy</span></span><br><span class="line">  <span class="hljs-built_in">printf</span>(fmt,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>block中所使用的被截获自动变量就如“带有自动变量值的匿名函数”所说，仅截获自动变量。block中使用自动变量后，在block的结构体实例中重写该自动变量也不会改变原先截获的自动变量。</p><p>如果在block中修改截获自动变量的值会产生编译错误，因为在实现上不能改写截获自动变量的值。</p><p>解决这种问题有两个方法。</p><h5 id="第一种：C语言中有几种变量允许block改写值："><a href="#第一种：C语言中有几种变量允许block改写值：" class="headerlink" title="第一种：C语言中有几种变量允许block改写值："></a>第一种：C语言中有几种变量允许block改写值：</h5><ul><li>静态局部变量</li><li>静态全局变量</li><li>全局变量</li></ul><p>虽然block语法的匿名函数部分简单地变换为了c语言函数，但从这个变换的函数中访问静态全局变量/全局变量并没有任何改变，可直接使用。但是静态局部变量的情况下，转换后的函数原本就设置在含有block语法的函数外面，所以无法在变量作用域访问。</p><p>看一下下面的代码：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> global_val = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> static_global_val = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> static_val = <span class="hljs-number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">void</span> (^blk)(<span class="hljs-keyword">void</span>) = ^&#123;</span><br><span class="line">        global_val *= <span class="hljs-number">1</span>;</span><br><span class="line">        static_global_val *= <span class="hljs-number">2</span>;</span><br><span class="line">        static_val *= <span class="hljs-number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码转换后如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> global_val = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> static_global_val = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span></span><br><span class="line">  <span class="hljs-comment">//将静态局部变量的地址作为成员变量保存</span></span><br><span class="line">  <span class="hljs-keyword">int</span> *static_val;</span><br><span class="line">  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="hljs-keyword">int</span> *_static_val, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : static_val(_static_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> *static_val = __cself-&gt;static_val; <span class="hljs-comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">  global_val *= <span class="hljs-number">1</span>;</span><br><span class="line">  static_global_val *= <span class="hljs-number">2</span>;</span><br><span class="line">  (*static_val) *= <span class="hljs-number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">size_t</span> reserved;</span><br><span class="line">  <span class="hljs-keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> static_val = <span class="hljs-number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">void</span> (*blk)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val));</span><br><span class="line"></span><br><span class="line">    ((<span class="hljs-keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过转换后的代码可以得知，对静态全局变量和全局变量的访问与转换前完全相同，因为他们是全局变量，不管在哪里都可以访问到，没有作用域的限制。但是对于静态局部变量，为什么要使用指针来访问呢？</p><p>因为静态局部变量在其所在函数结束后，是仍然存在的（自动变量在函数结束后就不存在），但又因为在其他函数中无法引用到该静态局部变量，所以通过将静态局部变量的指针传递给block结构体的构造函数并作为成员变量保存，是超出作用域使用静态局部变量的最简单方法。</p><p>静态局部变量的这种方法也适用于自动变量的访问。但是我们为什么没有这么做呢？因为前面已经提到了，在变量作用域结束的同时，静态局部变量没有被废弃，而自动变量被废弃掉了，所以将不能通过指针访问原来的自动变量。</p><h5 id="第二种方法是使用”-block说明符”"><a href="#第二种方法是使用”-block说明符”" class="headerlink" title="第二种方法是使用”__block说明符”"></a>第二种方法是使用”__block说明符”</h5><p>”<code>__block</code>说明符“,更准确的表述方式为”__block存储域类说明符”。</p><p>下面是使用__block修饰自动变量的代码：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    __block <span class="hljs-keyword">int</span> val = <span class="hljs-number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">void</span> (^blk)(<span class="hljs-keyword">void</span>) = ^ &#123;</span><br><span class="line">        val = <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码变换后如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">Block_byref_val_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">void</span> *__isa;</span><br><span class="line">  __Block_byref_val_0 *__forwarding;</span><br><span class="line">  <span class="hljs-keyword">int</span> __flags;</span><br><span class="line">  <span class="hljs-keyword">int</span> __size;</span><br><span class="line">  <span class="hljs-keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span></span><br><span class="line">  __Block_byref_val_0 *val; <span class="hljs-comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    </span><br><span class="line">    __Block_byref_val_0 *val = __cself-&gt;val; <span class="hljs-comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">    (val-&gt;__forwarding-&gt;val) = <span class="hljs-number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((<span class="hljs-keyword">void</span>*)&amp;dst-&gt;val, (<span class="hljs-keyword">void</span>*)src-&gt;val, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="hljs-keyword">void</span>*)src-&gt;val, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">size_t</span> reserved;</span><br><span class="line">  <span class="hljs-keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="hljs-keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="hljs-keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(__Block_byref_val_0), <span class="hljs-number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">void</span> (*blk)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="hljs-number">570425344</span>));</span><br><span class="line">    ((<span class="hljs-keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是在自动变量上附加了__block说明符，源代码量就急剧增加。</p><p>__block修饰的val变量</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="hljs-keyword">int</span> val = <span class="hljs-number">10</span>;</span><br></pre></td></tr></table></figure><p>，转换成了：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">Block_byref_val_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">void</span> *__isa;</span><br><span class="line">  __Block_byref_val_0 *__forwarding;</span><br><span class="line">  <span class="hljs-keyword">int</span> __flags;</span><br><span class="line">  <span class="hljs-keyword">int</span> __size;</span><br><span class="line">  <span class="hljs-keyword">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里能够发现，__block修饰的自动变量也同block一样变成了__Block_byref_val<em>0结构体类型的自动变量，即栈上生成的\</em>_Block_byref_val_0结构体实例。</p><p>再来看一下__block变量赋值的代码：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ &#123;</span><br><span class="line">       val = <span class="hljs-number">1</span>;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>该源代码转换如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    </span><br><span class="line">    __Block_byref_val_0 *val = __cself-&gt;val; <span class="hljs-comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">    (val-&gt;__forwarding-&gt;val) = <span class="hljs-number">1</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>block的__main_block_impl<em>0结构体实例持有指向变量的\</em>_Block_byref_bal_0结构体实例的指针。__Block_byref_bal_0结构体实例的成员变量__forwarding持有指向该实例自身的指针。通过成员变量__forwarding访问成员变量val。</p><p>这里会遇到3个问题</p><p>1.为什么_<em>block变量的\</em>_Block_byref_val_0结构体不放在__main_block_impl_0结构体中？</p><p>这样做是为了在多个Block中使用__block变量。达到复用效果，从而节省不必要的空间开销。</p><p>2.block超出变量作用域可存在的理由</p><p>3.__block变量的结构体成员变量__forwarding存在的理由。</p><p>问题2和3，留到下面讲解</p><h4 id="Block存储域"><a href="#Block存储域" class="headerlink" title="Block存储域"></a>Block存储域</h4><p>通过前面的说明可知，block转换为block的结构体类型的自动变量，_<em>block变量转换为\</em>_block变量的结构体类型的自动变量。</p><p>block也是Objective-C对象，block的类有：</p><ul><li>_NSConcreteStackBlock</li><li>_NSConcreteGlobalBlock</li><li>_NSConcreteMallocBlock</li></ul><h5 id="全局block"><a href="#全局block" class="headerlink" title="全局block"></a>全局block</h5><p>特点：应用程序在它就在。</p><ul><li>在记录全局变量的地方写block的时候，block为全局block</li><li>不在书写全局变量的地方，只要不截获自动变量，不管用什么修饰符修饰，都是全局block。</li></ul><p>全局变量全部粗放在静态存储区，在程序开始执行时给全局变量分配存储区，程序执行完毕就释放。它们占据固定的存储单元。</p><h5 id="栈block"><a href="#栈block" class="headerlink" title="栈block"></a>栈block</h5><p>特点：声明周期由系统控制，超出其所在作用域即销毁。</p><p>截获自动变量且没有强指针引用的时候，为栈block。栈block因为存储在栈上，所以在超出其作用域时被销毁，不会存在了。</p><p>在ARC下。会默认添加__strong修饰符，所以很少会出现栈block。</p><p>大多数情况编译器会会在适当的地方添加修饰，把block从栈复制到堆，比如将block作为函数返回值时。不过在此之外的情况下需要手动生成代码，将block从栈复制到堆上。</p><p>编译器不能进行判断是什么样的状况呢？如下所示：</p><ul><li>向方法或函数的参数中传递block时</li></ul><p>但是如果在方法或函数内部适当地复制了传递过来的参数，那么就不必在调用该方法或函数前手动复制了。以下方法或函数不用手动复制：</p><ul><li>Cocoa框架的方法且方法名中含有usingBlock等时</li><li>GCD的api</li></ul><p>以下两个例子在ARC下都为栈block：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (id)getBlockArray &#123;</span><br><span class="line">    int val = 10;</span><br><span class="line">    return [[NSArrary alloc] initWithObjects:</span><br><span class="line">            ^&#123;NSLog(@&quot;blk0:%d&quot;,val);&#125;,</span><br><span class="line">            ^&#123;NSLog(@&quot;blk0:%d&quot;,val);&#125;,</span><br><span class="line">            nil</span><br><span class="line">           ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//栈block</span><br><span class="line">int i = 0;</span><br><span class="line">NSLog(@&quot;%@&quot;,^&#123;NSLog(@&quot;%d&quot;,i);&#125;);//输出结果 __NSStackBlock__: 0x7fff57aada78&gt;</span><br></pre></td></tr></table></figure><h5 id="堆block"><a href="#堆block" class="headerlink" title="堆block"></a>堆block</h5><p>特点：没有强指针引用即销毁，生命周期由程序员手动管理</p><p>栈block有强指针strong/copy引用就会被copy到堆中，变成堆block</p><p>通过对着3类block的解释，也解释了为什么block在超出其作用域仍然可以存在。</p><h4 id="block变量存储域"><a href="#block变量存储域" class="headerlink" title="__block变量存储域"></a>__block变量存储域</h4><p>block从栈复制到堆时对__block变量产生的影响：</p><table><thead><tr><th>__block变量的配置存储域</th><th>block从栈复制到堆时的影响</th></tr></thead><tbody><tr><td>栈</td><td>从栈复制到堆并被block持有</td></tr><tr><td>堆</td><td>被block持有</td></tr></tbody></table><p>在一个block中使用_<em>block变量，则当该block从栈复制到堆时，使用的所有\</em>_block变量也必定配置在栈上。这些__block变量也全部从栈复制到对上。此时block持有__block变量。即使在该block已复制到堆的情况下，复制Block也对所使用的__block变量没有任何影响。</p><p>在多个block中使用__block变量，因为最先会将所有的block配置在栈上，所以__block变量也会配置在栈上。在任何一个block从栈复制到堆时，__block变量也会一并从栈复制到堆并被该block所持有。当剩下的block从栈复制到堆时，被复制的block持有__block变量，并增加__block变量的引用计数。</p><p>如果配置在堆上的block被废弃，那么它会释放所持有的_<em>block变量，当该\</em>_block变量没有持有者时，就会释放。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fpkftl2r3nj30zk0rhk62.jpg" alt="IMG_49827612A50D-1"></p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fpr8jswvinj31a40zqn1e.jpg" alt="01522122826_.pic_h"></p><p>到这里我们可以看出，此思考方式与OC的引用计数内存管理完全相同。</p><p>看如下源代码：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    __block <span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//在arc下，不用copy就可以了。因为默认会有__strong修饰符</span></span><br><span class="line">    <span class="hljs-keyword">void</span> (^blk)(<span class="hljs-keyword">void</span>) = [^&#123;++val;&#125; copy];</span><br><span class="line">    </span><br><span class="line">    ++val;</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">    <span class="hljs-comment">//打印结果为2。说明栈上的val结构体，和堆上的val结构体，指向同一块内存地址。为什么呢？下面会给出答案。</span></span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span></span><br><span class="line">  __Block_byref_val_0 *val; <span class="hljs-comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="hljs-comment">// bound by ref</span></span><br><span class="line">  ++(val-&gt;__forwarding-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="hljs-keyword">void</span>*)&amp;dst-&gt;val, (<span class="hljs-keyword">void</span>*)src-&gt;val, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="hljs-keyword">void</span>*)src-&gt;val, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">size_t</span> reserved;</span><br><span class="line">  <span class="hljs-keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="hljs-keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="hljs-keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//只留下main函数，其他部分这里省略</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(__Block_byref_val_0), <span class="hljs-number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">void</span> (*blk)(<span class="hljs-keyword">void</span>) = ((<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="hljs-number">570425344</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//注意这里！</span></span><br><span class="line">    ++(val.__forwarding-&gt;val);</span><br><span class="line">    </span><br><span class="line">    ((<span class="hljs-keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,(val.__forwarding-&gt;val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述源代码中，利用copy方法复制使用了_<em>block变量的block，block和\</em>_block变量两者均从栈复制到了堆上。代码中有两处使用到了val，一处是在block的匿名函数里，使用的是堆上的val，另一处是复制前栈上的__block变量的结构体实例的地址。</p><p>那是如何保证，不管__block变量是配置在栈上还是堆上，都能够正确的访问该变量呢？</p><p><strong>因为栈上的_<em>block变量用结构体实例在\</em>_block变量从栈复制到堆上时，会将成员变量__forwarding的值替换为复制目标上的__block变量结构体实例的地址。所以就算使用栈上的__block变量。访问的其实还是堆上的那个。</strong>如下图所示：</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fprelrguffj30ms0h3tgb.jpg" alt="mage-20180327152425"></p><p>通过该功能，无论是在block语法中、block语法外使用_<em>block变量，还是\</em>_block变量配置在栈上或堆上，都可以顺利地访问同一个__block变量。</p><h4 id="截获对象"><a href="#截获对象" class="headerlink" title="截获对象"></a>截获对象</h4><p>来看一下在block语法中使用对象的语法：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">blk_t blk;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">NSMutableArray</span> *array = [[<span class="hljs-built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    blk = ^(<span class="hljs-keyword">id</span> obj) &#123;</span><br><span class="line">        [array addObject:obj];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">blk([<span class="hljs-built_in">NSObject</span> new]);</span><br><span class="line">blk([<span class="hljs-built_in">NSObject</span> new]);</span><br><span class="line">blk([<span class="hljs-built_in">NSObject</span> new]);</span><br></pre></td></tr></table></figure><p>变量作用域结束的同时，变量array被废弃，其强引用失效，因此赋值给变量的array的NSMutableArray类的对象必定被释放并废弃。但是上述代码能够运行正常。这一结果意味着赋值给变量array的NSMutableArray类的对象在该源代码最后block的执行部分超出其作用域而存在。通过编译转换后的代码如下：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-keyword">blk_t</span>)</span><span class="hljs-params">(id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span></span><br><span class="line">  id <span class="hljs-built_in">array</span>;<span class="hljs-comment">//这里是在arc环境下，默认有__strong修饰符。强引用</span></span><br><span class="line">  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, id _array, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : <span class="hljs-built_in">array</span>(_array) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself, id obj) &#123;</span><br><span class="line">  id <span class="hljs-built_in">array</span> = __cself-&gt;<span class="hljs-built_in">array</span>; <span class="hljs-comment">// bound by copy</span></span><br><span class="line">  ((<span class="hljs-keyword">void</span> (*)(id, SEL, ObjectType))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)<span class="hljs-built_in">array</span>, sel_registerName(<span class="hljs-string">"addObject:"</span>), (id)obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="hljs-keyword">void</span>*)&amp;dst-&gt;<span class="hljs-built_in">array</span>, (<span class="hljs-keyword">void</span>*)src-&gt;<span class="hljs-built_in">array</span>, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="hljs-keyword">void</span>*)src-&gt;<span class="hljs-built_in">array</span>, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-keyword">size_t</span> reserved;</span><br><span class="line">  <span class="hljs-keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="hljs-keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="hljs-keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/* @autoreleasepool */</span></span><br><span class="line">    &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">     </span><br><span class="line">     <span class="hljs-keyword">blk_t</span> blk;</span><br><span class="line">     </span><br><span class="line">        &#123;</span><br><span class="line">            id <span class="hljs-built_in">array</span> = ((NSMutableArray *(*)(id, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)((NSMutableArray *(*)(id, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="hljs-string">"NSMutableArray"</span>), sel_registerName(<span class="hljs-string">"alloc"</span>)), sel_registerName(<span class="hljs-string">"init"</span>));</span><br><span class="line"></span><br><span class="line">            blk = ((<span class="hljs-keyword">void</span> (*)(id))&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, <span class="hljs-built_in">array</span>, <span class="hljs-number">570425344</span>));</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="hljs-comment">//(*blk-&gt;impl.FuncPtr)(blk, [NSObject new]);</span></span><br><span class="line">        ((<span class="hljs-keyword">void</span> (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSObject *(*)(id, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="hljs-string">"NSObject"</span>), sel_registerName(<span class="hljs-string">"new"</span>)));</span><br><span class="line">        ((<span class="hljs-keyword">void</span> (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSObject *(*)(id, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="hljs-string">"NSObject"</span>), sel_registerName(<span class="hljs-string">"new"</span>)));</span><br><span class="line">        ((<span class="hljs-keyword">void</span> (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSObject *(*)(id, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="hljs-string">"NSObject"</span>), sel_registerName(<span class="hljs-string">"new"</span>)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意被赋值NSMutableArray对象并被截获的自动变量array。我们可以发现，它是block结构体中的成员变量：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span></span><br><span class="line">    <span class="hljs-comment">//注意这里</span></span><br><span class="line">  id __strong <span class="hljs-built_in">array</span>;</span><br><span class="line">    </span><br><span class="line">  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, id _array, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) : <span class="hljs-built_in">array</span>(_array) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在Objective-C中，C语言结构体不能含有附有_<em>strong修饰符的变量（换句话说：对象型变量不能作为C语言结构体的成员）。因为编译器不知道何时进行C语言结构体的初始化和废弃操作，不能很好地管理内存。但是Objective-C运行时库能够准确把握block从栈复制到堆以及堆上的block被废弃的时机，因此block结构体中即使含有对象型变量，也可以恰当地进行初始化和废弃。为此需要使用\</em>_main_block_desc_0结构体中增加的成员变量copy和dispose（这两个变量都是函数指针，指向函数），以及作为指针赋值给该成员变量的__main_block_copy_0函数和__main_block_dispose_0函数：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((<span class="hljs-keyword">void</span>*)&amp;dst-&gt;<span class="hljs-built_in">array</span>, (<span class="hljs-keyword">void</span>*)src-&gt;<span class="hljs-built_in">array</span>, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src)&#123;</span><br><span class="line">    _Block_object_dispose((<span class="hljs-keyword">void</span>*)src-&gt;<span class="hljs-built_in">array</span>, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察转换后的代码，上面两个函数包括使用指针全部都没有被调用。那么这些函数是从哪儿调用呢？</p><table><thead><tr><th>函数</th><th>调用时机</th></tr></thead><tbody><tr><td>copy函数</td><td>栈上的block复制到堆时</td></tr><tr><td>dispose函数</td><td>堆上的block被废弃时</td></tr></tbody></table><p>那么什么时候栈上的block会复制到堆呢？</p><ul><li>调用block的copy/strong实例方法</li><li>block作为函数返回值返回时</li><li>将block赋值给附有__storng修饰符id类型的类或block类型成员变量时</li><li>在方法中含有usingBlock的Cocoa框架方法或GCD的api中传递block时</li></ul><p>也就是说虽然从源代码来看，在上面这些情况下栈上的block被赋值到堆上，但其实可归结为_Block<em>copy函数被调用时block从栈复制到堆。相对的，在释放复制到堆上的block后，谁都不持有block而使其被废弃时调用disopose函数。这相当于对象的dealloc方法。有了这种构造，通过使用附有__strong修饰符的自动变量，block中截获的对象就能够超出其变量作用域而存在。虽然这种使用copy函数，dispose函数的方法在之前没有讲解，但实际上在\</em>_block变量中已经用到了。</p><h4 id="block修饰变量和对象"><a href="#block修饰变量和对象" class="headerlink" title="__block修饰变量和对象"></a>__block修饰变量和对象</h4><p><code>__block</code>说明符可指定任何类型的自动变量。下面指定用于赋值Objective-C对象的id类型自动变量。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="hljs-keyword">id</span> obj = [<span class="hljs-built_in">NSObject</span> new];</span><br></pre></td></tr></table></figure><p>其代码等同于：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="hljs-keyword">id</span> __<span class="hljs-keyword">strong</span> obj = [<span class="hljs-built_in">NSObject</span> new];</span><br></pre></td></tr></table></figure><p>改代码可通过clang转换如下：</p><p>在_<em>block变量为附有\</em>_strong修饰符的id类型或对象类型自动变量的情况下会发生同样的过程。当__block变量从栈复制到堆上时，使用_Block_object_assign函数，持有赋值给__block变量的对象。当堆上的__block变量被废弃时，则使用_Block_object_dispose函数释放赋值给__block变量的对象。</p><p>如果__block和__weak一起使用，则block不会被持有，所以不起作用。__block不能和__autoreleasing一起使用，会编译错误。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>block截获自动变量时不管截获的自动变量是对象类型还是基本类型，都会在block结构体内部建立一个成员变量进行存储，数据类型与与截获的自动变量数据类型相同。</li></ol><p>为什么不能修改截获的自动变量？</p><ul><li>对于值类型，是简单的值传递。（为什么不直接传递指针呢？因为值类型保存在栈上，就算传递了指针，值类型在函数结束后就销毁了。所以传递指针也没有意义。）</li><li>对于对象类型是指针浅复制（浅拷贝就是拷贝指向原来对象的指针，使原对象的引用计数+1，可以理解为创建了一个指向原对象的新指针而已，并没有创建一个全新的对象。所以我们可以通过复制后的变量修改这份内存，但是不能修改外部自动变量使其指向另一块内存区域）。</li></ul><ol><li><p>为什么使用__block后就可以修改截获的自动变量？</p><p>被修饰了_<em>block的自动变量不管是基本类型还是对象类型都会被封装到一个结构体类型变量中，表面上看到的是block截获的是自动变量，其实是这个结构体类型变量的指针，因此可以修改自动变量。并且当block从栈上复制到堆上时，栈上的\</em>_block修饰的自动变量的结构体类型变量的forwarding指针会指向堆上的__block修饰的自动变量的结构体类型变量。所以不管是在栈上还是堆上，在block内还是在block外修改使用__block修饰的自动变量，修改的都是同一块内存区域。</p></li></ol><blockquote><p>参考：</p><p><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00DE60G3S" target="_blank" rel="noopener">《Objective-C高级编程:iOS与OS X多线程和内存管理》</a></p><p><a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="noopener">《谈Objective-C block的实现-唐巧》</a></p><p><a href="http://www.desgard.com/iOS-Source-Probe/Objective-C/Runtime/%E6%B5%85%E8%B0%88%20block%EF%BC%882%EF%BC%89%20-%20%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F%E6%96%B9%E5%BC%8F.html" target="_blank" rel="noopener">《浅谈 block - 截获变量方式》</a></p><p><a href="https://www.cnblogs.com/acBool/p/5146639.html" target="_blank" rel="noopener">《iOS中的深复制与浅复制》</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1fp58b4pem0j308c04owem.jpg&quot; alt=&quot;961b7caed0225e03fea7cb75de43b540&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/categories/Objective-C/"/>
    
    
      <category term="Block" scheme="http://www.wuqihan.cn/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>如何继承类簇（例如NSString）</title>
    <link href="http://www.wuqihan.cn/2017/05/15/%E5%A6%82%E4%BD%95%E7%BB%A7%E6%89%BF%E7%B1%BB%E7%B0%87/"/>
    <id>http://www.wuqihan.cn/2017/05/15/如何继承类簇/</id>
    <published>2017-05-15T08:51:53.000Z</published>
    <updated>2018-08-18T03:09:24.799Z</updated>
    
    <content type="html"><![CDATA[<p>在今天之前 如果有人问我 如果给NSString添加一个方法 ，我最先想到的方法肯定就是使用Category。一直觉得NSString是不能被继承的，因为它是类簇，其实如果真的想继承，也是有办法的。<br>        在Cocoa框架里有许多类簇，比如NSArray，NSString，NSNumber（具体什么是类簇就不解释了。网上关于类簇的介绍很多）。</p><p>具体关于如何为类簇添加子类，需要遵守几条规则：</p><blockquote><ol><li>子类应该继承自类簇中的抽象基类。</li><li>子类应该自定义自己的数据存储方式。（开发者编写NSArray子类时，必须用一个实例变量来存放数组中的对象。这似乎与大家预想的不同，我们以为NSArray自己肯定会保存那些对象，所以在子类中就无须再保存一份了。但是大家要记住，NSArray本身只不过是包在其他隐藏对象外面的壳，它仅仅定义了所有数组都需具备的一些接口。对于这个自定义的数组类来说，可以用NSArray来保存其实例）。</li><li>子类应当覆写超类文档中指明需要覆写的方法。</li></ol></blockquote><a id="more"></a><p>接下来就动手实现如何继承NSArray 和 NSString。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">"WUArray.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">WUArray</span>()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">NSArray</span> *_storeArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">WUArray</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">instancetype</span>)initWithArray:(<span class="hljs-built_in">NSArray</span> *)array &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) &#123;</span><br><span class="line">        _storeArray = [<span class="hljs-built_in">NSArray</span> arrayWithArray:array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#pragma mark - override</span></span><br><span class="line">- (<span class="hljs-built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> _storeArray.count;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="hljs-keyword">id</span>)objectAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> [_storeArray objectAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><p>######以上为WUArray.m文件</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">"WUString.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">WUString</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">NSString</span> *_storeString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">WUString</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">instancetype</span>)initWithString:(<span class="hljs-built_in">NSString</span> *)aString &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">self</span> init]) &#123;</span><br><span class="line">        _storeString = [[<span class="hljs-built_in">NSString</span> stringWithString:aString] <span class="hljs-keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-built_in">NSUInteger</span>)length &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> [_storeString length];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">unichar</span>)characterAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> [_storeString characterAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><p>######以上为WUString.m 文件</p><p>实现完之后 来验证一下：<br><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WUString *str = [[WUString alloc] initWithString:<span class="hljs-string">@"123456789"</span>];</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,[str substringFromIndex:<span class="hljs-number">5</span>]); <span class="hljs-comment">//控制台打印输出为 6789</span></span><br><span class="line">    </span><br><span class="line">    WUArray *array = [[WUArray alloc] initWithArray:@[<span class="hljs-string">@"h"</span>,<span class="hljs-string">@"e"</span>,<span class="hljs-string">@"l"</span>,<span class="hljs-string">@"l"</span>,<span class="hljs-string">@"0"</span>]];</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,[array componentsJoinedByString:<span class="hljs-string">@"."</span>]); <span class="hljs-comment">//控制台打印输出为 h.e.l.l.o</span></span><br></pre></td></tr></table></figure></p><p>在继承的时候 关于要具体覆写超类的哪几个方法，NSString的头文件里面写的有：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* NSString primitives. A minimal subclass of NSString just needs to implement these two, along with an init method appropriate for that subclass. We also recommend overriding getCharacters:range: for performance.</span><br><span class="line"> */</span><br><span class="line">@property (readonly) NSUInteger length;</span><br><span class="line">- (unichar)characterAtIndex:(NSUInteger)index;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在今天之前 如果有人问我 如果给NSString添加一个方法 ，我最先想到的方法肯定就是使用Category。一直觉得NSString是不能被继承的，因为它是类簇，其实如果真的想继承，也是有办法的。&lt;br&gt;        在Cocoa框架里有许多类簇，比如NSArray，NSString，NSNumber（具体什么是类簇就不解释了。网上关于类簇的介绍很多）。&lt;/p&gt;
&lt;p&gt;具体关于如何为类簇添加子类，需要遵守几条规则：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;子类应该继承自类簇中的抽象基类。&lt;/li&gt;
&lt;li&gt;子类应该自定义自己的数据存储方式。（开发者编写NSArray子类时，必须用一个实例变量来存放数组中的对象。这似乎与大家预想的不同，我们以为NSArray自己肯定会保存那些对象，所以在子类中就无须再保存一份了。但是大家要记住，NSArray本身只不过是包在其他隐藏对象外面的壳，它仅仅定义了所有数组都需具备的一些接口。对于这个自定义的数组类来说，可以用NSArray来保存其实例）。&lt;/li&gt;
&lt;li&gt;子类应当覆写超类文档中指明需要覆写的方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RAC(四)信号高阶操作</title>
    <link href="http://www.wuqihan.cn/2017/03/10/RAC-%E5%9B%9B-%E4%BF%A1%E5%8F%B7%E9%AB%98%E9%98%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.wuqihan.cn/2017/03/10/RAC-四-信号高阶操作/</id>
    <published>2017-03-10T06:42:50.000Z</published>
    <updated>2018-08-18T03:09:24.797Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqc24yeimhj31d404k75z.jpg" alt="image-20180414120959021"></p><h3 id="高阶信号"><a href="#高阶信号" class="headerlink" title="高阶信号"></a>高阶信号</h3><p>对数组的操作可以有二维数组，多维数组。同样，信号也是可以嵌套的，经常会遇到二维信号，也就是信号中发送的值也为信号。</p><a id="more"></a><h4 id="升阶和降阶"><a href="#升阶和降阶" class="headerlink" title="升阶和降阶"></a>升阶和降阶</h4><p><strong>(下图菱形图例代表信号，圆圈代表值)</strong></p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqgsukkquuj30kz06lmxt.jpg" alt="image-20180418143626144"></p><h4 id="创建高阶信号"><a href="#创建高阶信号" class="headerlink" title="创建高阶信号"></a>创建高阶信号</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSiganl *siganl = [RACSignal <span class="hljs-keyword">return</span>:@<span class="hljs-number">1</span>];</span><br><span class="line"></span><br><span class="line">RACSiganl *signalHighOrder = [RACSiganl <span class="hljs-keyword">return</span>:signal];</span><br><span class="line">RACSiganl *anotherSignal = [signal map:^<span class="hljs-keyword">id</span>(<span class="hljs-keyword">id</span> value) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> [RACSignal <span class="hljs-keyword">return</span>:value];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="订阅高级信号"><a href="#订阅高级信号" class="headerlink" title="订阅高级信号"></a>订阅高级信号</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSiganl *siganl = @[@<span class="hljs-number">1</span>,@<span class="hljs-number">2</span>,@<span class="hljs-number">3</span>].rac_sequence.signal;</span><br><span class="line">RACSignal *highOrderSignal = [signal map:^<span class="hljs-keyword">id</span>(RACSiganl *aSiganl) &#123;</span><br><span class="line">    [aSignal subscribeNext:^(<span class="hljs-keyword">id</span> x) &#123;</span><br><span class="line">        <span class="hljs-comment">//...</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="降阶操作"><a href="#降阶操作" class="headerlink" title="降阶操作"></a>降阶操作</h3><h4 id="SwitchToLatests"><a href="#SwitchToLatests" class="headerlink" title="SwitchToLatests"></a>SwitchToLatests</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqgt45kmhqj30k009dmyo.jpg" alt="image-20180418144538812"></p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqgt3zw110j30jh090gmt.jpg" alt="image-20180418144441907"></p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqgt4a6g9cj30ji08zt9q.jpg" alt="image-20180418144546449"></p><p>使用switchToLatests方法降阶时，需要注意的是<strong>新的信号会把旧的信号截断</strong></p><h4 id="if-then-else"><a href="#if-then-else" class="headerlink" title="if/then/else"></a>if/then/else</h4><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqgt60x0arj30mh0a5q4t.jpg" alt="image-20180418144726566"></p><p>看一下ifThenElse方法的实现代码，可以很容易理解。它的本质还是使用了SwitchToLatests。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)if:(RACSignal *)boolSignal then:(RACSignal *)trueSignal else:(RACSignal *)falseSignal &#123;</span><br><span class="line">NSCParameterAssert(boolSignal != nil);</span><br><span class="line">NSCParameterAssert(trueSignal != nil);</span><br><span class="line">NSCParameterAssert(falseSignal != nil);</span><br><span class="line"></span><br><span class="line">return [[[boolSignal</span><br><span class="line">map:^(NSNumber *value) &#123;</span><br><span class="line">NSCAssert([value isKindOfClass:NSNumber.class], @&quot;Expected %@ to send BOOLs, not %@&quot;, boolSignal, value);</span><br><span class="line"></span><br><span class="line">return (value.boolValue ? trueSignal : falseSignal);</span><br><span class="line">&#125;]</span><br><span class="line">switchToLatest]</span><br><span class="line">setNameWithFormat:@&quot;+if: %@ then: %@ else: %@&quot;, boolSignal, trueSignal, falseSignal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的方法还有SwitchCasesDefaultSignal:</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)<span class="hljs-keyword">switch</span>:(RACSignal *)signal cases:(<span class="hljs-built_in">NSDictionary</span> *)cases <span class="hljs-keyword">default</span>:(RACSignal *)defaultSignal &#123;</span><br><span class="line"><span class="hljs-built_in">NSCParameterAssert</span>(signal != <span class="hljs-literal">nil</span>);</span><br><span class="line"><span class="hljs-built_in">NSCParameterAssert</span>(cases != <span class="hljs-literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">id</span> key <span class="hljs-keyword">in</span> cases) &#123;</span><br><span class="line"><span class="hljs-keyword">id</span> value __attribute__((unused)) = cases[key];</span><br><span class="line"><span class="hljs-built_in">NSCAssert</span>([value isKindOfClass:RACSignal.class], <span class="hljs-string">@"Expected all cases to be RACSignals, %@ isn't"</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">NSDictionary</span> *<span class="hljs-keyword">copy</span> = [cases <span class="hljs-keyword">copy</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> [[[signal</span><br><span class="line">map:^(<span class="hljs-keyword">id</span> key) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (key == <span class="hljs-literal">nil</span>) key = RACTupleNil.tupleNil;</span><br><span class="line"></span><br><span class="line">RACSignal *signal = <span class="hljs-keyword">copy</span>[key] ?: defaultSignal;</span><br><span class="line"><span class="hljs-keyword">if</span> (signal == <span class="hljs-literal">nil</span>) &#123;</span><br><span class="line"><span class="hljs-built_in">NSString</span> *description = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-built_in">NSLocalizedString</span>(<span class="hljs-string">@"No matching signal found for value %@"</span>, <span class="hljs-string">@""</span>), key];</span><br><span class="line"><span class="hljs-keyword">return</span> [RACSignal error:[<span class="hljs-built_in">NSError</span> errorWithDomain:RACSignalErrorDomain code:RACSignalErrorNoMatchingCase userInfo:@&#123; <span class="hljs-built_in">NSLocalizedDescriptionKey</span>: description &#125;]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> signal;</span><br><span class="line">&#125;]</span><br><span class="line">switchToLatest]</span><br><span class="line">setNameWithFormat:<span class="hljs-string">@"+switch: %@ cases: %@ default: %@"</span>, signal, cases, defaultSignal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Flatten"><a href="#Flatten" class="headerlink" title="Flatten"></a>Flatten</h4><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqgt6aqxf6j30jr08ygmo.jpg" alt="image-20180418144742256"></p><p>flatten与SwitchToLatests不同的是，新的信号不会截断旧的信号。它相当于是使用<strong>**merge:</strong>方法把信号中的所有信号都合并在了一起。</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqgt6jnkalj30jd08vq3y.jpg" alt="image-20180418144755171"></p><p>flatten：这个带参数的方法 的参数类型是NSUInteger。拿上图举例子就是说，当前这个参数为2，那这个值就代表的是当前最多展开的信号，signalA中有4个信号，最多同时展开两个信号。也就是说，首先能够一次订阅前两个信号，如果这里两个信号都没执行完， 就不能订阅第三个，当 前两个信号其中有一个信号结束之后，才会去订阅第三个信号，这样依次类推。 </p><h4 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h4><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqgt6mylwlj30is08zt9k.jpg" alt="image-20180418144801999"></p><p>对于一个返回a信号、b信号的高阶信号调用flatten:1，等价于[a信号 concat:b信号]。</p><p>对于高级信号，也有一个- (RACSIgnal *)concat;方法，就是相当于调用flatten:1</p><h4 id="FlattenMap"><a href="#FlattenMap" class="headerlink" title="FlattenMap"></a>FlattenMap</h4><p>flattenMap就是 先map为高阶信号在调用flatten降阶</p><p>看一下 RACStream.m文件中 flattenMap: 、flatten、map：的实现</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(<span class="hljs-keyword">id</span> value))block &#123;</span><br><span class="line">Class <span class="hljs-keyword">class</span> = <span class="hljs-keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> bind:^&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ^(<span class="hljs-keyword">id</span> value, <span class="hljs-built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="hljs-keyword">id</span> stream = block(value) ?: [<span class="hljs-keyword">class</span> empty];</span><br><span class="line"><span class="hljs-built_in">NSCAssert</span>([stream isKindOfClass:RACStream.class], <span class="hljs-string">@"Value returned from -flattenMap: is not a stream: %@"</span>, stream);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> stream;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="hljs-string">@"[%@] -flattenMap:"</span>, <span class="hljs-keyword">self</span>.name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (__kindof RACStream *)flatten &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> flattenMap:^(<span class="hljs-keyword">id</span> value) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> value;</span><br><span class="line">&#125;] setNameWithFormat:<span class="hljs-string">@"[%@] -flatten"</span>, <span class="hljs-keyword">self</span>.name];</span><br><span class="line">&#125;</span><br><span class="line">- (__kindof RACStream *)map:(<span class="hljs-keyword">id</span> (^)(<span class="hljs-keyword">id</span> value))block &#123;</span><br><span class="line"><span class="hljs-built_in">NSCParameterAssert</span>(block != <span class="hljs-literal">nil</span>);</span><br><span class="line"></span><br><span class="line">Class <span class="hljs-keyword">class</span> = <span class="hljs-keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> flattenMap:^(<span class="hljs-keyword">id</span> value) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> [<span class="hljs-keyword">class</span> <span class="hljs-keyword">return</span>:block(value)];</span><br><span class="line">&#125;] setNameWithFormat:<span class="hljs-string">@"[%@] -map:"</span>, <span class="hljs-keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过看方法的实现，可以看出，flatten和map方法都是基于flattenMap:的，还有filter：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)filter:(<span class="hljs-built_in">BOOL</span> (^)(<span class="hljs-keyword">id</span> value))block &#123;</span><br><span class="line"><span class="hljs-built_in">NSCParameterAssert</span>(block != <span class="hljs-literal">nil</span>);</span><br><span class="line"></span><br><span class="line">Class <span class="hljs-keyword">class</span> = <span class="hljs-keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> flattenMap:^ <span class="hljs-keyword">id</span> (<span class="hljs-keyword">id</span> value) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (block(value)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> [<span class="hljs-keyword">class</span> <span class="hljs-keyword">return</span>:value];</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span>.empty;</span><br><span class="line">&#125;</span><br><span class="line">&#125;] setNameWithFormat:<span class="hljs-string">@"[%@] -filter:"</span>, <span class="hljs-keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看flattenMap方法实现。发现它是基于bind:方法的。RAC中的方法几乎所有都是基于bind方法实现的，它是RAC的核心方法。<strong>这个bind方法感觉比较复杂，我暂时也不太理解，以后再研究</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fqc24yeimhj31d404k75z.jpg&quot; alt=&quot;image-20180414120959021&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;高阶信号&quot;&gt;&lt;a href=&quot;#高阶信号&quot; class=&quot;headerlink&quot; title=&quot;高阶信号&quot;&gt;&lt;/a&gt;高阶信号&lt;/h3&gt;&lt;p&gt;对数组的操作可以有二维数组，多维数组。同样，信号也是可以嵌套的，经常会遇到二维信号，也就是信号中发送的值也为信号。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/categories/Objective-C/"/>
    
    
      <category term="ReactiveCocoa" scheme="http://www.wuqihan.cn/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>RAC(三)RACSignal各类操作</title>
    <link href="http://www.wuqihan.cn/2017/01/08/RAC-%E4%B8%89-RACSignal%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.wuqihan.cn/2017/01/08/RAC-三-RACSignal基本使用/</id>
    <published>2017-01-08T05:20:24.000Z</published>
    <updated>2018-08-18T03:09:24.797Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqc24yeimhj31d404k75z.jpg" alt="image-20180414120959021"></p><h3 id="获得一个信号的方式"><a href="#获得一个信号的方式" class="headerlink" title="获得一个信号的方式"></a>获得一个信号的方式</h3><h4 id="单元信号"><a href="#单元信号" class="headerlink" title="单元信号"></a>单元信号</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal <span class="hljs-keyword">return</span>:<span class="hljs-string">@"Some value"</span>];</span><br><span class="line">RACSignal *signal2 = [RACSignal error:errorObject];</span><br><span class="line">RACSignal *signal3 = [RACSignal empty];</span><br><span class="line">RACSignal *signal4 = [RACSignal never];</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="动态信号"><a href="#动态信号" class="headerlink" title="动态信号"></a>动态信号</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal5 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="hljs-keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@<span class="hljs-number">1</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="hljs-number">2</span>];</span><br><span class="line">    [subscriber sendError:errorObject];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="hljs-keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="Cocoa桥接"><a href="#Cocoa桥接" class="headerlink" title="Cocoa桥接"></a>Cocoa桥接</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal6 = [button rac_signalForSelector:<span class="hljs-keyword">@selector</span>(setFrame:)];</span><br><span class="line">RACSignal *signal7 = [button rac_signalForControlEvents:<span class="hljs-built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">RACSignal *signal8 = [button rac_willDeallocSignal];</span><br><span class="line">RACSignal *signal9 = RACObserve(button, backgroundColor);</span><br></pre></td></tr></table></figure><h4 id="信号变换"><a href="#信号变换" class="headerlink" title="信号变换"></a>信号变换</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal10 = [signal1 map:^<span class="hljs-keyword">id</span> _Nullable(<span class="hljs-built_in">NSString</span>*  _Nullable value) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> [value substringFromIndex:<span class="hljs-number">1</span>];</span><br><span class="line">    &#125;]</span><br></pre></td></tr></table></figure><h4 id="序列转换"><a href="#序列转换" class="headerlink" title="序列转换"></a>序列转换</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal11 = [RACSequence <span class="hljs-keyword">return</span>:@<span class="hljs-number">1</span>].signal;</span><br></pre></td></tr></table></figure><h3 id="订阅一个信号的方式"><a href="#订阅一个信号的方式" class="headerlink" title="订阅一个信号的方式"></a>订阅一个信号的方式</h3><p><strong>注意Signal是push-driven(推驱动)</strong></p><h4 id="基本订阅方法-subscribe"><a href="#基本订阅方法-subscribe" class="headerlink" title="基本订阅方法 subscribe"></a>基本订阅方法 subscribe</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[signal1 subscribeNext:^(<span class="hljs-keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,x);</span><br><span class="line">&#125; error:^(<span class="hljs-built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,error);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"complete"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(view,backgroundColor) = signal10;</span><br></pre></td></tr></table></figure><h4 id="Cocoa桥接-1"><a href="#Cocoa桥接-1" class="headerlink" title="Cocoa桥接"></a>Cocoa桥接</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[view rac_liftSelector:<span class="hljs-keyword">@selector</span>(convertPoint:toView:) withSignals:signal1,signal2, <span class="hljs-literal">nil</span>];</span><br><span class="line">[view rac_liftSelector:<span class="hljs-keyword">@selector</span>(convertPoint:toView:) withSignalsFromArray:@[signal1,signal2]];</span><br><span class="line">[view rac_liftSelector:<span class="hljs-keyword">@selector</span>(convertPoint:toView:) withSignalOfArguments:signal5];</span><br></pre></td></tr></table></figure><h3 id="分析订阅过程"><a href="#分析订阅过程" class="headerlink" title="分析订阅过程"></a>分析订阅过程</h3><p>RACSignal的常见用法：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="hljs-comment">// part 1:[RACSignal createSignal]来获得signal</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="hljs-keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// part 3: 进入didSubscribe，通过[subscriber sendNext:]来执行next block</span></span><br><span class="line">        [subscriber sendNext:@<span class="hljs-number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="hljs-number">2</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<span class="hljs-comment">//这里忽略RACDisposable，暂时不讲</span></span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line"><span class="hljs-comment">// part 2 : [signal subscribeNext:]来获得subscriber，然后进行subscription，error和complete不讨论与next一样。（RACSignal里面保存的事件分为3中。一种是值value，一种是error，一种是complete。）</span></span><br><span class="line">    [signal subscribeNext:^(<span class="hljs-keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="hljs-comment">//...</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RACSignal的Subscription过程概括起来可以分为三个步骤：</p><h4 id="步骤一：-RACSignal-createSignal-来获得signal"><a href="#步骤一：-RACSignal-createSignal-来获得signal" class="headerlink" title="步骤一：[RACSignal createSignal]来获得signal"></a>步骤一：[RACSignal createSignal]来获得signal</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//RACSignal.m中：</span></span><br><span class="line">+ ( RACSignal *)createSignal:( RACDisposable * (^)( <span class="hljs-keyword">id</span> &lt; RACSubscriber &gt; subscriber))didSubscribe &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> [ RACDynamicSignal   createSignal :didSubscribe];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//RACDynamicSignal.m中</span></span><br><span class="line">+ ( RACSignal *)createSignal:( RACDisposable * (^)( <span class="hljs-keyword">id</span> &lt; RACSubscriber &gt; subscriber))didSubscribe &#123;</span><br><span class="line">  RACDynamicSignal *signal = [[ <span class="hljs-keyword">self</span>   alloc ] init ];</span><br><span class="line"> signal-&gt; _didSubscribe = [didSubscribe <span class="hljs-keyword">copy</span> ];</span><br><span class="line">  <span class="hljs-keyword">return</span> [signal setNameWithFormat : <span class="hljs-string">@"+createSignal:"</span> ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[RACSignal createSignal]会调用子类RACDynamicSignal的createSignal来返回一个signal，并在signal中保存后面的 didSubscribe这个block</p><h4 id="步骤二：-signal-subscribeNext-来获得subscriber，然后进行subscription"><a href="#步骤二：-signal-subscribeNext-来获得subscriber，然后进行subscription" class="headerlink" title="步骤二：[signal subscribeNext:]来获得subscriber，然后进行subscription"></a>步骤二：[signal subscribeNext:]来获得subscriber，然后进行subscription</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//RACSignal.m中：</span></span><br><span class="line">- ( RACDisposable *)subscribeNext:( <span class="hljs-keyword">void</span> (^)( <span class="hljs-keyword">id</span> x))nextBlock &#123;</span><br><span class="line">  RACSubscriber *o = [ RACSubscriber   subscriberWithNext :nextBlock error : <span class="hljs-literal">NULL</span>   completed : <span class="hljs-literal">NULL</span> ];</span><br><span class="line">  <span class="hljs-keyword">return</span> [ <span class="hljs-keyword">self</span>  subscribe :o];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//RACSubscriber.m中：</span></span><br><span class="line">+ ( <span class="hljs-keyword">instancetype</span> )subscriberWithNext:( <span class="hljs-keyword">void</span> (^)( <span class="hljs-keyword">id</span> x))next error:( <span class="hljs-keyword">void</span> (^)( <span class="hljs-built_in">NSError</span> *error))error completed:( <span class="hljs-keyword">void</span> (^)( <span class="hljs-keyword">void</span> ))completed &#123;</span><br><span class="line">  RACSubscriber *subscriber = [[ <span class="hljs-keyword">self</span>   alloc ] init ];</span><br><span class="line"> subscriber-&gt; _next = [next <span class="hljs-keyword">copy</span> ];</span><br><span class="line"> subscriber-&gt; _error = [error <span class="hljs-keyword">copy</span> ];</span><br><span class="line"> subscriber-&gt; _completed = [completed <span class="hljs-keyword">copy</span> ];</span><br><span class="line">  <span class="hljs-keyword">return</span> subscriber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//RACDynamicSignal.m中：</span></span><br><span class="line">- (RACDisposable *)subscribe:(<span class="hljs-keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">    RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">    subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class="hljs-keyword">self</span> disposable:disposable];</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.didSubscribe != <span class="hljs-literal">NULL</span>) &#123;</span><br><span class="line">        RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">            RACDisposable *innerDisposable = <span class="hljs-keyword">self</span>.didSubscribe(subscriber);</span><br><span class="line">            [disposable addDisposable:innerDisposable];</span><br><span class="line">        &#125;];</span><br><span class="line">        [disposable addDisposable:schedulingDisposable];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>[signal subscribeNext]先会获得一个subscriber，这个subscriber中保存了nextBlock、errorBlock、completedBlock</li><li>由于这个signal其实是RACDynamicSignal类型的，这个[self subscribe]方法会调用步骤一中保存的didSubscribe，参数就是1中的subscriber</li></ol><h4 id="步骤三：进入didSubscribe，通过-subscriber-sendNext-来执行next-block"><a href="#步骤三：进入didSubscribe，通过-subscriber-sendNext-来执行next-block" class="headerlink" title="步骤三：进入didSubscribe，通过[subscriber sendNext:]来执行next block"></a>步骤三：进入didSubscribe，通过[subscriber sendNext:]来执行next block</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//RACSubscriber.m中：</span></span><br><span class="line">- (<span class="hljs-keyword">void</span>)sendNext:(<span class="hljs-keyword">id</span>)value &#123;</span><br><span class="line">    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">void</span> (^nextBlock)(<span class="hljs-keyword">id</span>) = [<span class="hljs-keyword">self</span>.next <span class="hljs-keyword">copy</span>];</span><br><span class="line">        <span class="hljs-keyword">if</span> (nextBlock == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">return</span>;</span><br><span class="line">        nextBlock(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="signal的subscription过程回顾"><a href="#signal的subscription过程回顾" class="headerlink" title="signal的subscription过程回顾"></a>signal的subscription过程回顾</h4><p>从上面的三个步骤，我们看出：</p><ul><li>先通过createSignal和subscribeNext这两个调用，声明了流中value到来时的处理方式</li><li>didSubscribe block块中异步处理完毕之后，subscriber进行sendNext，自动处理</li></ul><h3 id="RACTuple"><a href="#RACTuple" class="headerlink" title="RACTuple"></a>RACTuple</h3><p>RAC定义的一种数据类型。类似Swift中的tuple。这里不多介绍。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RACTuple *tuple = RACTuplePack(@<span class="hljs-number">1</span>,<span class="hljs-string">@"haha"</span>);</span><br><span class="line"><span class="hljs-keyword">id</span> first = tuple.first;</span><br><span class="line"><span class="hljs-keyword">id</span> last = tuple.last;</span><br><span class="line"><span class="hljs-keyword">id</span> idnex1 = tuple[<span class="hljs-number">1</span>];</span><br><span class="line">RACTupleUnpack(<span class="hljs-built_in">NSNumber</span> *num,<span class="hljs-built_in">NSString</span> *str) = tuple;</span><br></pre></td></tr></table></figure><h3 id="RACSignal各类操作"><a href="#RACSignal各类操作" class="headerlink" title="RACSignal各类操作"></a>RACSignal各类操作</h3><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqgsdbj5vej30q00bfjsr.jpg" alt="image-20180418141948795"></p><h4 id="对值操作"><a href="#对值操作" class="headerlink" title="对值操作"></a>对值操作</h4><h5 id="map-mapReplace"><a href="#map-mapReplace" class="headerlink" title="map/mapReplace"></a>map/mapReplace</h5><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqgsefandlj30oj07wwfq.jpg" alt="image-20180418142054959"></p><h5 id="reduceEach"><a href="#reduceEach" class="headerlink" title="reduceEach"></a>reduceEach</h5><p>只能用在tuple上。tuple个数少了会挂，多了只去和参数相同的个数。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqgsesw2fij30pi08mq46.jpg" alt="image-20180418142116897"></p><h5 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h5><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqgsn3atzgj30ms075t9v.jpg" alt="image-20180418142914659"></p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>not/and/or/reduceApply/materialize/dematerialize;</p><h4 id="对数量操作"><a href="#对数量操作" class="headerlink" title="对数量操作"></a>对数量操作</h4><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqgsg7fvrij30nh07hab4.jpg" alt="image-20180418142238131"></p><h5 id="ignore-ignoreValues-distinctUntilChanged"><a href="#ignore-ignoreValues-distinctUntilChanged" class="headerlink" title="ignore/ignoreValues/distinctUntilChanged"></a>ignore/ignoreValues/distinctUntilChanged</h5><p>这几个根据英文很容易理解</p><h5 id="take"><a href="#take" class="headerlink" title="take"></a>take</h5><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqgshjenxxj30lo080gmj.jpg" alt="image-20180418142354763"></p><h5 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h5><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqgshpdhdsj30ll07ywfe.jpg" alt="image-20180418142404053"></p><h5 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h5><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqgsiid4djj30k803xjst.jpg" alt="image-20180418142450462"></p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqgsiqtsioj30j603dgm7.jpg" alt="image-20180418142504248"></p><h5 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a>startWith</h5><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqgsje8jtvj30lo07fab0.jpg" alt="image-20180418142541910"></p><h5 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h5><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqgsjpyiysj30ml08t0tu.jpg" alt="image-20180418142600575"></p><h5 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h5><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqgsk15k0qj30m307kdgl.jpg" alt="image-20180418142618562"></p><h5 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h5><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqgsm7tmmkj30lv07e750.jpg" alt="image-20180418142824458"></p><h5 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h5><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqgsmkwne6j30mx07oab4.jpg" alt="image-20180418142845070"></p><h4 id="副作用操作"><a href="#副作用操作" class="headerlink" title="副作用操作"></a>副作用操作</h4><p>doNext</p><h4 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h4><h5 id="Delay"><a href="#Delay" class="headerlink" title="Delay"></a>Delay</h5><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqgsns20wcj30m009pmyg.jpg" alt="image-20180418142954495"></p><h5 id="Throttle"><a href="#Throttle" class="headerlink" title="Throttle"></a>Throttle</h5><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqgso26y53j30m407vaat.jpg" alt="image-20180418143010615"></p><h4 id="组合操作"><a href="#组合操作" class="headerlink" title="组合操作"></a>组合操作</h4><h5 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h5><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqgsomdr49j30kn088t9t.jpg" alt="image-20180418143043116"></p><h5 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h5><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqgsp90zc4j30mt08sdhe.jpg" alt="image-20180418143118995"></p><p>merge用处很多，如下：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *appearSignal = [[<span class="hljs-keyword">self</span> rac_signalForSelector:<span class="hljs-keyword">@selector</span>(viewDidAppear:)]] mapReplace:@YES];</span><br><span class="line">RACSignal *disappearSignal = [[<span class="hljs-keyword">self</span> rac_signalForSelector:<span class="hljs-keyword">@selector</span>(viewWillDisAppear:)]] mapReplace:@NO];</span><br><span class="line">RACSignal *activeSignal = [RACSignal merge:@[appearSignal,disappearSignal]];</span><br></pre></td></tr></table></figure><h5 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h5><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqgsrhyhl2j30mq08rta3.jpg" alt="image-20180418143328779"></p><h5 id="CombineLatest"><a href="#CombineLatest" class="headerlink" title="CombineLatest"></a>CombineLatest</h5><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqgsrsnndcj30nf08mjsm.jpg" alt="image-20180418143345994"></p><h5 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h5><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqgss75tvfj30l808cjsa.jpg" alt="image-20180418143409171"></p><h5 id="TakeUntil"><a href="#TakeUntil" class="headerlink" title="TakeUntil"></a>TakeUntil</h5><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqgssyvjr7j30ml07pt9p.jpg" alt="image-20180418143453317"></p><h5 id="TakeUntilReplacement"><a href="#TakeUntilReplacement" class="headerlink" title="TakeUntilReplacement"></a>TakeUntilReplacement</h5><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqgst9nswuj30oi08bq45.jpg" alt="image-20180418143511093"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fqc24yeimhj31d404k75z.jpg&quot; alt=&quot;image-20180414120959021&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;获得一个信号的方式&quot;&gt;&lt;a href=&quot;#获得一个信号的方式&quot; class=&quot;headerlink&quot; title=&quot;获得一个信号的方式&quot;&gt;&lt;/a&gt;获得一个信号的方式&lt;/h3&gt;&lt;h4 id=&quot;单元信号&quot;&gt;&lt;a href=&quot;#单元信号&quot; class=&quot;headerlink&quot; title=&quot;单元信号&quot;&gt;&lt;/a&gt;单元信号&lt;/h4&gt;&lt;figure class=&quot;highlight objc hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;RACSignal *signal1 = [RACSignal &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;@&quot;Some value&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RACSignal *signal2 = [RACSignal error:errorObject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RACSignal *signal3 = [RACSignal empty];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RACSignal *signal4 = [RACSignal never];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/categories/Objective-C/"/>
    
    
      <category term="ReactiveCocoa" scheme="http://www.wuqihan.cn/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>RAC(二)基础知识</title>
    <link href="http://www.wuqihan.cn/2017/01/01/RAC-%E4%BA%8C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.wuqihan.cn/2017/01/01/RAC-二-基础知识/</id>
    <published>2017-01-01T09:11:36.000Z</published>
    <updated>2018-08-18T03:09:24.797Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqc24yeimhj31d404k75z.jpg" alt="image-20180414120959021"></p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ul><li>RACStream RACSequence RACSignal</li><li>RACSubscriber</li><li>RACDisposable</li><li>RACScheduler</li><li>Cocoa框架适配工具</li></ul><a id="more"></a><h3 id="RACStream的两个子类：Sequence-amp-Signal"><a href="#RACStream的两个子类：Sequence-amp-Signal" class="headerlink" title="RACStream的两个子类：Sequence &amp; Signal"></a>RACStream的两个子类：Sequence &amp; Signal</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqc2p2ji01j30f309q3ys.jpg" alt="image-20180414122918648"></p><p>RACStream表示一个数据流的类。这个流不一定是基于时间的，所以它有两个子类RACSequence和RACSignal。</p><ul><li>RACSequence是基于空间的数据流</li><li>RACSignal是基于时间的数据流</li></ul><p>对比RACSequence和RACSignal，基于空间的数据流和基于时间的数据流到底有什么区别？</p><ol><li><p><strong>Sequence是Pull-Driven(拉驱动)，Signal是Push-driven(推驱动)</strong></p><p>pull-driver表示数据的变化是由拉取者决定的。举个简单的例子，sequence就好比一本书，我们看书，想看到哪页就可以翻到哪页去看，看什么内容读取什么数据，是由我们决定，而不是由书（sequence）决定。</p><p>push-driver表示数据的变化是由推送者决定的，与pull-driver刚好相反。可以把Signal比作电视体育直播。看什么内容读取什么数据，是由电视(Signal)决定的，如果我们去上个卫生间也无法暂停体育直播，中间的数据就会错过。</p></li><li><p>Sequence里面可以仅仅存放任何类型的数据。RACSignal里面不仅包含数据，也包含信号的状态（后面会了解到信号状态）。</p></li></ol><h3 id="RACSequence的简单使用"><a href="#RACSequence的简单使用" class="headerlink" title="RACSequence的简单使用"></a>RACSequence的简单使用</h3><p>RACSequence使用的情况很少。这里就简单介绍一下常用方法</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//创建</span></span><br><span class="line">   RACSequence *sequence1 = [RACSequence <span class="hljs-keyword">return</span>:@<span class="hljs-number">1</span>];</span><br><span class="line">   RACSequence *sequence2 = [RACSequence sequenceWithHeadBlock:^<span class="hljs-keyword">id</span> _Nullable&#123;</span><br><span class="line">       <span class="hljs-keyword">return</span> @<span class="hljs-number">2</span>;</span><br><span class="line">   &#125; tailBlock:^RACSequence * _Nonnull&#123;</span><br><span class="line">       <span class="hljs-keyword">return</span> sequence1;</span><br><span class="line">   &#125;];</span><br><span class="line">   RACSequence *sequence3 = @[@<span class="hljs-number">1</span>,@<span class="hljs-number">2</span>,@<span class="hljs-number">3</span>].rac_sequence;</span><br><span class="line">   </span><br><span class="line">   <span class="hljs-comment">//变换</span></span><br><span class="line">   RACSequence *mappedSequence = [sequence1 map:^<span class="hljs-keyword">id</span> _Nullable(<span class="hljs-built_in">NSNumber</span>* value) &#123;</span><br><span class="line">       <span class="hljs-keyword">return</span> @(value.integerValue*<span class="hljs-number">3</span>);</span><br><span class="line">   &#125;];</span><br><span class="line">   RACSequence *concatedSequence = [sequence2 concat:mappedSequence];</span><br><span class="line">   RACSequence *mergerdSequence = [RACSequence zip:@[concatedSequence,sequence3]];</span><br><span class="line">   </span><br><span class="line">   <span class="hljs-comment">//遍历</span></span><br><span class="line">   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,mergerdSequence.head);</span><br><span class="line">   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">id</span> value <span class="hljs-keyword">in</span> mergerdSequence) &#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="RACSignal的简单使用"><a href="#RACSignal的简单使用" class="headerlink" title="RACSignal的简单使用"></a>RACSignal的简单使用</h3><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//创建</span></span><br><span class="line">   RACSignal *signal1 = [RACSignal <span class="hljs-keyword">return</span>:<span class="hljs-string">@"hello"</span>];</span><br><span class="line">   RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="hljs-keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">       [subscriber sendNext:@<span class="hljs-number">1</span>];</span><br><span class="line">       [subscriber sendNext:@<span class="hljs-number">2</span>];</span><br><span class="line">       [subscriber sendCompleted];</span><br><span class="line">       <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;</span><br><span class="line">   &#125;];</span><br><span class="line">   RACSignal *signal3 = RACObserve(<span class="hljs-keyword">self</span>.view, backgroundColor);</span><br><span class="line">   </span><br><span class="line">   <span class="hljs-comment">//变换</span></span><br><span class="line">   RACSignal *mappedSignal = [signal1 map:^<span class="hljs-keyword">id</span> _Nullable(<span class="hljs-built_in">NSString</span>* value) &#123;</span><br><span class="line">       <span class="hljs-keyword">return</span> [value stringByAppendingString:<span class="hljs-string">@" word"</span>];</span><br><span class="line">   &#125;];</span><br><span class="line">   RACSignal *concatedSignal = [mappedSignal concat:signal2];</span><br><span class="line">   RACSignal *mergeSignal = [mappedSignal merge:@[concatedSignal,signal3]];</span><br><span class="line">   </span><br><span class="line">   <span class="hljs-comment">//遍历</span></span><br><span class="line">   [mergeSignal subscribeNext:^(<span class="hljs-keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,x);</span><br><span class="line">   &#125; completed:^&#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"completed"</span>);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure><p>这里仅仅是对RACSignal做初步了解。具体方法到底怎么用。后面的文章会讲到。</p><h3 id="RACSubscriber-amp-RACDisposable"><a href="#RACSubscriber-amp-RACDisposable" class="headerlink" title="RACSubscriber &amp; RACDisposable"></a>RACSubscriber &amp; RACDisposable</h3><p>Subscription(订阅者)表⽰等待或者能够等待信号发送事件的任意对象。在框架中使用RACSubscriber协议表示,也即任意实现了RACSubscriber协议的对象都可以是订阅者。可以通过调⽤ -subscribeNext:error:completed:⽅法来创建订阅。RACStream和RACSignal类的大多操作也会⾃己创建订阅。订阅会对Signals对象引⽤计数加1,当信号发送错误或者完成事件后,会⾃动被处理,不需要⽤户关⼼内存管理。当然,⽤户也可以⼿动处理。</p><p>RACDisposable类⽤于取消订阅或者清理资源。</p><p>下图展示了Subscriber、Disposable、Signal三者的关系</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fqc8cu2wgsj30gk08pdg4.jpg" alt="image-20180414154509246"></p><h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><ul><li>用来做调度</li><li>代替GCD</li><li>异步与并发</li></ul><p>scheduler由RACScheduler类表示,它是信号执行任务时所在的队列(queue)或者信号执⾏完后将结果放到队列⾥执行,可以认为就是gcd⾥的queues。scheduler⽀持取消操作,⽽且它总是串行地执⾏任务。这有利于避免死锁。RACScheduler有时候也类似NSOperationQueue,但它不允许任务间相互依赖。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fqc24yeimhj31d404k75z.jpg&quot; alt=&quot;image-20180414120959021&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;核心组件&quot;&gt;&lt;a href=&quot;#核心组件&quot; class=&quot;headerlink&quot; title=&quot;核心组件&quot;&gt;&lt;/a&gt;核心组件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;RACStream RACSequence RACSignal&lt;/li&gt;
&lt;li&gt;RACSubscriber&lt;/li&gt;
&lt;li&gt;RACDisposable&lt;/li&gt;
&lt;li&gt;RACScheduler&lt;/li&gt;
&lt;li&gt;Cocoa框架适配工具&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/categories/Objective-C/"/>
    
    
      <category term="ReactiveCocoa" scheme="http://www.wuqihan.cn/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>RAC(一)函数响应式编程概述</title>
    <link href="http://www.wuqihan.cn/2016/12/14/RAC-%E4%B8%80-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://www.wuqihan.cn/2016/12/14/RAC-一-函数式编程概述/</id>
    <published>2016-12-14T04:05:11.000Z</published>
    <updated>2018-08-18T03:09:24.796Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fqc24yeimhj31d404k75z.jpg" alt="image-20180414120959021"></p><p>ReactiveCocoa是一种新的编程范式(即函数响应式编程)，而不是一个基础库。是在面向对象语言的基础上，对函数响应式编程的实现。本文主要讲解函数式编程和响应式编程。</p><a id="more"></a><h3 id="编程是什么？"><a href="#编程是什么？" class="headerlink" title="编程是什么？"></a>编程是什么？</h3><p>根据冯诺依曼体系结构。编程就是：对输入设备进行采样，最终通过计算设备进行计算，得到的结果通过输出设备输出，这就是编程。</p><p>编程也可以是：根据业务需求，形成一种业务模式，最后通过把这个模式转换为代码实现的一个过程。</p><h3 id="面向过程-vs-面向对象"><a href="#面向过程-vs-面向对象" class="headerlink" title="面向过程 vs 面向对象"></a>面向过程 vs 面向对象</h3><p>“面向过程”和“面向对象”指的是编程思想，它们属于同一种编程范式，都是命令式编程。</p><h3 id="命令式编程-vs-函数式编程"><a href="#命令式编程-vs-函数式编程" class="headerlink" title="命令式编程 vs 函数式编程"></a>命令式编程 vs 函数式编程</h3><p>所有的命令式编程都被设计来高效地使用冯诺依曼体系结构的计算机。实际上，最初的命令式语言的目的就是取代汇编语言，对机器指令进行进一步抽象。因此，命令式语言带有强烈的硬件结构特征。命令式语言的核心特性有：模拟存储单元的变量、基于传输操作的赋值语句，以及迭代形式的循环运算。命令式语言的基础是<strong>语句</strong>（特别是赋值），它们通过修改存储器的值而产生副作用的方式去影响后续的计算。</p><p>函数式语言设计的基础是数学函数，函数式程序设计把程序的输出定义为其输入的一个数学函数，在这里没有内部状态，也没有副作用。函数式语言进行计算的主要是将函数作用与给定参数之上。函数式语言没有命令式语言所必需的那种变量，可以没有赋值语句，也可以没有循环。一个程序就是函数定义和函数应用的说明；一个程序的执行就是对函数应用的求值。</p><p>看下面两段代码，功能都为求一个数的阶乘（n!），下面两段代码分别代表了命令式编程 和 函数式编程。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//命令式编程</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">factorial1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= x; ++i) &#123;</span><br><span class="line">        result *= i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//函数式编程</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">factorial2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> x * factorial2(x<span class="hljs-number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难理解，两个方法的作用相同。都为求一个数的阶乘（n!）。那么两段代码有什么区别呢？</p><ul><li><p>看待运算不懂</p><p>factorial1把运算看做是cpu的运算，有存储，创建、计算，返回值（基于冯诺依曼体系结构）。</p><p>factorial2更接近数学计算，更多的是描述一种运算。n的阶乘是什么呢？那就是n! = n * (n-1)!。所以factorial2就是在表述这种运算。</p></li><li><p>factorial1是基于语句的(赋值语句、for循环语句)，factorial2是基于表达式的（表达式是指有值返回的就叫做表达式）。</p></li><li><p>factorial1是基于状态量的，就是代码中的result，要赋值，比较。factorial2是基于不变量的，代码中没有任何修改值的操作。</p></li></ul><p>factorial1 与 factorial2的对比，也就是命令式编程与函数式编程的对比。像我们平时接触的c、oc、java都是命令式编程很少会接触到纯函数式编程的编程语言,比如Erlang、clojure、Scala。</p><h3 id="总结函数式编程的特点"><a href="#总结函数式编程的特点" class="headerlink" title="总结函数式编程的特点"></a>总结函数式编程的特点</h3><ul><li><p>函数是“第一等公民”</p><p>所谓“第一等公民”，指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p></li><li><p>只用表达式，不用语句</p><p>“表达式”是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p><p>原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。”语句”属于对系统的读写操作，所以就被排斥在外。</p><p>当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。</p></li><li><p>没有“副作用”</p><p>所谓“副作用”，指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</p><p>函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p><p>这个不太容易理解，通俗一点的说，我们平时使用命令式编程开发工程中有经常会有如下场景：fun1()调用完之后才能调用fun2()。那这种情况在函数式编程中就不会出现。因为每个函数都是没有副作用的，不影响外部变量，所以func1()还是func2谁先调用，都无所谓。</p></li><li><p>不修改状态</p><p>上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。在其他类型的语言中，变量往往用来保存”状态”。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。</p></li><li><p>引用透明</p><p>引用透明，指的是函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</p><p>有了前面的第三点和第四点，这点是很显然的。其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫”引用不透明”，很不利于观察和理解程序的行为。</p></li><li><p>惰性计算<strong>（？？有点疑问<a href="http://www.nowamagic.net/academy/detail/1220550" target="_blank" rel="noopener">函数式编程的惰性求值</a>）</strong>  </p></li></ul><h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><p>在计算机中，响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。</p><p>例如，在命令式编程环境中，a=b+c表示将表达式的结果赋给a，而之后改变b或c的值不会影响a。但在响应式编程中，a的值会随着b或c的更新而更新。</p><p>电子表格程序就是响应式编程的一个例子。单元格可以包含字面值或类似”=B1+C1”的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化 。</p><p>在ios开发中，autolayout就是使用了响应式编程。响应式编程理解起来应该会简单一点，这里就不多解释。</p><h3 id="ReactiveCocoa是什么？"><a href="#ReactiveCocoa是什么？" class="headerlink" title="ReactiveCocoa是什么？"></a>ReactiveCocoa是什么？</h3><p>上面讲了函数式编程 和 响应式编程。那么ReactiveCocoa 就是结合了函数式编程和响应式编程的特点：</p><ul><li>函数式编程：将运算过程尽量写成一些列的函数调用。</li><li>响应式编程：面对离散数据流以及对离散数据流进行操作。</li></ul><p>，提供<strong>基于时间变化的数据流</strong>的组合和变换，将输入转化为输出在时间上的持续过程的一种方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fqc24yeimhj31d404k75z.jpg&quot; alt=&quot;image-20180414120959021&quot;&gt;&lt;/p&gt;
&lt;p&gt;ReactiveCocoa是一种新的编程范式(即函数响应式编程)，而不是一个基础库。是在面向对象语言的基础上，对函数响应式编程的实现。本文主要讲解函数式编程和响应式编程。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/categories/Objective-C/"/>
    
    
      <category term="ReactiveCocoa" scheme="http://www.wuqihan.cn/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>iOS内存管理详解</title>
    <link href="http://www.wuqihan.cn/2016/08/20/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://www.wuqihan.cn/2016/08/20/iOS内存管理/</id>
    <published>2016-08-20T08:16:43.000Z</published>
    <updated>2018-08-18T03:09:24.798Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/wqhiOS/blogSources/master/arc/arc.jpg" alt="arc"><br><a id="more"></a></p><h2 id="内存管理-引用计数"><a href="#内存管理-引用计数" class="headerlink" title="内存管理/引用计数"></a>内存管理/引用计数</h2><p>Objective-C的内存管理方式：引用计数</p><h3 id="内存管理的思考方式"><a href="#内存管理的思考方式" class="headerlink" title="内存管理的思考方式"></a>内存管理的思考方式</h3><table><thead><tr><th style="text-align:left">对象操作</th><th>Objective-C方法</th></tr></thead><tbody><tr><td style="text-align:left">生成并持有对象</td><td>alloc/new/copy/mutableCopy等方法</td></tr><tr><td style="text-align:left">持有对象</td><td>retain方法</td></tr><tr><td style="text-align:left">释放对象</td><td>release方法</td></tr><tr><td style="text-align:left">废弃对象</td><td>dealloc方法</td></tr></tbody></table><p>​    这些有关Objective-C内存管理的方法，实际上不包括在该语言中，而是包含在Cocoa框架中用于OS X、iOS应用开发。<strong>Cocoa框架中Foundation框架类库的NSObject类担负内存管理的职责</strong>。<img src="https://ws1.sinaimg.cn/large/006tKfTcly1fnxex4oeslj308w05rgn5.jpg" alt="IMG_3B1C737308BF-1"></p><ul><li><p>自己生成的对象，自己持有</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 自己生成并持有对象</span></span><br><span class="line"><span class="hljs-keyword">id</span> obj = [[<span class="hljs-built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure><p>使用alloc/new/copy/mutableCopy的方法，取得的对象都是自己生成并持有的。</p><p>用这些以外的方法取得的对象，因为非自己生成，所以自己不是对象的持有者。</p><p>copy方法利用基于NSCopying方法约定，由各类实现的copyWithZone:方法生成并持有对象的副本，mutable与copy类似  。用copy/mutableCopy方法生成的对象，虽然是对象的副本，但同allco、new方法一样，在“自己生成并持有对象”这点上没有改变。</p></li><li><p>非自己生成的对象，自己也能持有</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">取得非自己生成对象，不持有</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-keyword">id</span> obj = [<span class="hljs-built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">自己持有</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line">[obj reatin];</span><br></pre></td></tr></table></figure><p>通过retain方法，非自己生成的像 可以被自己所持有。</p></li><li><p>不再需要自己持有的对象时释放</p><p>用alloc/new/copy/mutableCopy方法生成并持有的对象，或者用retain方法持有的对象，一旦不再需要，务必要用release方法进行释放。</p></li><li><p>无法释放非自己持有的对象</p></li></ul><blockquote><p>内存管理黄金法则：</p><p>The basic rule to apple is everything thatincreases the reference counter with alloc,[mutable]copy[WithZone:] or retainis in charge of the corresponding [auto]release.</p><p>如果一个对象使用了alloc，[mutable] copy，retain，那么你必须使用相应的[auto]release</p></blockquote><h3 id="苹果对于引用计数的实现"><a href="#苹果对于引用计数的实现" class="headerlink" title="苹果对于引用计数的实现"></a>苹果对于引用计数的实现</h3><p>在NSObject类的alloc类方法上设置断点，追踪程序的执行。以下列出了执行所调用的方法和函数：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+alloc</span><br><span class="line">+allocWithZone:</span><br><span class="line">class_createInstance</span><br><span class="line"><span class="hljs-built_in">calloc</span></span><br></pre></td></tr></table></figure><p>alloc类方法首先调用allocWithZone:类方法，然后调用class_createInstance函数，最后通过调用calloc来分配内存块。</p><p>retainCount/retain/release实例方法又是怎么实现呢？同刚才的方法一样，下面列出各个方法分别调用的方法和函数：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-retainCount</span><br><span class="line">__CFDoExternRefOperation</span><br><span class="line">CFBasicHashGetCountOfKey</span><br></pre></td></tr></table></figure><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-retain</span><br><span class="line">__CFDoExternRefOperation</span><br><span class="line">CFBasicHashAddValue</span><br></pre></td></tr></table></figure><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-release</span><br><span class="line">__CFDoExternRefOperation</span><br><span class="line">CFBasicHashRemoveValue</span><br><span class="line">(CFBasicHashRemoveValue返回<span class="hljs-number">0</span>时，-release调用dealloc)</span><br></pre></td></tr></table></figure><p>各个方法都通过同一个__CFDoExternRefOperation函数，调用了一系列名称相似的函数。如这些函数名的前缀”CF”所示，她们包含于CoreFoundation框架源代码中，即是CFRuntime.c的CFDoExternRefOperation函数。为了理解其实现，下面简化该函数的源代码：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> __CFDoExternRefOperation(<span class="hljs-keyword">uintptr_t</span> op, id obj) &#123;</span><br><span class="line"></span><br><span class="line">    CFBasicHashRef table = 取得对象的散列表(obj);</span><br><span class="line">    <span class="hljs-keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="hljs-keyword">case</span> OPERATION_retainCount:</span><br><span class="line">        count = CFBasicHashGetCountOfKey(table, obj);</span><br><span class="line">        <span class="hljs-keyword">return</span> count;</span><br><span class="line">        <span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">case</span> OPERATION_retain:</span><br><span class="line">        count = CFBasicHashAddValue(table, obj);</span><br><span class="line">        <span class="hljs-keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">case</span> OPERATION_release:</span><br><span class="line">        count = CFBasicHashRemoveValue(table, obj);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> == count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__CFDoExternRefOperation通过switch语句 针对不同的操作来进行具体的方法调用，retainCount/retain/release实例方法也许如下面代码所示：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-built_in">NSUInteger</span>)retainCount</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">NSUInteger</span>)____CFDoExternRefOperation(OPERATION_retainCount,<span class="hljs-keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">id</span>)<span class="hljs-keyword">retain</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">id</span>)____CFDoExternRefOperation(OPERATION_retain,<span class="hljs-keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)release</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> ____CFDoExternRefOperation(OPERATION_release,<span class="hljs-keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上，可以看出苹果的大概实现就是将引用计数保存在引用计数表的记录中，而不是保存在对象占用内存块头部中。采用散列表(引用计数表)来管理引用计数。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fnxiv07q3tj30hs081ae7.jpg" alt="IMG_75C55E500AB3-1"></p><p>这样的好处是：</p><ul><li>不用在每个对象内存块中考虑引用计数所占的内存</li><li>引用技术表各记录中存有内存地址，可从各个记录追溯到各对象的内存块（即使出现故障导致对象占用的内存块损坏，但只要引用计数表没有被破坏，就能够确认各个内存块的位置）</li></ul><p>另外，在利用工具检测内存泄漏时，引用计数表的各记录也有助于检测各对象的持有者是否存在。</p><h2 id="Autorelease"><a href="#Autorelease" class="headerlink" title="Autorelease"></a>Autorelease</h2><p>使用autorelease，可使取得的对象存在但自己不持有对象。autorelease提供 这样的功能，使对象在超出指定的生存范围时能够自动并正确地释放(自动调用release方法)。</p><h3 id="autorelease的具体使用方法如下"><a href="#autorelease的具体使用方法如下" class="headerlink" title="autorelease的具体使用方法如下"></a>autorelease的具体使用方法如下</h3><ol><li>生成并持有NSAutoreleasePool对象</li><li>调用已分配对象的autorelease实例方法</li><li>废弃NSAutoreleasePool对象</li></ol><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fq5cw1ev3tj30ye0frwux.jpg" alt="image-20180408170302393"></p><p>NSAutoreleasePool对象的生存周期相当于C语言变量的作用域。对于所有调用过autorelease实例方法的对象，在废弃NSAutoreleasePool对象时，都将调用release实例方法。</p><p>用源代码表示如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSAutoReleasePool *pool = [[NSAutoReleasePool alloc] init];</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line">[pool drain];</span><br></pre></td></tr></table></figure><blockquote><p>NSAutoreleasePool对象的销毁是调用 drain() 方法</p></blockquote><p>ARC中使用NSAutoReleasePool：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//在&#123;&#125;中存放的对象会在&#125;后释放掉</span></span><br></pre></td></tr></table></figure><h3 id="使用NSAutoreleasePool减少内存峰值"><a href="#使用NSAutoreleasePool减少内存峰值" class="headerlink" title="使用NSAutoreleasePool减少内存峰值"></a>使用NSAutoreleasePool减少内存峰值</h3><p>在大量产生autorelease的对象时，只要不废弃NSAutoReleasePool对象，那么生成的对象就不能被释放，因此有时会产生内存不足的现象。典型的例子是读入大量图象的同时改变其尺寸。图象文件读入到NSData对象，并生成UIImage对象，改变该对象的尺寸后生成新的UIImage对象。这种情况下，就会大量生成autorelease对象。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, i &lt; 图像数, ++i) &#123;</span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">     *读入图像</span></span><br><span class="line"><span class="hljs-comment">     *大量产生autorelease对象</span></span><br><span class="line"><span class="hljs-comment">     *由于没有废弃NSAutoreleasePool对象</span></span><br><span class="line"><span class="hljs-comment">     *最终导致内存不足</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此情况下，有必要在适当地方生成、持有或废弃NSAutoreleasePool对象。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; 图像数; ++i) &#123;</span><br><span class="line">    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">     *读入图像</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    [pool drain];</span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">    *通过[pool drain],</span></span><br><span class="line"><span class="hljs-comment">    *autorelease的对象被一起废弃</span></span><br><span class="line"><span class="hljs-comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="autorelease对象什么时候释放"><a href="#autorelease对象什么时候释放" class="headerlink" title="autorelease对象什么时候释放"></a>autorelease对象什么时候释放</h3><p>很多人的答案是“当前作用域大括号结束时释放”，显然没有正确理解autorelease的机制。在没有手动添加autoreleasepool的情况下，<strong>autorelease对象是在当前runloop迭代结束时释放的</strong>。而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop。</p><p>看下面代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__<span class="hljs-keyword">weak</span> <span class="hljs-keyword">id</span> reference = <span class="hljs-literal">nil</span>;</span><br><span class="line">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    __autoreleasing Person *p = [[Person alloc] init];</span><br><span class="line">    reference = p;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,reference);<span class="hljs-comment">//Console: &lt;Person: 0x60000000f170&gt;</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="hljs-keyword">void</span>)viewWillAppear:(<span class="hljs-built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,reference);<span class="hljs-comment">//Console: &lt;Person: 0x60000000f170&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)viewDidAppear:(<span class="hljs-built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,reference);<span class="hljs-comment">//Console: (null)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这个vc在loadView之后便add到了window层级上，所以<code>viewDidLoad</code>和<code>viewWillAppear</code>是在同一个runloop调用的，因此在<code>viewWillAppear</code>中，这个autorelease的变量依然有值。当然我们也可以手动干预autorelease对象的释放时机：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__<span class="hljs-keyword">weak</span> <span class="hljs-keyword">id</span> reference = <span class="hljs-literal">nil</span>;</span><br><span class="line">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        __autoreleasing Person *p = [[Person alloc] init];</span><br><span class="line">        reference = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,reference);<span class="hljs-comment">//Console: (null)</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="hljs-keyword">void</span>)viewWillAppear:(<span class="hljs-built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,reference);<span class="hljs-comment">//Console: (null)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)viewDidAppear:(<span class="hljs-built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>,reference);<span class="hljs-comment">//Console: (null)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="苹果对于autorelease的实现"><a href="#苹果对于autorelease的实现" class="headerlink" title="苹果对于autorelease的实现"></a>苹果对于autorelease的实现</h3><p>autorelease实例方法的本质就是调用NSAutoreleasePool对象的addObject方法。</p><p>系统在每个runloop迭代中都加入了自动释放池的Push和Pop方法。具体为runloop开始的时候调用AutoreleasePoolPage的Push方法，结束的时候调用Pop方法。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">objc_autoreleasePoolPush</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">objc_autoreleasePoolPop</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ctxt)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么AutoreleasePoolPage是什么东西呢？</p><p>AutoReleasePoolPage是一个C++的类，在NSObject.mm中定义是：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoreleasePoolPage</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">magic_t</span> <span class="hljs-keyword">const</span> magic;</span><br><span class="line">    id *next;</span><br><span class="line">    <span class="hljs-keyword">pthread_t</span> <span class="hljs-keyword">const</span> thread;</span><br><span class="line">    AutoreleasePoolPage * <span class="hljs-keyword">const</span> parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> <span class="hljs-keyword">const</span> depth;</span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> hiwat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>magic 用于对当前 AutoreleasePoolPage`<strong>完整性</strong>的校验</p></li><li><p>thread 保存了当前所在的线程</p><p>​</p></li></ul><p>每一个自动释放池都是由一系列的AutoreleasePoolPage组成的，并且每一个AutoreleasePoolPage的大小都是4096字节(0x1000)</p><p>自动释放池中的AutoreleasePoolPage是以<strong>双向链表</strong>的形式链接起来的：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqjgq5m20tj30rs05iwg1.jpg" alt="image-20180420215336249"></p><p>parent 和 child 就是用来构造双向链表的指针。</p><h3 id="autorelease和runloop的关系"><a href="#autorelease和runloop的关系" class="headerlink" title="autorelease和runloop的关系"></a>autorelease和runloop的关系</h3><p>runloop开始启动的时候会创建autoreleasePool，结束的时候会销毁autoreleasePool</p><h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><p>引用计数内存管理的本质部分在ARC中并没有改变。ARC只是自动帮我们处理“引用计数”的相关部分。</p><h3 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h3><p>ARC有效时，id类型和对象类型同C语言其他类型不同，其类型上必须附加所有权修饰符。所有权修饰符一共有4中。</p><ul><li><p>__strong</p><p>__strong修饰符是id类型和对象类型默认的所有权修饰符。__strong修饰符表示对对象的“强引用”，持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放。</p><p>__strong修饰符修饰的变量，不仅仅只在变量作用域中，在赋值上也能够正确地管理其对象的所有者。</p><p>通过__strong修饰符，不必再键入retain或者release，完美地满足了“引用技术内存管理的思考方式”</p></li><li><p>__weak</p><p>多用来解决“循环引用”的问题。</p><p>__weak修饰符还有另外一个优点，在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于nil被赋值的状态（空弱引用）。</p></li><li><p>__unsafe_unretained</p><p>__unsafe_unretained修饰符正如其名unsafe所示，是不安全的所有权修饰符。尽管ARC式的内存管理是编译器的工作，但附有 __unsafe_unretained修饰符的变量不属于编译器的内存管理对象。</p><p>和__weak一样都是弱引用。但是当引用的对象被废弃后，指针不会置为nil，会造成野指针</p></li><li><p>__autoreleasing</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* ARC无效 */</span></span><br><span class="line"><span class="hljs-built_in">NSAutoreleasePool</span> *pool = [[<span class="hljs-built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="hljs-keyword">id</span> obj = [[<span class="hljs-built_in">NSObject</span> alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line">[pool drain];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* ARC有效 与上面代码等价 */</span></span><br><span class="line"><span class="hljs-keyword">@autoreleasepool</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">id</span> __autoreleaseing obj = [[<span class="hljs-built_in">NSObject</span> alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ARC有效时，autorelease功能是起作用的。用@autorelasepool块替代NSAutoreleasePool类，用附有__autoreleasing修饰符的变量替代autorelease方法。</p><p>对象赋值给附有__autorelease修饰符的变量等价于在ARC无效时调用对象的autorelease方法，即对象被注册到autoreleasepool。</p><p>显示地附加_<em>autoreleaseing修饰符同显示地附加\</em>_strong修饰符一样罕见，所以在ARC中经常非显示地使用___autoreleasing修饰符。</p><p>非显示地使用__autoreleaseing修饰符的列子：</p><p>1)  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id __weak obj1 = obj0;</span><br><span class="line">NSLog(@&quot;class=%@&quot;,[obj1 class]);</span><br></pre></td></tr></table></figure><p>下面的代码与上面的相同：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id __weak obj1 = obj0;</span><br><span class="line">id __autoreleasing tmp = obj1;</span><br><span class="line">NSLog(@&quot;class=%@&quot;,[tmp class]);</span><br></pre></td></tr></table></figure><p><strong>在访问到weak修饰符的变量时必须访问注册到autoreleasepool的对象</strong>。这是因为weak修饰符只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。如果把要访问的对象注册到autoreleasepool中，那么在@autoreleasepool块结束之前都能确保该对象存在。因此，使用富有weak修饰符的变量时就必定要使用注册到autoreleasepool中的对象。</p><p>2）</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="hljs-keyword">id</span>)array &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSMutableArray</span> new];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述源代码等同于：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="hljs-keyword">id</span>)array &#123;</span><br><span class="line">    <span class="hljs-keyword">id</span> obj = [<span class="hljs-built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="hljs-keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于return使得对象变量超出其作用域，所以该强引用对应的自己持有的对象会被自动释放，但该对象作为返回值，编译器会自动将其注册到autoreleasePool。</p><p>3)</p><p>id的指针或对象的指针在没有显示指定时会被附加上__autoreleasing修饰符</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSError *error = nil;</span><br><span class="line">Bool result = [obj performOperationWithError:&amp;error];</span><br></pre></td></tr></table></figure><p>该方法的声明为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)performOperationWithError:(NSError **)error;</span><br></pre></td></tr></table></figure><p>等同于一下源代码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)performOperationWithError:(NSError * __autoreleasing*)error;</span><br></pre></td></tr></table></figure></li></ul><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li><p>不能使用retain/release/retainCount/autorelease</p></li><li><p>不能使用NSAllocateObject/NSDeallocateObject</p></li><li><p>须遵守内存管理的方法命名规则</p></li><li><p>不要显示调用dealloc</p></li><li><p>使用@autoreleasepool块代替NSAutoreleasePool</p></li><li><p>不能使用区域(NSZone)</p><p>不管ARC是否有效，区域在现在的运行时系统中已单纯地被忽略</p></li><li><p>对象型变量不能作为C语言结构体的成员</p><p>C语言的规约上没有方法来管理结构体成员的生命周期。因为ARC把内存管理的工作分配给编译器，所以编译器必须能够知道并管理对象的生命周期。例如C语言的自动变量(局部变量)可使用该变量的作用于来管理对象。但是对于C语言的结构体成员来说，这在标准上就是不可实现的。</p><p>如果非要把对象型变量加入到结构体重时，可强制转换为void *或是附加见面所述的__unsafe_unretained修饰符（附有___unsafe_unretained修饰符的变量不属于编译器的内存管理对象。如果管理时不注意赋值对象的所有者，便有可能遭遇内存泄漏或程序崩溃）</p></li><li><p>显示转换id和void *</p><p>通过_<em>bridge，id和void能够相互转换。但是\</em>_bridge转换，其安全性与赋值给__unsafe_unretained修饰符相近，甚至会更低。如果管理时不注意赋值对象的所有者，就会因悬垂指针而导致程序崩溃。</p><p>__bridge转换中还有另外两种转换，分别是__bridge_retained转换和__bridge_transfer转换</p></li></ul><p>## </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wqhiOS/blogSources/master/arc/arc.jpg&quot; alt=&quot;arc&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/categories/Objective-C/"/>
    
    
      <category term="内存管理" scheme="http://www.wuqihan.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Grand Central Dispatch</title>
    <link href="http://www.wuqihan.cn/2016/07/18/Grand-Central-Dispatch/"/>
    <id>http://www.wuqihan.cn/2016/07/18/Grand-Central-Dispatch/</id>
    <published>2016-07-18T07:21:44.000Z</published>
    <updated>2018-08-18T03:09:24.795Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/wqhiOS/blogSources/master/GCD/gcd_logo.jpeg" alt="GCD"><br><a id="more"></a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>什么是GCD<ul><li>全程：Grand Central Dispatch（强大的中枢调度器）</li><li>纯C语言，提供了非常强大的函数</li></ul></li><li>GCD的优势<ul><li>GCD会自动利用更多的CPU内核</li><li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li><li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</li></ul></li></ul><h3 id="任务和队列"><a href="#任务和队列" class="headerlink" title="任务和队列"></a>任务和队列</h3><ul><li>GCD中有两个核心概念<ul><li>任务：执行什么操作</li><li>队列：用来存放任务</li></ul></li><li>GCD的使用有两个步骤<ul><li>定制任务</li><li>将任务添加到队列中<ul><li>GCD会自动将队列中的任务取出来，放到对应的线程中执行</li><li>任务的取出遵循队列的FIFO（现金先出）原则</li></ul></li></ul></li></ul><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><ul><li><p>GCD中有两个用来执行任务的常用函数</p><ul><li><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     用同步的方式执行任务</span></span><br><span class="line"><span class="hljs-comment"></span></span><br><span class="line"><span class="hljs-comment">     @param queue#&gt; 队列 description#&gt;</span></span><br><span class="line"><span class="hljs-comment">     @param void block任务</span></span><br><span class="line"><span class="hljs-comment">     @return</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-built_in">dispatch_sync</span>(&lt;<span class="hljs-meta">#dispatch_queue_t  _Nonnull queue#&gt;, <span class="hljs-meta-string">&lt;#^(void)block#&gt;</span>);</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     用异步的方式执行任务</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(&lt;<span class="hljs-meta">#dispatch_queue_t  _Nonnull queue#&gt;, <span class="hljs-meta-string">&lt;#^(void)block#&gt;</span>);</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>还有个用来执行任务的函数：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;     <span class="hljs-comment">//第一个参数queue 不能是全局的并发队列</span></span><br><span class="line">&gt; <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">&gt; dispatch_barrier_async函数的作用与barrier的意思相同,在进程管理中起到一个栅栏的作用,它等待所有位于barrier函数之前的操作执行完毕后执行,并且在barrier函数执行之后,barrier函数之后的操作才会得到执行,该函数需要同dispatch_queue_create函数生成的concurrent Dispatch Queue  队列一起使用</span></span><br><span class="line"><span class="hljs-comment">&gt; */</span></span><br><span class="line">&gt;     dispatch_barrier_async(&lt;<span class="hljs-meta">#dispatch_queue_t  _Nonnull queue#&gt;, <span class="hljs-meta-string">&lt;#^(void)block#&gt;</span>);</span></span><br><span class="line">&gt;     dispatch_barrier_sync(&lt;<span class="hljs-meta">#dispatch_queue_t  _Nonnull queue#&gt;, <span class="hljs-meta-string">&lt;#^(void)block#&gt;</span>);</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>同步和异步的区别</p><ul><li>同步：只能在当前线程中执行任务，不具备开启新线程的能力</li><li>异步：只能在新的线程中执行任务，局别开启新线程的能力</li></ul><blockquote><p>同步、异步、并发、串行 要分清楚</p><ul><li>同步和异步主要影响：能不能开启新的线程<ul><li>同步：只是在当前线程中执行任务，不具备开启新线程的能力</li><li>异步：可以在新的线程中执行任务，具备开启新线程的能力</li></ul></li><li>并发和串行主要影响：任务的执行方式<ul><li>并发：允许多个任务并发（同时）执行</li><li>串行：一个任务执行完毕后，再执行下一个任务</li></ul></li></ul></blockquote></li><li><p>dispatch_async 和 dispatch_sync 还要一个很重要的区别</p><ul><li><p>异步执行 会立刻返回</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//验证异步执行会立刻返回</span></span><br><span class="line">   <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">       <span class="hljs-comment">//子线程</span></span><br><span class="line">       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;</span><br><span class="line">           <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"22222"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"33333"</span>);</span><br><span class="line">   <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">   先打印33333</span></span><br><span class="line"><span class="hljs-comment">   最后才是2222。。。</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>同步执行会等待执行结束后才返回</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//验证同步执行会等待执行结束后返回</span></span><br><span class="line">   <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">       <span class="hljs-comment">//因为是同步。不会开启线程，所以仍然是main线程</span></span><br><span class="line">       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;</span><br><span class="line">           <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"22222"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"33333"</span>);</span><br><span class="line">   <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">   先打印完所有22222</span></span><br><span class="line"><span class="hljs-comment">   最后才会打印33333</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br></pre></td></tr></table></figure><p>正是因为这个特性 在主线程同步调用任务在mainQueue里，就会造成死锁的情况。因为：<br>1）:dispatch_sync在等待block语句执行完成，而block语句需要在主线程里执行，所以dispatch_sync如果在主线程调用就会造成死锁<br>2）:dispatch_sync是同步的，本身就会阻塞当前线程，也即主线程。而又往主线程里塞进去一个block，所以就会发生死锁。</p></li></ul><p>​</p></li></ul><h3 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h3><h4 id="队列的类型"><a href="#队列的类型" class="headerlink" title="队列的类型"></a>队列的类型</h4><ul><li>GCD的队列可以分为2大类型<ul><li>并发队列<ul><li>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）</li><li>并发功能只有在异步（dispatch_async）函数下才有效</li></ul></li><li>串行队列<ul><li>让任务一个接着一个地执行（一个任务执行完毕之后，再执行下一个任务）</li></ul></li></ul></li></ul><h4 id="如何创建并发队列"><a href="#如何创建并发队列" class="headerlink" title="如何创建并发队列"></a>如何创建并发队列</h4><p>第一种方法：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_create(<span class="hljs-string">"com.a"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><p>第二种方法：使用系统提供的 Global Dispatch Queue</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//第一个设置优先级，仅仅是大致优先级。第二个暂时没用</span></span><br></pre></td></tr></table></figure><h4 id="如何创建串行队列"><a href="#如何创建串行队列" class="headerlink" title="如何创建串行队列"></a>如何创建串行队列</h4><p>第一种方法：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_create(<span class="hljs-string">"com.b"</span>, <span class="hljs-literal">NULL</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意：《iOS与OS X多线程和内存管理》中讲到 使用dispatch_queue_create()创建的DispatchQueue在ARC中也需要手动调用dispatch_release（）方法释放。经过验证，iOS6以后的ARC中就不需要了。</p></blockquote><p>这里需要注意使用Serial Disparch Queue时，其生成个数的问题，Concurrent Dispatch Queue能够并行执行多个追加处理（也就是会开启多条线程去处理追加到队列中的的多个任务），而Serial Dispatch Queue同时只能执行一个追加处理（也就是只能开启一条线程）。</p><p>但是当通过dispatch_queue_create()生成多个Serial Dispatch Queue时，各个Serial Dispatch Queue将并行执行（<strong>前提是使用异步方式</strong>）。虽然在一个Serial Dispatch Queue中同时只能执行一个追加处理，但如果将处理分别追加到4个Serial Dispatch Queue中，各个Serial Dispatch Queue执行一个，即为并行执行4个处理。≈ 如下图：</p><p><img src="https://raw.githubusercontent.com/wqhiOS/blogSources/master/GCD/gcd1.png" alt="多个Serial Dispatch Queue"></p><p>如果生成2000个Serial Dispatch Queue，那么就生成2000个线程，如果过多使用，就会消耗大量内存，引起大量的上下文切换，大幅度降低系统的性能。</p><p>第二种方法：直接使用主队列（主队列是串行队列）</p><h3 id="GCD的其他函数"><a href="#GCD的其他函数" class="headerlink" title="GCD的其他函数"></a>GCD的其他函数</h3><h4 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h4><ol><li><p>变更Dispatch Queue的执行优先级。<br>dispatch_queue_create函数生成的Dispatch Queue不管是Serial Dispatch Queue还是Concurrent Dispatch Queue，都使用与默认优先级Global Dispatch Queue相同执行优先级的线程。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.oukavip.www&quot;,NULL);</span><br><span class="line">    dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);</span><br><span class="line">   dispatch_set_target_queue(serialQueue, globalQueue);</span><br><span class="line">   // 第一个参数为要设置优先级的queue,第二个参数是参照物，既将第一个queue的优先级和第二个queue的优先级设置一样。</span><br><span class="line">//第一个参数如果指定系统提供的Main/Global Dispatch Queue则不知道会出现什么情况，因此这些均不可以指定。</span><br></pre></td></tr></table></figure></li><li><p>将Dispatch Queue指定为dispatch_set_target_queue函数的参数还可以作成Dispatch Queue的执行阶层，那么原本应并行执行的多个Serial Dispatch Queue，在目标Serial Dispatch Queue上只能同时执行一个处理。（修改用户队列的目标队列，使多个Queue在目标Queue上一次只有一个执行）</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> targetQueue = dispatch_queue_create(<span class="hljs-string">"targetQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="hljs-string">"queue1"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="hljs-built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="hljs-string">"queue1"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//设置参考</span></span><br><span class="line">    dispatch_set_target_queue(queue1, targetQueue);</span><br><span class="line">    dispatch_set_target_queue(queue2, targetQueue);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"job3 in"</span>);</span><br><span class="line">        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2.</span>f];</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"job3 out"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"job2 in"</span>);</span><br><span class="line">        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1.</span>f];</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"job2 out"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"job1 in"</span>);</span><br><span class="line">        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">3.</span>f];</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"job1 out"</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>打印输出为：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">48.144492</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">3693</span>:<span class="hljs-number">336603</span>] job3 in</span><br><span class="line"><span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">50.148901</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">3693</span>:<span class="hljs-number">336603</span>] job3 out</span><br><span class="line"><span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">50.149213</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">3693</span>:<span class="hljs-number">336603</span>] job2 in</span><br><span class="line"><span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">51.153663</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">3693</span>:<span class="hljs-number">336603</span>] job2 out</span><br><span class="line"><span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">51.154019</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">3693</span>:<span class="hljs-number">336603</span>] job1 in</span><br><span class="line"><span class="hljs-number">15</span>:<span class="hljs-number">19</span>:<span class="hljs-number">54.157262</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">3693</span>:<span class="hljs-number">336603</span>] job1 out</span><br></pre></td></tr></table></figure><p>通过打印的结果说明我们设置了queue1和queue2队列以targetQueue队列为参照对象，那么queue1和queue2中的任务将按照targetQueue的队列处理。</p><p>在必须将不可并行执行的处理追加到多个Serial Dispatch Queue中时，如果使用dispatch_set_target_queue函数将目标制定为某一个Serial Dispatch Queue，即可防止处理并行执行。</p><p>适用场景：一般都是把一个任务放到一个串行的queue中，如果这个任务被拆分了，被放置到多个串行的queue中，但实际还是需要这个任务同步执行，那么就会有问题，因为多个串行queue之间是并行的。这时候dispatch_set_target_queue将起到作用。</p></li></ol><h4 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h4><p>想在指定时间后执行处理，可使用dispatch_after函数来实现。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//在3秒后将指定的block追加到Main Dispatch Queue中</span></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">3</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"waited at last three seconds."</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>dispatch_after函数并不是在指定时间后执行处理，而只是在指定时间追加处理到Dispatch Queue。此源代码与在3秒后用dispatch_async函数追加block到Main Dispatch Queue相同。</p><p>因为Main Dispatch Queue在主线程的RunLoop中执行，所以在比如每隔1/60秒执行的RunLoop中，block最快在3秒后执行，最慢在3+1/60秒后执行。并且Main Dispatch Queue有大量处理追加或主线程的处理本身有延迟时，这个时间会更长。如果想在大致延迟时间执行处理，该函数是非常有效的。</p><h4 id="disparch-group-t"><a href="#disparch-group-t" class="headerlink" title="disparch_group_t"></a>disparch_group_t</h4><p>无论向什么样的Dispatch Queue中追加处理，使用Dispatch Group都可以监视这些处理执行的结束。一旦检测到所有处理执行结束，就可将结束的处理追加到Dispatch Queue中。这就是使用Dispatch Group的原因。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);</span><br><span class="line">   dispatch_group_t group = dispatch_group_create();</span><br><span class="line">   </span><br><span class="line">   dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"blk0"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"blk1"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_group_async(group, dispatch_queue_create(<span class="hljs-string">"com.wuqh.queue"</span>, <span class="hljs-literal">NULL</span>), ^&#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"blk2"</span>);</span><br><span class="line">       [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">5</span>];</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"blk2done"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"done"</span>);</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>另外，在Dispatch Gourp中也可以使用dispatch_group_wait函数仅等待全部处理执行结束。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"blk0"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"blk1"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, dispatch_queue_create(<span class="hljs-string">"com.wuqh.queue"</span>, <span class="hljs-literal">NULL</span>), ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"blk2"</span>);</span><br><span class="line">        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">5</span>];</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"blk2done"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-comment">//程序会一直停留在此处等待gourp中的任务，直到全部执行完毕才会继续向下执行。</span></span><br><span class="line"><span class="hljs-comment">//也就是说，意味着一旦调用dispatch_group_wait函数，该函数就处于调用的状态而不返回。即执行dispatch</span></span><br><span class="line"><span class="hljs-comment">//_group_wait函数的线程停止。在经过dispatch_group_wait函数中指定时间或任务全部执行结束之前</span></span><br><span class="line"><span class="hljs-comment">//执行该函数的线程停止</span></span><br><span class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure><p>也可以指定等待时间。disparch_group_wait，有一个long类型的返回值，返回值为0，表示全部执行结束，返回值不为0，表示虽然经过了指定时间，但还有某些处理没有执行完。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">long</span> result = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">3</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>)));</span><br><span class="line">    <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"没有全部执行结束执行结束"</span>);</span><br><span class="line">    &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"全部执行结束"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>指定time为DISPATCH_TIME_NOW，则不用任何等待即可判定属于Dispatch Group的处理是否执行结束。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">long</span> result = dispatch_group_wait(group, DISPATCH_TIME_NOW);</span><br></pre></td></tr></table></figure><h4 id="dispatch-a-sync"><a href="#dispatch-a-sync" class="headerlink" title="dispatch_(a)sync"></a>dispatch_(a)sync</h4><p>dispatch_async函数的”async“意味着“非同步”，就是将指定的block”非同步”地追加到指定的队列中。dispatch_async函数不作任何等待，如下图：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fpdkusphkej30lc09xtck.jpg" alt="mage-20180315162245"></p><p>dispatch_sync意味着“同步”。函数会一直等待执行结束，“等待”意味着当前线程停止。如下图：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fpdkt9644rj30kt0a4ads.jpg" alt="mage-20180315162057"></p><p>注意：dispatch_sync函数容易引起问题，即死锁。例如在主线程中执行以下源代码就会死锁：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="hljs-comment">//。。。</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>使用async，或者Serail Dispatch Queue都会遇到死锁，如下：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"..."</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">"com.gcd.error"</span>, <span class="hljs-literal">NULL</span>);</span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"..."</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="dispatchbarrier-a-sync"><a href="#dispatchbarrier-a-sync" class="headerlink" title="dispatchbarrier(a)sync"></a>dispatch<em>barrier</em>(a)sync</h4><p>在进程管理中起到一个栅栏的作用，它等待所有位于barrier函数之前的操作执行完毕后执行，并且在barrier函数执行之后，barrier函数之后的操作才会得到执行，该函数需要同dispatch_queue_create函数生成的Concureent Dispatch Queue队列一起使用。<strong>注意：与使用dispatch_get_global_queue()获得的队列一起使用无效</strong>。</p><p>作用：</p><ul><li>实现高效率的数据库访问和文件访问</li><li>避免数据竞争</li></ul><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">"com.gcd"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"----1----%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"----2----%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"----barrier----%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"----3----%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"----4----%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="hljs-comment">//先执行1和2，之后是barrier，最后是3和4</span></span><br></pre></td></tr></table></figure><p>同dispath_async一样，此函数也有一个这样的函数：dispatch_barrier_sync函数，此函数与dispatch_barrier_async的区别和 dispatch_async与dispatch_sync的区别相同：async不阻塞当前线程。</p><h4 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h4><p> dispatch_apply函数时dispatch_sync函数和Dispatch Group的关联API。该函数按指定的次数将指定的block追加到指定的Dispatch Queue中，并等待全部处理执行结束。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">NSArray</span> *array = [<span class="hljs-built_in">NSArray</span> arrayWithObjects:@<span class="hljs-number">0</span>,@<span class="hljs-number">1</span>,@<span class="hljs-number">2</span>,@<span class="hljs-number">3</span>,@<span class="hljs-number">4</span>,@<span class="hljs-number">5</span>,@<span class="hljs-number">6</span>,@<span class="hljs-number">7</span>,@<span class="hljs-number">8</span>,@<span class="hljs-number">9</span>, <span class="hljs-literal">nil</span>];</span><br><span class="line">dispatch_apply([array count], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^(size_t index) &#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"async:%@-%@"</span>,array[index],[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"done"</span>);<span class="hljs-comment">//同sync一样。最后才会打印done。</span></span><br></pre></td></tr></table></figure><p>由于dispatch_apply函数会等待执行结束，因此有时候也可以在dispatch_async函数中非同步地执行dispatch_apply函数。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">        dispatch_apply([array count],  dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^(size_t index) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"async:%@-%@"</span>,array[index],[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"success"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"done"</span>);<span class="hljs-comment">//因为async不需要等待，所以会立马执行，不会最后才打印。</span></span><br></pre></td></tr></table></figure><h4 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend/dispatch_resume"></a>dispatch_suspend/dispatch_resume</h4><p>当追加大量处理到Dispatch Queue时，在追加处理的过程中，有时希望不执行已追加的处理。在这种情况下，只要挂起Dispatch Queue即可，当可以执行时再恢复。</p><p>注意：dispatch_suspend/dispatch_resume对全局队列不起作用。</p><p>必须确保dispatch_suspend/dispatch_resume成对调用。那么这里有个问题？<strong>gcd中如何中途结束线程？</strong></p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">"com.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="hljs-comment">//提交第一个block，延时5秒打印。</span></span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    sleep(<span class="hljs-number">5</span>);</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"After 5 seconds..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-comment">//提交第二个block，也是延时5秒打印</span></span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    sleep(<span class="hljs-number">5</span>);</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"After 5 seconds again..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-comment">//延时一秒</span></span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"sleep 1 second..."</span>);</span><br><span class="line">sleep(<span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-comment">//挂起队列</span></span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"suspend..."</span>);</span><br><span class="line">dispatch_suspend(queue);</span><br><span class="line"><span class="hljs-comment">//延时10秒</span></span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"sleep 10 second..."</span>);</span><br><span class="line">sleep(<span class="hljs-number">10</span>);</span><br><span class="line"><span class="hljs-comment">//恢复队列</span></span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"resume..."</span>);</span><br><span class="line">dispatch_resume(queue);</span><br></pre></td></tr></table></figure><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">2017</span><span class="hljs-number">-08</span><span class="hljs-number">-18</span> <span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">41.261398</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">5222</span>:<span class="hljs-number">795121</span>] sleep <span class="hljs-number">1</span> second...</span><br><span class="line"><span class="hljs-number">2017</span><span class="hljs-number">-08</span><span class="hljs-number">-18</span> <span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">42.262096</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">5222</span>:<span class="hljs-number">795121</span>] suspend...</span><br><span class="line"><span class="hljs-number">2017</span><span class="hljs-number">-08</span><span class="hljs-number">-18</span> <span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">42.262496</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">5222</span>:<span class="hljs-number">795121</span>] sleep <span class="hljs-number">10</span> second...</span><br><span class="line"><span class="hljs-number">2017</span><span class="hljs-number">-08</span><span class="hljs-number">-18</span> <span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">46.263456</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">5222</span>:<span class="hljs-number">795188</span>] After <span class="hljs-number">5</span> seconds...</span><br><span class="line"><span class="hljs-number">2017</span><span class="hljs-number">-08</span><span class="hljs-number">-18</span> <span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">52.263457</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">5222</span>:<span class="hljs-number">795121</span>] resume...</span><br><span class="line"><span class="hljs-number">2017</span><span class="hljs-number">-08</span><span class="hljs-number">-18</span> <span class="hljs-number">17</span>:<span class="hljs-number">52</span>:<span class="hljs-number">57.264210</span>+<span class="hljs-number">0800</span> GCD[<span class="hljs-number">5222</span>:<span class="hljs-number">795191</span>] After <span class="hljs-number">5</span> seconds again...</span><br></pre></td></tr></table></figure><p>在dispatch_suspend挂起队列后，第一个block还是在运行，并且正常输出。</p><p>dispatch_suspend并不会立即暂停正在运行的block，而是在当前block执行完成后，暂停后续的block执行。</p><h4 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h4><p>dispatch_semaphore只有3个方法：</p><ul><li><p>dispatch_semaphore_create </p><p>执行dispatch_semaphore_create会根据传入的long类型参数创建对应数目的信号量</p></li><li><p>dispatch_semaphore_signal </p><p>执行dispatch_semaphore_singal会增加一个信号量</p></li><li><p>dispatch_semaphore_wait //等待信号量</p><p>执行dispatch_semaphore_wait如果信号量是0，就会根据传入的等待时间来等待，如果大于0则不会等待，并且会减去一个信号量</p></li></ul><p>作用：</p><ul><li><p>可以控制一个资源最多由多少个线程来访问。</p><p>如下代码所示，由于设定的信号值为2，先执行两个线程，等执行完其中一个，第三个才会继续执行。保证同一时间执行的线程数不超过2。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//crate的value表示，最多几个资源可访问</span></span><br><span class="line">   dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">2</span>);</span><br><span class="line">   <span class="hljs-built_in">dispatch_queue_t</span> quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="hljs-comment">//任务1</span></span><br><span class="line">   <span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">       dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"run task 1"</span>);</span><br><span class="line">       sleep(<span class="hljs-number">1</span>);</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"complete task 1"</span>);</span><br><span class="line">       dispatch_semaphore_signal(semaphore);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="hljs-comment">//任务2</span></span><br><span class="line">   <span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">       dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"run task 2"</span>);</span><br><span class="line">       sleep(<span class="hljs-number">1</span>);</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"complete task 2"</span>);</span><br><span class="line">       dispatch_semaphore_signal(semaphore);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="hljs-comment">//任务3</span></span><br><span class="line">   <span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;</span><br><span class="line">       dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"run task 3"</span>);</span><br><span class="line">       sleep(<span class="hljs-number">1</span>);</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"complete task 3"</span>);</span><br><span class="line">       dispatch_semaphore_signal(semaphore);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>也可以起到类似栅栏函数的作用。线程A和线程B：线程A执行完之后线程B再继续执行。</p><p>如下代码所示：先执行获取token方法，在执行request</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-comment">//这里使用dispatch_async，是为了不阻塞当前线程。</span></span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">        dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">0</span>);</span><br><span class="line">        [<span class="hljs-keyword">self</span> getToken:semaphore];</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        [<span class="hljs-keyword">self</span> request];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"继续执行啊"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//异步请求，获取token</span></span><br><span class="line">- (<span class="hljs-keyword">void</span>)getToken:(dispatch_semaphore_t)semaphore &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"getToken:%d"</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"getToken:Success"</span>);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//执行网络请求</span></span><br><span class="line">- (<span class="hljs-keyword">void</span>)request &#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"request"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ul><blockquote><p>题外话：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="hljs-built_in">NSMutableArray</span> *array = [[<span class="hljs-built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">&gt;     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i) &#123;</span><br><span class="line">&gt;         <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">&gt;             [array addObject:[<span class="hljs-built_in">NSNumber</span> numberWithInt:i]];</span><br><span class="line">&gt;         &#125;);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>上面这段代码会执行错误。报错如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="hljs-built_in">malloc</span>: *** error <span class="hljs-keyword">for</span> object <span class="hljs-number">0x6040003805b0</span>: pointer being freed was <span class="hljs-keyword">not</span> allocated</span><br><span class="line">&gt; *** <span class="hljs-built_in">set</span> a breakpoint in malloc_error_break to debug</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>为什么、？</p></blockquote><h4 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h4><p>dispatch_once函数是保证在应用程序中只执行一次指定处理的API。单例模式经常用到此函数。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="hljs-comment">//code to be executed once</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="Dispatch-I-O"><a href="#Dispatch-I-O" class="headerlink" title="Dispatch I/O"></a>Dispatch I/O</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wqhiOS/blogSources/master/GCD/gcd_logo.jpeg&quot; alt=&quot;GCD&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/categories/Objective-C/"/>
    
    
      <category term="多线程" scheme="http://www.wuqihan.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程基础篇</title>
    <link href="http://www.wuqihan.cn/2016/07/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.wuqihan.cn/2016/07/08/多线程基础/</id>
    <published>2016-07-08T02:05:17.000Z</published>
    <updated>2018-08-18T03:09:24.799Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>学习多线程之前，首先要了解什么是进程和线程，以及进程与线程的关系：</p><ul><li>进程：<ul><li>进程是指在系统中运行的一个应用程序。（比如打卡QQ,就是打开了一个进程）</li><li>每个进程之间是相互独立的，每个进程均运行在受保护的内存空间内</li></ul></li><li>线程：<ul><li>一个进程想要执行任务，必须得有线程（每个进程至少有一条线程）</li><li>进程中的所有任务都是在线程中执行的</li></ul></li><li>总结：<ul><li>进程有独立的空间地址，而线程只是一个进程中的不同执行路径。</li><li>进程是资源分配的基本单位(进程是一块包含了某些资源的内存区域)。</li><li>线程是CPU独立运行和独立调度的基本单位(可以理解为一个进程中执行的代码片段)。 </li></ul></li></ul><a id="more"></a><h4 id="关于多线程"><a href="#关于多线程" class="headerlink" title="关于多线程"></a>关于多线程</h4><p>了解了进程和线程之后，那什么是多线程呢？</p><p>1个进程中可以开启多条线程，每条线程中可以并行（同时）执行不同的任务。</p><p>多线程并发执行的原理？</p><p>在同一时间内。CPU只能处理1条线程，只有1条线程在工作（执行）。多线程并发（同时）执行，其实是CPU快速地在多线程之间调度（切换），如果CPU调度线程的时间足够快。那就造成了多线程并发执行的假象。</p><p>多线程的优缺点</p><ul><li>优点<ul><li>能适当提高程序的执行效率</li><li>能适当提高资源利用率（CPU、内存利用率）</li></ul></li><li>缺点<ul><li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序性能</li><li>线程越多，CPU在调度线程上的开销就越大</li><li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li></ul></li></ul><h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fpdmhdzvp4j30yg0mk42h.jpg" alt="mage-20180315171902"></p><p>下面分别阐述线程周期中的每一步：</p><ul><li>新建：实例化线程对象</li><li>就绪：向线程对象发送start消息，线程对象被加入可调度线程池等待CPU调度。</li><li>运行：CPU负责调度可调度线程池中线程的执行。线程执行完毕之前，状态可能会在就绪和运行之间来回切换。就绪和运行之间的状态变化有CPU负责，程序员不能干预。</li><li>阻塞：当满足某个预定条件时，可以使用休眠或锁，阻塞线程执行。sleepForTimeInterval（休眠指定时长），sleepUntilDate(休眠到指定日期),@synchronized(self)：(互斥锁)。</li><li>死亡：正常死亡，线程执行完毕。非正常死亡，当满足某个条件后，在线程内部中执行/在主线程中止线程对象</li><li>还有线程的exit和cancel</li><li>【NSThread exit】:一旦强行终止线程，后续的所有代码都不会被执行。</li><li>【thread cancel】取消，并不会直接取消线程，只是给线程对象添加isCancelled标记。</li></ul><h4 id="iOS中多线程的实现方案"><a href="#iOS中多线程的实现方案" class="headerlink" title="iOS中多线程的实现方案"></a>iOS中多线程的实现方案</h4><table><thead><tr><th></th><th style="text-align:left">特点</th><th style="text-align:left">使用语言</th><th>使用频率</th><th>线程生命周期</th></tr></thead><tbody><tr><td>pthread</td><td style="text-align:left">1）跨平台，可移植； 2）使用起来挺难吧</td><td style="text-align:left">C</td><td>几乎不用</td><td>由程序员进行管理</td></tr><tr><td>NSThread</td><td style="text-align:left">1）面向对象；2）简单，可以直接操作线程对象</td><td style="text-align:left">OC</td><td>偶尔</td><td>由程序员进行管理</td></tr><tr><td>GCD</td><td style="text-align:left">1）旨在替代NSThread等线程技术 2）充分利用设备的多核</td><td style="text-align:left">C</td><td>经常</td><td>自动管理</td></tr><tr><td>NSOperation</td><td style="text-align:left">1）底层是GCD；2）比GCD多了一些更简单实用的功能；3）实用更加面向对象</td><td style="text-align:left">OC</td><td>经常</td><td>自动管理</td></tr></tbody></table><h5 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h5><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// import &lt;phtread.h&gt;</span></span><br><span class="line"><span class="hljs-comment">//1.创建线程对象</span></span><br><span class="line">    pthread_t thread;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//2.创建线程</span></span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">     第一个参数:线程对象 传递地址</span></span><br><span class="line"><span class="hljs-comment">     第二个参数:线程的属性 NULL</span></span><br><span class="line"><span class="hljs-comment">     第三个参数:指向函数的指针</span></span><br><span class="line"><span class="hljs-comment">     第四个参数:函数需要接受的参数</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    pthread_create(&amp;thread, <span class="hljs-literal">NULL</span>, task, <span class="hljs-literal">NULL</span>);</span><br></pre></td></tr></table></figure><h5 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h5><p>(1) 基本使用</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//第一种创建线程的方式：alloc init.</span></span><br><span class="line"><span class="hljs-comment">//特点：需要手动开启线程，可以拿到线程对象进行详细设置</span></span><br><span class="line"><span class="hljs-comment">//创建线程</span></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">第一个参数：目标对象</span></span><br><span class="line"><span class="hljs-comment">第二个参数：选择器，线程启动要调用哪个方法</span></span><br><span class="line"><span class="hljs-comment">第三个参数：前面方法要接收的参数（最多只能接收一个参数，没有则传nil）</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-built_in">NSThread</span> *thread = [[<span class="hljs-built_in">NSThread</span> alloc]initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(run:) object:<span class="hljs-string">@"wendingding"</span>];</span><br><span class="line"><span class="hljs-comment">//启动线程</span></span><br><span class="line">[thread start];    </span><br><span class="line"><span class="hljs-comment">//第二种创建线程的方式：分离出一条子线程</span></span><br><span class="line"><span class="hljs-comment">//特点：自动启动线程，无法对线程进行更详细的设置</span></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">第一个参数：线程启动调用的方法</span></span><br><span class="line"><span class="hljs-comment">第二个参数：目标对象</span></span><br><span class="line"><span class="hljs-comment">第三个参数：传递给调用方法的参数</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line">[<span class="hljs-built_in">NSThread</span> detachNewThreadSelector:<span class="hljs-keyword">@selector</span>(run:) toTarget:<span class="hljs-keyword">self</span> withObject:<span class="hljs-string">@"我是分离出来的子线程"</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//第三种创建线程的方式：后台线程</span></span><br><span class="line"><span class="hljs-comment">//特点：自动启动县城，无法进行更详细设置</span></span><br><span class="line">[<span class="hljs-keyword">self</span> performSelectorInBackground:<span class="hljs-keyword">@selector</span>(run:) withObject:<span class="hljs-string">@"我是后台线程"</span>];</span><br></pre></td></tr></table></figure><p>（2）设置线程的属性</p><figure class="highlight obj-c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//设置线程的属性</span></span><br><span class="line"><span class="hljs-comment">//设置线程的名称</span></span><br><span class="line">thread.name = <span class="hljs-string">@"线程A"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//设置线程的优先级,注意线程优先级的取值范围为0.0~1.0之间，1.0表示线程的优先级最高,如果不设置该值，那么理想状态下默认为0.5</span></span><br><span class="line">thread.threadPriority = <span class="hljs-number">1.0</span>;</span><br></pre></td></tr></table></figure><p>（3）线程的状态</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//线程的各种状态：新建-就绪-运行-阻塞-死亡</span></span><br><span class="line"><span class="hljs-comment">//常用的控制线程状态的方法</span></span><br><span class="line">[<span class="hljs-built_in">NSThread</span> exit];<span class="hljs-comment">//退出当前线程</span></span><br><span class="line">[<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2.0</span>];<span class="hljs-comment">//阻塞线程</span></span><br><span class="line">[<span class="hljs-built_in">NSThread</span> sleepUntilDate:[<span class="hljs-built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="hljs-number">2.0</span>]];<span class="hljs-comment">//阻塞线程</span></span><br><span class="line"><span class="hljs-comment">//注意：线程死了不能复生</span></span><br></pre></td></tr></table></figure><p>（4）线程安全</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//线程的各种状态：新建-就绪-运行-阻塞-死亡</span></span><br><span class="line"><span class="hljs-comment">//常用的控制线程状态的方法</span></span><br><span class="line">[<span class="hljs-built_in">NSThread</span> exit];<span class="hljs-comment">//退出当前线程</span></span><br><span class="line">[<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2.0</span>];<span class="hljs-comment">//阻塞线程</span></span><br><span class="line">[<span class="hljs-built_in">NSThread</span> sleepUntilDate:[<span class="hljs-built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="hljs-number">2.0</span>]];<span class="hljs-comment">//阻塞线程</span></span><br><span class="line"><span class="hljs-comment">//注意：线程死了不能复生</span></span><br></pre></td></tr></table></figure><p>（5）线程间通信</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="hljs-keyword">void</span>)touchesBegan:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//    [self download2];</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//开启一条子线程来下载图片</span></span><br><span class="line">    [<span class="hljs-built_in">NSThread</span> detachNewThreadSelector:<span class="hljs-keyword">@selector</span>(downloadImage) toTarget:<span class="hljs-keyword">self</span> withObject:<span class="hljs-literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="hljs-keyword">void</span>)downloadImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-comment">//1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源</span></span><br><span class="line">    <span class="hljs-built_in">NSURL</span> *url = [<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@"http://p6.qhimg.com/t01d2954e2799c461ab.jpg"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//2.根据url地址下载图片数据到本地（二进制数据</span></span><br><span class="line">    <span class="hljs-built_in">NSData</span> *data = [<span class="hljs-built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//3.把下载到本地的二进制数据转换成图片</span></span><br><span class="line">    <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> imageWithData:data];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//4.回到主线程刷新UI</span></span><br><span class="line">    <span class="hljs-comment">//4.1 第一种方式</span></span><br><span class="line"><span class="hljs-comment">//    [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES];</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//4.2 第二种方式</span></span><br><span class="line"><span class="hljs-comment">//    [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES];</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//4.3 第三种方式</span></span><br><span class="line">    [<span class="hljs-keyword">self</span>.imageView performSelector:<span class="hljs-keyword">@selector</span>(setImage:) onThread:[<span class="hljs-built_in">NSThread</span> mainThread] withObject:image waitUntilDone:<span class="hljs-literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（6）如何计算代码段的执行时间</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//第一种方法</span></span><br><span class="line">    <span class="hljs-built_in">NSDate</span> *start = [<span class="hljs-built_in">NSDate</span> date];</span><br><span class="line">    <span class="hljs-comment">//2.根据url地址下载图片数据到本地（二进制数据）</span></span><br><span class="line">    <span class="hljs-built_in">NSData</span> *data = [<span class="hljs-built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-built_in">NSDate</span> *end = [<span class="hljs-built_in">NSDate</span> date];</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"第二步操作花费的时间为%f"</span>,[end timeIntervalSinceDate:start]);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//第二种方法</span></span><br><span class="line">    <span class="hljs-built_in">CFTimeInterval</span> start = <span class="hljs-built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    <span class="hljs-built_in">NSData</span> *data = [<span class="hljs-built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-built_in">CFTimeInterval</span> end = <span class="hljs-built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"第二步操作花费的时间为%f"</span>,end - start);</span><br></pre></td></tr></table></figure><h5 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h5><p>（1）基本概念</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">01</span> 两个核心概念-队列和任务</span><br><span class="line"><span class="hljs-number">02</span> 同步函数和异步函数</span><br></pre></td></tr></table></figure><p>（2）GCD基本使用</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">01</span> 异步函数+并发队列：开启多条线程，并发执行任务</span><br><span class="line"><span class="hljs-number">02</span> 异步函数+串行队列：开启一条线程，串行执行任务</span><br><span class="line"><span class="hljs-number">03</span> 同步函数+并发队列：不开线程，串行执行任务</span><br><span class="line"><span class="hljs-number">04</span> 同步函数+串行队列：不开线程，串行执行任务</span><br><span class="line"><span class="hljs-number">05</span> 异步函数+主队列：不开线程，在主线程中串行执行任务</span><br><span class="line"><span class="hljs-number">06</span> 同步函数+主队列：不开线程，串行执行任务（注意死锁发生）</span><br><span class="line"><span class="hljs-number">07</span> 注意同步函数和异步函数在执行顺序上面的差异</span><br></pre></td></tr></table></figure><p>（3）GCD间线程通信</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//0.获取一个全局的队列</span></span><br><span class="line">    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//1.先开启一个线程，把下载图片的操作放在子线程中处理</span></span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">       <span class="hljs-comment">//2.下载图片</span></span><br><span class="line">        <span class="hljs-built_in">NSURL</span> *url = [<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@"http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg"</span>];</span><br><span class="line">        <span class="hljs-built_in">NSData</span> *data = [<span class="hljs-built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> imageWithData:data];</span><br><span class="line"></span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"下载操作所在的线程--%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//3.回到主线程刷新UI</span></span><br><span class="line">        <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">           <span class="hljs-keyword">self</span>.imageView.image = image;</span><br><span class="line">           <span class="hljs-comment">//打印查看当前线程</span></span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"刷新UI---%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>（4）GCD其他常用函数</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-number">01</span> 栅栏函数（控制任务的执行顺序）</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"--dispatch_barrier_async-"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-number">02</span> 延迟执行（延迟·控制在哪个线程执行）</span><br><span class="line">  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">2.0</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"---%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-number">03</span> 一次性代码（注意不能放到懒加载）</span><br><span class="line">-(<span class="hljs-keyword">void</span>)once</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-comment">//整个程序运行过程中只会执行一次</span></span><br><span class="line">    <span class="hljs-comment">//onceToken用来记录该部分的代码是否被执行过</span></span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"-----"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-number">04</span> 快速迭代（开多个线程并发完成迭代操作）</span><br><span class="line">   dispatch_apply(subpaths.count, queue, ^(size_t index) &#123;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-number">05</span> 队列组（同栅栏函数）</span><br><span class="line"><span class="hljs-comment">//创建队列组</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"><span class="hljs-comment">//队列组中的任务执行完毕之后，执行该函数</span></span><br><span class="line">dispatch_group_notify(dispatch_group_t group,<span class="hljs-built_in">dispatch_queue_t</span> queue,dispatch_block_t block);</span><br><span class="line"></span><br><span class="line"><span class="hljs-number">06</span>进入群组和离开群组</span><br><span class="line">dispatch_group_enter(group);<span class="hljs-comment">//执行该函数后，后面异步执行的block会被gruop监听</span></span><br><span class="line">dispatch_group_leave(group);<span class="hljs-comment">//异步block中，所有的任务都执行完毕，最后离开群组</span></span><br><span class="line"><span class="hljs-comment">//注意：dispatch_group_enter|dispatch_group_leave必须成对使用</span></span><br></pre></td></tr></table></figure><h5 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h5><p>（1）基本概念</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">01</span> <span class="hljs-built_in">NSOperation</span>是对GCD的包装</span><br><span class="line"><span class="hljs-number">02</span> 两个核心概念【队列+操作】</span><br></pre></td></tr></table></figure><p>（2）基本使用</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">01</span> <span class="hljs-built_in">NSOperation</span>本身是抽象类，只能使用它的子类</span><br><span class="line"><span class="hljs-number">02</span> 三个子类分别是：<span class="hljs-built_in">NSBlockOperation</span>、<span class="hljs-built_in">NSInvocationOperation</span>以及自定义继承自<span class="hljs-built_in">NSOperation</span>的类</span><br><span class="line"><span class="hljs-number">03</span> <span class="hljs-built_in">NSOperation</span>和<span class="hljs-built_in">NSOperationQueue</span>结合使用实现多线程并发</span><br></pre></td></tr></table></figure><p>（3）相关代码</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//  01 NSInvocationOperation</span></span><br><span class="line">    <span class="hljs-comment">//1.封装操作</span></span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">     第一个参数：目标对象</span></span><br><span class="line"><span class="hljs-comment">     第二个参数：该操作要调用的方法，最多接受一个参数</span></span><br><span class="line"><span class="hljs-comment">     第三个参数：调用方法传递的参数，如果方法不接受参数，那么该值传nil</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-built_in">NSInvocationOperation</span> *operation = [[<span class="hljs-built_in">NSInvocationOperation</span> alloc]</span><br><span class="line">                                        initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(run) object:<span class="hljs-literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//2.启动操作</span></span><br><span class="line">    [operation start];</span><br><span class="line">-------------------------------------------------</span><br><span class="line">    <span class="hljs-comment">//  02 NSBlockOperation</span></span><br><span class="line">    <span class="hljs-comment">//1.封装操作</span></span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">     NSBlockOperation提供了一个类方法，在该类方法中封装操作</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-built_in">NSBlockOperation</span> *operation = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="hljs-comment">//在主线程中执行</span></span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"---download1--%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//2.追加操作，追加的操作在子线程中执行</span></span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"---download2--%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">         <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"---download3--%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//3.启动执行操作</span></span><br><span class="line">    [operation start];</span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="hljs-comment">// 03 自定义NSOperation</span></span><br><span class="line">    <span class="hljs-comment">//如何封装操作？</span></span><br><span class="line">    <span class="hljs-comment">//自定义的NSOperation,通过重写内部的main方法实现封装操作</span></span><br><span class="line">    -(<span class="hljs-keyword">void</span>)main</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"--main--%@"</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h4&gt;&lt;p&gt;学习多线程之前，首先要了解什么是进程和线程，以及进程与线程的关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程：&lt;ul&gt;
&lt;li&gt;进程是指在系统中运行的一个应用程序。（比如打卡QQ,就是打开了一个进程）&lt;/li&gt;
&lt;li&gt;每个进程之间是相互独立的，每个进程均运行在受保护的内存空间内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程：&lt;ul&gt;
&lt;li&gt;一个进程想要执行任务，必须得有线程（每个进程至少有一条线程）&lt;/li&gt;
&lt;li&gt;进程中的所有任务都是在线程中执行的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;总结：&lt;ul&gt;
&lt;li&gt;进程有独立的空间地址，而线程只是一个进程中的不同执行路径。&lt;/li&gt;
&lt;li&gt;进程是资源分配的基本单位(进程是一块包含了某些资源的内存区域)。&lt;/li&gt;
&lt;li&gt;线程是CPU独立运行和独立调度的基本单位(可以理解为一个进程中执行的代码片段)。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/categories/Objective-C/"/>
    
    
      <category term="多线程" scheme="http://www.wuqihan.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>@property与@dynamic</title>
    <link href="http://www.wuqihan.cn/2016/05/11/property%E4%B8%8E-dynamic/"/>
    <id>http://www.wuqihan.cn/2016/05/11/property与-dynamic/</id>
    <published>2016-05-11T12:48:42.000Z</published>
    <updated>2018-08-18T03:09:24.798Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/wqhiOS/blogSources/master/bg/%40dynamic_logo.jpg" alt="bg"></p><a id="more"></a><p>我们经常使用@property 声明一个属性，但是了解@property到底做了哪些事情呢？</p><p>其实property仅仅是声明了 setter 和 getter 方法（没有实现）。</p><p>@property 对应的是 @synthesize 和 @dynamic</p><p>在Xcode4.5及以后的版本中，可以省略@synthesize，编译器会默认帮你加上@synthesize ivar = _ivar;</p><p>@synthesize ivar = _ivar的作用是：</p><p>在.m文件中生成一个私有_ivar变量以及生成对应ivar的getter和setter方法的实现。</p><p>@dynamic ivar的作用是：</p><p>不会生成_ivar变量，也不会生成对应ivar的getter和setter的方法实现。只是告诉编译器,属性的setter与getter方法由用户自己实现，不自动生成。</p><p>通过一下代码可以验证，使用@dynamic ivar;的时候，不仅没有getter和setter方法，同时也并没有生成成员变量。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span></span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span></span><br><span class="line"><span class="hljs-keyword">@dynamic</span> name;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ivar_count = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> property_count = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-comment">//获取所有成员变量</span></span><br><span class="line">class_copyIvarList([Person <span class="hljs-keyword">class</span>], &amp;ivar_count);</span><br><span class="line"><span class="hljs-comment">//获取所有属性</span></span><br><span class="line">class_copyPropertyList([Person <span class="hljs-keyword">class</span>], &amp;property_count);</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d"</span>,ivar_count);</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d"</span>,property_count);</span><br><span class="line"><span class="hljs-comment">//当使用@dynamic name: ivar_count = 0;property_count = 1;</span></span><br><span class="line"><span class="hljs-comment">//当使用@synthesize :  ivar_count = 1;property_count = 1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wqhiOS/blogSources/master/bg/%40dynamic_logo.jpg&quot; alt=&quot;bg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>Objective-C类对象</title>
    <link href="http://www.wuqihan.cn/2016/05/08/Objective-C%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.wuqihan.cn/2016/05/08/Objective-C对象详解/</id>
    <published>2016-05-08T03:48:53.000Z</published>
    <updated>2018-08-18T03:09:24.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是类对象？"><a href="#什么是类对象？" class="headerlink" title="什么是类对象？"></a>什么是类对象？</h3><p>在Objective-C中任何的类定义都是对象。即在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个“描述其定义的对象”，也就是苹果公司说的类对象（class object），它是一个单例。</p><h3 id="类对象起什么作用？"><a href="#类对象起什么作用？" class="headerlink" title="类对象起什么作用？"></a>类对象起什么作用？</h3><p>Objective-C是一门很动态的语音，因此程序里的所有实例对象都是在运行时由Objective-Cd的运行时库生成的，而这个类对象就是运行时库用来创建实例对象的依据。</p><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// An opaque type that represents an Objective-Cclass.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_class</span> *<span class="hljs-title">Class</span>;</span></span><br></pre></td></tr></table></figure><p>查看objc/runtime.h中objc_class结构体的定义如下：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">struct</span> objc_class &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#if !OBJC2</span></span><br><span class="line"></span><br><span class="line">    Class _Nullablesuper_class                             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* _Nonnull name                             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    longversion                                           OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    longinfo                                              OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    longinstance_size                                     OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    structobjc_ivar_list * _Nullable ivars                 OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    structobjc_method_list * _Nullable * _NullablemethodLists                   OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    structobjc_cache * _Nonnull cache                      OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    structobjc_protocol_list * _Nullable protocols         OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#endif</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* Use Class instead of struct objc_class * */</span></span><br></pre></td></tr></table></figure><h3 id="id与objc-object"><a href="#id与objc-object" class="headerlink" title="id与objc_object"></a>id与objc_object</h3><p>“objc_object”是表示一个类的实例的结构体，它的定义如下</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/// Represents an instance of a class.</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_object</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    Class _Nonnullisa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">/// A pointer to an instance of a class.</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_object</span> *<span class="hljs-title">id</span>;</span></span><br></pre></td></tr></table></figure><p>可以看到，这个结构体只有一个变量，即指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类的方法列表以及父类的方法列表里中寻找与消息对应的selector指向的方法。</p><p>当创建一个特定类的实例对象时，分配的内存包含一个objc_object数据结构，然后是类的实例变量的数据。NSObject类的alloch和allocWithZone：方法使用函数class_creatInstance来创建objc_object数据结构。</p><h3 id="元类（Meta-Class）"><a href="#元类（Meta-Class）" class="headerlink" title="元类（Meta Class）"></a>元类（Meta Class）</h3><p>上面提到，所有的类自身也是一个对象，我们可以向这个类型发送消息（即调用类方法）。</p><p>NSArray*array = [ NSArray array];</p><p>这个例子中，+array消息发送给了NSArray类，而这个NSArray也是一个对象。既然是对象，那么它也是一个objc_object指针，它包含一个指向其类的一个isa指针。那么这些就又一个问题了。这个isa指针指向什么呢？为了调用+array方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念。</p><p>meta-class 是一个类对象的类。</p><p>当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。</p><p>meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。</p><p>再深入一下。meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类，而基类的meta-class的isa指针是指向它自己。这就形成了一个完美的闭环。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fqjknz2inxg30gm0hdgm8.gif" alt="0_1326963670oeC1"></p> <figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">void</span> testMetaClass(<span class="hljs-keyword">id</span> <span class="hljs-keyword">self</span>,SEL _cmd) &#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"This object is %p"</span>,<span class="hljs-keyword">self</span>);</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Class is %@,super class is %@"</span>,[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>],[<span class="hljs-keyword">self</span> superclass]);</span><br><span class="line">    </span><br><span class="line">    Class currentClass = [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>];</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Following the isa pointer %d times gives %p"</span>,i,currentClass);</span><br><span class="line">        currentClass = objc_getClass((__bridge <span class="hljs-keyword">void</span> *)currentClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"NSObject's class is %p"</span>,[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]);</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"NSObject's meta class is %p"</span>,objc_getClass((__bridge <span class="hljs-keyword">void</span>*)[<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">         Class newClass = objc_allocateClassPair([<span class="hljs-built_in">NSError</span> <span class="hljs-keyword">class</span>], <span class="hljs-string">"TestClass"</span>, <span class="hljs-number">0</span>);</span><br><span class="line">    class_addMethod(newClass, <span class="hljs-keyword">@selector</span>(testMetaClass), (IMP)testMetaClass, <span class="hljs-string">"v@:"</span>);</span><br><span class="line">    objc_registerClassPair(newClass);</span><br><span class="line">    <span class="hljs-keyword">id</span> instance = [[newClass alloc] initWithDomain:<span class="hljs-string">@"some domain"</span> code:<span class="hljs-number">0</span> userInfo:<span class="hljs-literal">nil</span>];</span><br><span class="line">    [instance performSelector:<span class="hljs-keyword">@selector</span>(testMetaClass)];</span><br></pre></td></tr></table></figure><p>打印输出：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">2016</span><span class="hljs-number">-05</span><span class="hljs-number">-08</span> <span class="hljs-number">16</span>:<span class="hljs-number">41</span>:<span class="hljs-number">43.414952</span>+<span class="hljs-number">0800</span> TestDemo[<span class="hljs-number">1759</span>:<span class="hljs-number">642703</span>]This object is <span class="hljs-number">0x60400025f3b0</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-number">2016</span><span class="hljs-number">-05</span><span class="hljs-number">-08</span> <span class="hljs-number">16</span>:<span class="hljs-number">41</span>:<span class="hljs-number">43.415111</span>+<span class="hljs-number">0800</span> TestDemo[<span class="hljs-number">1759</span>:<span class="hljs-number">642703</span>]Class is TestClass,super <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">is</span> <span class="hljs-title">NSError</span></span></span><br><span class="line"><span class="hljs-class"></span></span><br><span class="line"><span class="hljs-class">2016-05-08 16:</span><span class="hljs-number">41</span>:<span class="hljs-number">43.415196</span>+<span class="hljs-number">0800</span> TestDemo[<span class="hljs-number">1759</span>:<span class="hljs-number">642703</span>]Following the isa pointer <span class="hljs-number">0</span> times gives <span class="hljs-number">0x60400025f410</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-number">2016</span><span class="hljs-number">-05</span><span class="hljs-number">-08</span> <span class="hljs-number">16</span>:<span class="hljs-number">41</span>:<span class="hljs-number">43.415306</span>+<span class="hljs-number">0800</span> TestDemo[<span class="hljs-number">1759</span>:<span class="hljs-number">642703</span>]Following the isa pointer <span class="hljs-number">1</span> times gives <span class="hljs-number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-number">2016</span><span class="hljs-number">-05</span><span class="hljs-number">-08</span> <span class="hljs-number">16</span>:<span class="hljs-number">41</span>:<span class="hljs-number">43.415398</span>+<span class="hljs-number">0800</span> TestDemo[<span class="hljs-number">1759</span>:<span class="hljs-number">642703</span>]Following the isa pointer <span class="hljs-number">2</span> times gives <span class="hljs-number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-number">2016</span><span class="hljs-number">-05</span><span class="hljs-number">-08</span> <span class="hljs-number">16</span>:<span class="hljs-number">41</span>:<span class="hljs-number">43.415608</span>+<span class="hljs-number">0800</span> TestDemo[<span class="hljs-number">1759</span>:<span class="hljs-number">642703</span>]Following the isa pointer <span class="hljs-number">3</span> times gives <span class="hljs-number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-number">2016</span><span class="hljs-number">-05</span><span class="hljs-number">-08</span> <span class="hljs-number">16</span>:<span class="hljs-number">41</span>:<span class="hljs-number">43.415697</span>+<span class="hljs-number">0800</span> TestDemo[<span class="hljs-number">1759</span>:<span class="hljs-number">642703</span>]NSObject's <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">is</span> 0<span class="hljs-title">x102efeea8</span></span></span><br><span class="line"><span class="hljs-class"></span></span><br><span class="line"><span class="hljs-class">2016-05-08 16:</span><span class="hljs-number">41</span>:<span class="hljs-number">43.415783</span>+<span class="hljs-number">0800</span> TestDemo[<span class="hljs-number">1759</span>:<span class="hljs-number">642703</span>]NSObject's meta <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">is</span> 0<span class="hljs-title">x0</span></span></span><br></pre></td></tr></table></figure><p>在for循环中，我们通过objc_getClass来获取对象的isa，并将其打印出来，以此一直回溯到NSObject的meta-class。分析打印结果，可以看到最后指针指向的地址是0x0。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是类对象？&quot;&gt;&lt;a href=&quot;#什么是类对象？&quot; class=&quot;headerlink&quot; title=&quot;什么是类对象？&quot;&gt;&lt;/a&gt;什么是类对象？&lt;/h3&gt;&lt;p&gt;在Objective-C中任何的类定义都是对象。即在程序启动的时候任何类定义都对应于一块内存。在编译
      
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.wuqihan.cn/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS绘制手势解锁</title>
    <link href="http://www.wuqihan.cn/2016/04/02/iOS%E7%BB%98%E5%88%B6%E6%89%8B%E5%8A%BF%E8%A7%A3%E9%94%81/"/>
    <id>http://www.wuqihan.cn/2016/04/02/iOS绘制手势解锁/</id>
    <published>2016-04-02T09:25:02.000Z</published>
    <updated>2018-08-18T03:09:24.798Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/651642-deeb6d6a8fd78aea.gif?imageMogr2/auto-orient/strip" alt="WUGesturesToUnlock.gif"><br><a id="more"></a><br>手势解锁这个功能其实已经用的越来越少了。但是郁闷不知道我公司为什么每次做一个app都要把手势解锁加上。。。。。于是就自己研究了一下手势解锁页面的实现。。<br>　　要想实现这个页面，先说说需要掌握哪些：<br>UIPanGestureRecognizer的基本使用<br>CGRectContainsPoint(&lt;#CGRect rect#&gt;, &lt;#CGPoint point#&gt;)<br>UIBezierPath贝塞尔曲线的绘制<br>drawRect 和 layoutIfNeeded 知道何时，如何使用</p><p><em>　　只要掌握上面说的四点，实现手势解锁就很简单了。上面说的初学者可以自己谷歌学习，学完后再去看我的手势解锁代码，应该就会很明白了。</em> 并且已经适配所有尺寸的iPhone，可以自定义UI<br>源码地址：<a href="https://github.com/wqhiOS/WUGesturesToUnlock" target="_blank" rel="noopener">https://github.com/wqhiOS/WUGesturesToUnlock</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/651642-deeb6d6a8fd78aea.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;WUGesturesToUnlock.gif&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
